<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Founding of Rome ‚Äî Complete Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="Build your Roman Empire through Trade, Military, Settlement, and Resources. Conquer the Italian peninsula." />
<style>

/* Fast Battles toggle switch */
.fast-toggle{
  display:inline-flex;
  align-items:center;
  gap:10px;
  cursor:pointer;
  user-select:none;
  font-weight:800;
}
.fast-toggle input{
  position:absolute;
  opacity:0;
  width:0; height:0;
}
.fast-switch{
  width:42px; height:24px;
  border-radius:999px;
  border:1px solid var(--line);
  background:#eee;
  position:relative;
  transition:all .2s ease;
  box-shadow:inset 0 1px 3px rgba(0,0,0,.1);
}
.fast-switch::after{
  content:'';
  position:absolute;
  top:2px; left:2px;
  width:20px; height:20px;
  border-radius:50%;
  background:#fff;
  box-shadow:0 1px 2px rgba(0,0,0,.2);
  transition:transform .2s ease;
}
.fast-toggle input:checked + .fast-switch{
  background:#fde68a;
  border-color:var(--roman-gold);
}
.fast-toggle input:checked + .fast-switch::after{
  transform:translateX(18px);
}
.fast-label{ font-size:14px; }



/* Battle speed controls inside header */
.battle-speed-controls{
  margin-left:auto;
  display:flex;
  gap:8px;
}


:root{
  /* Global battle speed & duration/iterations */
  --battle-speed: 0.35;                 /* Faster default: 0.35 instead of 0.6 */
  --battle-dur: calc(0.8s * var(--battle-speed));  /* Reduced base from 1.2s to 0.8s */
  --battle-iters: 1;                   /* Reduced from 2 to 1 iteration */
  --spark-dur: calc(0.4s * var(--battle-speed));  /* Reduced base from 0.6s to 0.4s */
  --spark-iters: 2;                    /* Reduced from 3 to 2 iterations */
}

/* Optional presets (toggle these on <body> or .battle-screen) */
.fast-battles { --battle-speed: 0.2; --battle-iters: 1; --spark-iters: 1; }  /* Much faster */
.instant-battles { --battle-speed: 0.05; --battle-iters: 1; --spark-iters: 1; }  /* Nearly instant */

:root{
    --bg:#f6f1e6; --paper:#fffdf7; --ink:#232323; --muted:#6b7280; --line:#e6dccb;
    --roman-red:#7a1f1f; --roman-gold:#b8860b; --accent:#7a3b00;
    --trade-color:#2563eb; --military-color:#dc2626; --settlement-color:#16a34a;
  }
  
  *{box-sizing:border-box}
  
  body{
    margin:0;
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
    color:var(--ink);
    background:
      radial-gradient(rgba(184,134,11,.06) 1px, transparent 1px) 0 0/22px 22px,
      radial-gradient(rgba(122,31,31,.05) 1px, transparent 1px) 11px 11px/44px 44px,
      linear-gradient(180deg,#fbf8f1,var(--bg));
    min-height:100vh;
  }
  
  .container{max-width:1400px;margin:0 auto;padding:22px}
  
  .card{
    background:var(--paper);
    border:1px solid var(--line);
    border-radius:22px;
    padding:16px;
    box-shadow:0 6px 18px rgba(0,0,0,.06);
    margin-bottom:12px;
    transition:all .3s ease;
  }
  
  .card:hover{
    box-shadow:0 8px 24px rgba(0,0,0,.1);
    transform:translateY(-2px);
  }
  
  .header{
    display:flex;
    gap:12px;
    align-items:center;
    background:linear-gradient(180deg,#fff8ef,#fcf7ea);
    border:1px solid var(--line);
    padding:10px 14px;
    border-radius:22px;
    outline:3px double var(--roman-gold);
    box-shadow:0 4px 12px rgba(184,134,11,.15);
    margin-bottom:16px;
  }
  
  h1{
    font-size:26px;
    margin:0;
    font-weight:900;
    color:var(--roman-red);
    text-shadow:1px 1px 0 rgba(255,255,255,.5);
  }
  
  h2{font-size:20px;margin:12px 0 8px;font-weight:800}
  h3{font-size:16px;margin:8px 0 6px;font-weight:800}
  
  .subtitle{
    font-size:13px;
    color:#555;
    line-height:1.4;
  }
  
  .grid{display:grid;gap:10px}
  .g2{grid-template-columns:1fr 1fr}
  .g3{grid-template-columns:repeat(3,1fr)}
  .g4{grid-template-columns:repeat(4,1fr)}
  .g5{grid-template-columns:repeat(5,1fr)}
  
  .pill{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:6px 10px;
    border-radius:999px;
    font-size:13px;
    font-weight:700;
    border:1px solid var(--line);
    background:#fff;
    transition:all .2s ease;
  }
  
  .pill:hover{
    transform:scale(1.05);
    box-shadow:0 2px 6px rgba(0,0,0,.1);
  }
  
  .choice{
    border:1px solid var(--line);
    border-radius:14px;
    background:#fff;
    padding:12px;
    cursor:pointer;
    transition:all .2s ease;
  }
  
  .choice:hover{
    background:#fff9f3;
    box-shadow:0 2px 8px rgba(0,0,0,.08);
    transform:translateY(-1px);
    border-color:var(--roman-gold);
  }
  
  .choice:active{
    transform:translateY(0);
  }
  
  .choice.selected{
    outline:2px solid var(--roman-gold);
    background:#fffbf5;
  }
  
  .small{font-size:12px;color:#6b7280}
  .tiny{font-size:11px;color:#9ca3af}
  
  .tag{
    display:inline-block;
    font-size:12px;
    padding:4px 8px;
    border-radius:999px;
    border:1px solid var(--line);
    background:#fff;
    transition:all .2s ease;
  }
  
  .divider{
    height:1px;
    background:linear-gradient(90deg,transparent,var(--line),transparent);
    margin:12px 0;
  }
  
  .btn{
    appearance:none;
    border:1px solid var(--line);
    background:#fff;
    color:#111;
    padding:10px 14px;
    border-radius:12px;
    font-weight:800;
    cursor:pointer;
    font-size:14px;
    transition:all .2s ease;
    box-shadow:0 1px 3px rgba(0,0,0,.05);
  }
  
  .btn:hover:not(:disabled){
    background:#faf2e6;
    transform:translateY(-2px);
    box-shadow:0 4px 8px rgba(0,0,0,.1);
  }
  
  .btn:active:not(:disabled){
    transform:translateY(0);
  }
  
  .btn:disabled{
    opacity:0.5;
    cursor:not-allowed;
    transform:none !important;
  }
  
  .btn-primary{
    background:var(--roman-red);
    color:#fff;
    border-color:#5e1818;
    box-shadow:0 2px 0 #5e1818, 0 4px 8px rgba(122,31,31,.2);
  }
  
  .btn-primary:hover:not(:disabled){
    background:#8e2a2a;
    box-shadow:0 2px 0 #5e1818, 0 6px 12px rgba(122,31,31,.3);
  }
  
  .btn-success{
    background:var(--settlement-color);
    color:#fff;
    border-color:#15803d;
    box-shadow:0 2px 0 #15803d, 0 4px 8px rgba(22,163,74,.2);
  }
  
  .btn-success:hover:not(:disabled){
    background:#166534;
    box-shadow:0 2px 0 #15803d, 0 6px 12px rgba(22,163,74,.3);
  }
  
  .statbar{
    height:10px;
    border-radius:6px;
    background:#eee;
    overflow:hidden;
    position:relative;
    box-shadow:inset 0 1px 3px rgba(0,0,0,.1);
  }
  
  .bar{
    height:100%;
    transition:width 0.5s ease;
    position:relative;
    background:linear-gradient(90deg, var(--roman-gold), #d4af37);
  }
  
  .bar::after{
    content:'';
    position:absolute;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:linear-gradient(90deg, transparent, rgba(255,255,255,.3), transparent);
    animation:shimmer 2s infinite;
  }
  
  @keyframes shimmer{
    0%{transform:translateX(-100%)}
    100%{transform:translateX(100%)}
  }
  
  .tabs{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    margin-bottom:8px;
  }
  
  .tab{
    padding:8px 12px;
    border:1px solid var(--line);
    border-radius:999px;
    background:#fff;
    cursor:pointer;
    font-weight:800;
    font-size:13px;
    transition:all .2s ease;
  }
  
  .tab:hover{
    background:#f9fafb;
    transform:translateY(-1px);
    box-shadow:0 2px 6px rgba(0,0,0,.08);
  }
  
  .tab.active{
    background:linear-gradient(135deg,#fff0e6,#ffe8d6);
    border-color:#e6cfa8;
    box-shadow:inset 0 1px 3px rgba(184,134,11,.2);
  }
  
  .info{
    background:linear-gradient(135deg,#eff6ff,#e0f2fe);
    border:1px solid #bfdbfe;
    padding:8px 12px;
    border-radius:8px;
    margin:8px 0;
    font-size:13px;
  }
  
  .success{color:#16a34a;font-weight:700}
  .warning{color:#dc2626;font-weight:700}
  
  .milestone{
    background:linear-gradient(135deg,#fef3c7,#fde68a);
    border:2px solid var(--roman-gold);
    padding:10px;
    border-radius:12px;
    margin:8px 0;
    font-weight:700;
    animation:milestoneGlow 2s ease-in-out infinite;
  }
  
  @keyframes milestoneGlow{
    0%,100%{box-shadow:0 0 10px rgba(184,134,11,.3)}
    50%{box-shadow:0 0 20px rgba(184,134,11,.6)}
  }
  
  .map-container{
    background:linear-gradient(135deg,#f9fafb,#f3f4f6);
    border:2px solid var(--line);
    border-radius:12px;
    padding:16px;
    margin:12px 0;
  }
  
  .map-grid{
    display:flex;
    flex-wrap:wrap;
    gap:12px;
    margin-top:12px;
    justify-content:center;
    align-items:flex-start;
  }
  
  .territory{
    position:relative;
    width:140px;
    height:160px;
    clip-path:polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
    border:3px solid #d1d5db;
    padding:16px 8px;
    text-align:center;
    cursor:pointer;
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
    transition:all 0.3s ease;
  }
  
  .territory:hover:not(.locked){
    transform:scale(1.08) rotate(2deg);
    box-shadow:0 8px 16px rgba(0,0,0,0.15);
    z-index:10;
  }
  
  .territory.owned{
    background:linear-gradient(135deg,#dcfce7,#bbf7d0);
    border-color:#16a34a;
    box-shadow:0 0 12px rgba(22,163,74,0.3);
  }
  
  .territory.contested{
    background:linear-gradient(135deg,#fef3c7,#fde68a);
    border-color:#ca8a04;
    box-shadow:0 0 12px rgba(202,138,4,0.3);
  }
  
  .territory.hostile{
    background:linear-gradient(135deg,#fee2e2,#fecaca);
    border-color:#dc2626;
    box-shadow:0 0 12px rgba(220,38,38,0.3);
  }
  
  .territory.hostile-hard{
    background:linear-gradient(135deg,#450a0a,#7f1d1d);
    color:#fff;
    border-color:#991b1b;
    box-shadow:0 0 16px rgba(153,27,27,0.5);
  }
  
  .territory.locked{
    opacity:0.4;
    cursor:not-allowed;
    filter:grayscale(0.8);
  }
  
  .map-tabs{
    display:flex;
    gap:8px;
    margin-bottom:12px;
    flex-wrap:wrap;
  }
  
  .rarity{
    display:inline-block;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:4px;
    margin-left:4px;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }
  
  .rarity-common{color:#6b7280;border:1px solid #d1d5db}
  .rarity-uncommon{color:#16a34a;border:1px solid #86efac;background:rgba(22,163,74,0.05)}
  .rarity-rare{color:#2563eb;border:1px solid #60a5fa;background:rgba(37,99,235,0.05)}
  .rarity-epic{color:#9333ea;border:1px solid #c084fc;background:rgba(147,51,234,0.05)}
  .rarity-legendary{color:#ea580c;border:1px solid #fb923c;background:rgba(234,88,12,0.05)}
  .rarity-imperial{
    color:#dc2626;
    border:1px solid #fca5a5;
    background:linear-gradient(90deg,rgba(220,38,38,0.1),rgba(234,88,12,0.1),rgba(234,179,8,0.1));
    font-weight:900;
    animation:imperial-glow 2s ease-in-out infinite;
  }
  
  @keyframes imperial-glow{
    0%,100%{text-shadow:0 0 4px rgba(220,38,38,0.5)}
    50%{text-shadow:0 0 8px rgba(220,38,38,0.8),0 0 12px rgba(234,88,12,0.5)}
  }
  
  .save-load-btn{
    position:fixed;
    top:20px;
    right:20px;
    z-index:1000;
    display:flex;
    gap:8px;
    flex-direction:column;
  }
  
  .battle-screen{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.95);
    z-index:9999;
    display:flex;
    align-items:center;
    justify-content:center;
    animation:fadeIn 0.4s;
  }
  
  @keyframes fadeIn{
    from{opacity:0}
    to{opacity:1}
  }
  
  .battle-card{
    background:var(--paper);
    border:3px solid var(--roman-red);
    border-radius:16px;
    padding:24px;
    max-width:600px;
    width:90%;
    box-shadow:0 20px 60px rgba(0,0,0,0.5);
    animation:slideUp 0.5s ease;
  }
  
  @keyframes slideUp{
    from{transform:translateY(50px);opacity:0}
    to{transform:translateY(0);opacity:1}
  }
  
  .battle-animation{
    width:100%;
    height:200px;
    background:linear-gradient(180deg,#fee2e2,#fef3c7);
    border-radius:12px;
    margin:16px 0;
    position:relative;
    overflow:hidden;
    border:2px solid var(--line);
  }
  
  .battle-unit{
    position:absolute;
    width:40px;
    height:40px;
    font-size:32px;
    will-change: transform;
    transform: translateZ(0);  /* Force GPU acceleration */
    backface-visibility: hidden;  /* Improve animation performance */
  }
  
  .unit-left{
    left:20%;
    top:50%;
    transform:translateY(-50%);
    animation: battle-attack-left var(--battle-dur) ease-in-out var(--battle-iters) forwards;
  }
  
  .unit-right{
    right:20%;
    top:50%;
    transform:translateY(-50%);
    animation: battle-attack-right var(--battle-dur) ease-in-out var(--battle-iters) forwards;
  }
  
  @keyframes battle-attack-left{
    0%,100%{transform:translateY(-50%) translateX(0) scale(1)}
    25%{transform:translateY(-50%) translateX(20px) scale(1.2)}
    50%{transform:translateY(-50%) translateX(0) scale(1)}
  }
  
  @keyframes battle-attack-right{
    0%,100%{transform:translateY(-50%) translateX(0) scale(1)}
    25%{transform:translateY(-50%) translateX(-20px) scale(1.2)}
    50%{transform:translateY(-50%) translateX(0) scale(1)}
  }
  
  .battle-effects{
    position:absolute;
    inset:0;
    pointer-events:none;
  }
  
  .battle-spark{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%) translateZ(0);  /* GPU acceleration */
    font-size:24px;
    animation: spark var(--spark-dur) ease-out var(--spark-iters) forwards;
    will-change: transform, opacity;
    backface-visibility: hidden;
  }
  
  @keyframes spark{
    0%{opacity:1;transform:translate(-50%,-50%) scale(0.5) rotate(0deg)}
    50%{opacity:0.8;transform:translate(-50%,-50%) scale(1.2) rotate(180deg)}
    100%{opacity:0;transform:translate(-50%,-50%) scale(2) rotate(360deg)}
  }
  
  .win-chance{
    font-size:28px;
    font-weight:900;
    text-align:center;
    margin:12px 0;
    padding:12px;
    border-radius:8px;
  }
  
  .win-high{background:linear-gradient(135deg,#dcfce7,#bbf7d0);color:#15803d}
  .win-medium{background:linear-gradient(135deg,#fef3c7,#fde68a);color:#b45309}
  .win-low{background:linear-gradient(135deg,#fee2e2,#fecaca);color:#991b1b}
  
  .snake-game{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.95);
    z-index:9999;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
  }
  
  .snake-canvas{
    border:4px solid var(--roman-gold);
    background:#1a1a1a;
    box-shadow:0 20px 60px rgba(0,0,0,0.8), 0 0 40px rgba(184,134,11,.3);
  }
  
  .snake-score{
    color:#fff;
    font-size:24px;
    font-weight:900;
    margin-bottom:16px;
    text-shadow:0 2px 4px rgba(0,0,0,0.5), 0 0 20px rgba(184,134,11,.5);
  }
  
  .snake-controls{
    color:#aaa;
    font-size:14px;
    margin-top:16px;
    text-align:center;
  }
  
  .territory img{
    width:100%;
    height:80px;
    object-fit:cover;
    border-radius:6px;
    margin-bottom:8px;
  }
  
  .resource-production{
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    margin:8px 0;
  }
  
  .production-item{
    background:#fff;
    border:1px solid var(--line);
    padding:8px 12px;
    border-radius:8px;
    display:flex;
    align-items:center;
    gap:8px;
    transition:all .2s ease;
  }
  
  .production-item:hover{
    transform:translateY(-2px);
    box-shadow:0 2px 8px rgba(0,0,0,.08);
  }
  
  /* NEW FEATURES STYLING */
  .advisor{
    position:fixed;
    bottom:20px;
    right:20px;
    max-width:300px;
    background:linear-gradient(135deg,#fef3c7,#fde68a);
    border:2px solid var(--roman-gold);
    border-radius:12px;
    padding:12px 16px;
    box-shadow:0 8px 24px rgba(0,0,0,0.15);
    z-index:999;
    animation:slideInRight 0.4s ease;
  }

  /* Tutorial pop‚Äëup styling */
  .tutorialPopup{
    position:fixed;
    top:30%;
    left:50%;
    transform:translate(-50%, -50%);
    background:linear-gradient(135deg,#fffbe6,#fef9c3);
    border:2px solid var(--roman-gold);
    border-radius:12px;
    padding:20px;
    width:300px;
    max-width:80%;
    text-align:center;
    font-family:inherit;
    box-shadow:0 8px 24px rgba(0,0,0,0.2);
    z-index:2000;
  }
  .tutorialPopup p{
    margin:0 0 12px 0;
    line-height:1.5;
    font-size:14px;
    color:#333;
  }
  .tutorialPopup button{
    background:var(--roman-gold);
    color:#1f2937;
    border:none;
    border-radius:6px;
    padding:6px 16px;
    font-weight:600;
    cursor:pointer;
    transition:background 0.2s ease;
  }
  .tutorialPopup button:hover{
    background:var(--roman-red);
    color:white;
  }
  
  @keyframes slideInRight{
    from{transform:translateX(100%);opacity:0}
    to{transform:translateX(0);opacity:1}
  }
  
  .advisor-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:8px;
  }
  
  .advisor-title{
    font-weight:900;
    font-size:14px;
    color:var(--roman-red);
  }
  
  .advisor-close{
    cursor:pointer;
    font-size:18px;
    line-height:1;
    color:#666;
    font-weight:900;
    transition:all .2s ease;
  }
  
  .advisor-close:hover{
    color:var(--roman-red);
    transform:scale(1.2);
  }
  
  .advisor-body{
    font-size:13px;
    line-height:1.5;
    color:#333;
  }
  
  .achievement-notification{
    position:fixed;
    top:80px;
    right:20px;
    max-width:320px;
    background:linear-gradient(135deg,#fff,#fef3c7);
    border:2px solid var(--roman-gold);
    border-radius:12px;
    padding:12px 16px;
    box-shadow:0 8px 24px rgba(0,0,0,0.2);
    z-index:9998;
    animation:achievementPop 0.5s ease;
  }
  
  @keyframes achievementPop{
    0%{transform:scale(0.5) rotate(-5deg);opacity:0}
    50%{transform:scale(1.1) rotate(2deg)}
    100%{transform:scale(1) rotate(0);opacity:1}
  }
  
  .achievement-icon{
    font-size:40px;
    text-align:center;
    margin-bottom:8px;
    animation:bounce 1s ease infinite;
  }
  
  @keyframes bounce{
    0%,100%{transform:translateY(0)}
    50%{transform:translateY(-10px)}
  }
  
  .achievement-title{
    font-weight:900;
    font-size:14px;
    color:var(--roman-red);
    text-align:center;
    margin:4px 0;
  }
  
  .achievement-desc{
    font-size:12px;
    color:#555;
    text-align:center;
    margin:4px 0;
  }
  
  .achievement-reward{
    font-size:11px;
    color:#16a34a;
    font-weight:700;
    text-align:center;
    margin-top:8px;
  }
  
  .tooltip{
    position:relative;
    display:inline-block;
  }
  
  .tooltip .tooltiptext{
    visibility:hidden;
    width:200px;
    background-color:#333;
    color:#fff;
    text-align:center;
    border-radius:6px;
    padding:8px;
    position:absolute;
    z-index:1000;
    bottom:125%;
    left:50%;
    margin-left:-100px;
    opacity:0;
    transition:opacity 0.3s;
    font-size:12px;
    line-height:1.4;
  }
  
  .tooltip:hover .tooltiptext{
    visibility:visible;
    opacity:0.95;
  }
  
  .tooltip .tooltiptext::after{
    content:"";
    position:absolute;
    top:100%;
    left:50%;
    margin-left:-5px;
    border-width:5px;
    border-style:solid;
    border-color:#333 transparent transparent transparent;
  }
  
  .achievement-badge{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:6px 12px;
    border-radius:999px;
    background:linear-gradient(135deg,#fef3c7,#fde68a);
    border:2px solid var(--roman-gold);
    font-size:12px;
    font-weight:800;
    margin:4px;
    box-shadow:0 2px 6px rgba(0,0,0,0.1);
    transition:all .2s ease;
  }
  
  .achievement-badge:hover{
    transform:scale(1.05);
    box-shadow:0 4px 12px rgba(0,0,0,0.15);
  }
  
  .achievement-badge.locked{
    opacity:0.4;
    background:#f3f4f6;
    border-color:#d1d5db;
  }
  
  .quest-card{
    background:linear-gradient(135deg,#eff6ff,#dbeafe);
    border:2px solid #3b82f6;
    border-radius:12px;
    padding:12px;
    margin:8px 0;
    transition:all .2s ease;
  }
  
  .quest-card:hover{
    transform:translateY(-2px);
    box-shadow:0 4px 12px rgba(59,130,246,0.2);
  }
  
  .quest-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:8px;
  }
  
  .quest-title{
    font-weight:900;
    font-size:14px;
    color:#1e40af;
  }
  
  .quest-progress{
    font-size:12px;
    color:#3b82f6;
    font-weight:700;
  }
  
  .quest-desc{
    font-size:12px;
    color:#1e3a8a;
    margin-bottom:6px;
  }
  
  .quest-reward{
    font-size:11px;
    color:#1e40af;
    font-weight:700;
    background:rgba(59,130,246,0.1);
    padding:4px 8px;
    border-radius:6px;
    display:inline-block;
  }
  
  .combo-card{
    background:#fff;
    border:2px solid var(--line);
    border-radius:12px;
    padding:12px;
    margin:8px 0;
    transition:all 0.3s;
  }
  
  .combo-card:hover{
    border-color:var(--roman-gold);
    box-shadow:0 4px 12px rgba(0,0,0,0.1);
    transform:translateY(-2px);
  }
  
  .combo-cost{
    display:flex;
    gap:8px;
    margin:8px 0;
    flex-wrap:wrap;
  }
  
  .combo-cost-item{
    background:#f3f4f6;
    padding:4px 8px;
    border-radius:6px;
    font-size:12px;
    font-weight:700;
  }
  
  .season-indicator{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:6px 12px;
    border-radius:999px;
    background:rgba(255,255,255,0.9);
    border:2px solid var(--line);
    font-size:13px;
    font-weight:800;
    box-shadow:0 2px 6px rgba(0,0,0,.05);
  }
  
  .building-level{
    display:inline-flex;
    align-items:center;
    gap:2px;
    margin-left:6px;
  }
  
  .building-level .star{
    color:var(--roman-gold);
    font-size:14px;
    animation:starTwinkle 2s ease-in-out infinite;
  }
  
  @keyframes starTwinkle{
    0%,100%{opacity:1;transform:scale(1)}
    50%{opacity:0.7;transform:scale(0.9)}
  }
  
  .specialization-badge{
    display:inline-block;
    padding:3px 8px;
    border-radius:999px;
    font-size:11px;
    font-weight:800;
    margin-left:6px;
  }
  
  .spec-military{background:rgba(220,38,38,0.1);color:#dc2626;border:1px solid #fca5a5}
  .spec-trade{background:rgba(37,99,235,0.1);color:#2563eb;border:1px solid #93c5fd}
  .spec-farm{background:rgba(22,163,74,0.1);color:#16a34a;border:1px solid #86efac}
  .spec-mine{background:rgba(120,53,15,0.1);color:#78350f;border:1px solid #d97706}
  
  .stat-change{
    display:inline-block;
    margin-left:6px;
    font-size:12px;
    font-weight:700;
    animation:statChange 0.5s ease;
  }
  
  .stat-change.positive{color:#16a34a}
  .stat-change.negative{color:#dc2626}
  
  @keyframes statChange{
    0%{transform:scale(0.8) translateY(10px);opacity:0}
    50%{transform:scale(1.2) translateY(-5px)}
    100%{transform:scale(1) translateY(0);opacity:1}
  }
  
  @media(max-width:768px){
    .g3,.g4,.g5{grid-template-columns:1fr}
    .g2{grid-template-columns:1fr}
    .map-grid{gap:8px}
    .territory{width:120px;height:140px;font-size:11px}
    .advisor{max-width:260px;bottom:10px;right:10px;left:10px}
    .achievement-notification{max-width:280px;top:60px;right:10px;left:10px}
    .save-load-btn{top:10px;right:10px}
    .container{padding:12px}
  }

/* === Performance & Reduced Motion improvements === */
@media (prefers-reduced-motion: reduce) {
  *,*::before,*::after {
    animation-duration: 0.001ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.001ms !important;
    scroll-behavior: auto !important;
  }
}

/* Hide legacy Save/Load/Delete controls within a scoped container.
   This prevents unintended hiding of in‚Äëgame buttons that share similar attributes. */
#app .save-load-btn-legacy [data-action="save"],
#app .save-load-btn-legacy [data-action="load"],
#app .save-load-btn-legacy [data-action="delete"] {
  display: none !important;
}

/* Ensure no duplicate tabs appear */
.tabs .tab[data-focus="military"]:nth-of-type(n+2),
.tabs .tab[data-focus="tracker"]:nth-of-type(n+2) {
  display: none !important;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 12px;
}

::-webkit-scrollbar-track {
  background: var(--bg);
}

::-webkit-scrollbar-thumb {
  background: var(--line);
  border-radius: 6px;
  border: 2px solid var(--bg);
}

::-webkit-scrollbar-thumb:hover {
  background: var(--roman-gold);
}

/* Loading indicator */
@keyframes spin {
  to { transform: rotate(360deg); }
}

.loading {
  border: 3px solid var(--line);
  border-top-color: var(--roman-gold);
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: 20px auto;
}

/* Pulse effect for new items */
@keyframes pulse {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(184, 134, 11, 0.7);
  }
  50% {
    box-shadow: 0 0 0 10px rgba(184, 134, 11, 0);
  }
}

.new-item {
  animation: pulse 2s ease-in-out infinite;
}

/* Trade System Styles */
.trade-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 10px;
  margin: 12px 0;
}

.trade-stat-box {
  background: linear-gradient(135deg, #fff9f3, #ffffff);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 12px;
  text-align: center;
}

.trade-stat-value {
  font-size: 24px;
  font-weight: 900;
  color: var(--trade-color);
  margin: 4px 0;
}

.trade-stat-label {
  font-size: 11px;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.reputation-bar {
  height: 6px;
  background: #e5e7eb;
  border-radius: 3px;
  overflow: hidden;
  margin-top: 4px;
}

.reputation-fill {
  height: 100%;
  background: linear-gradient(90deg, #10b981, #059669);
  transition: width 0.3s ease;
}

.caravan-in-transit {
  background: linear-gradient(135deg, #dbeafe, #bfdbfe);
  border: 2px dashed var(--trade-color);
  animation: pulse-trade 2s ease-in-out infinite;
}

@keyframes pulse-trade {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.8; }
}

.trade-route-active {
  border-left: 4px solid var(--settlement-color);
}

.price-trend-up {
  color: #10b981;
  font-weight: 800;
}

.price-trend-down {
  color: #ef4444;
  font-weight: 800;
}

/* ==================== TERRITORY MANAGEMENT ENHANCEMENTS ==================== */
.territory-event-notification {
  animation: slideInRight 0.3s ease-out;
}

@keyframes slideInRight {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

.territory.owned {
  background: linear-gradient(135deg, #dcfce7, #d1fae5);
  border-color: #86efac;
  cursor: pointer;
}

.territory.owned:hover {
  background: linear-gradient(135deg, #bbf7d0, #d1fae5);
  transform: translateY(-2px) scale(1.02);
}

.garrison-indicator {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border-radius: 999px;
  background: #eff6ff;
  border: 1px solid #bfdbfe;
  font-size: 11px;
  font-weight: 700;
}

.stability-bar {
  height: 8px;
  background: #e5e7eb;
  border-radius: 4px;
  overflow: hidden;
}

.stability-fill {
  height: 100%;
  transition: width 0.3s ease, background-color 0.3s ease;
}

.stability-fill.high { background: linear-gradient(90deg, #10b981, #059669); }
.stability-fill.medium { background: linear-gradient(90deg, #f59e0b, #d97706); }
.stability-fill.low { background: linear-gradient(90deg, #ef4444, #dc2626); }

.development-path-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
  background: linear-gradient(135deg, #fef3c7, #fde68a);
  border: 1px solid var(--roman-gold);
}

.governor-portrait {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--roman-gold), #d4af37);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  border: 2px solid var(--line);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.building-slot {
  min-height: 120px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.territory-income-display {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  border-radius: 12px;
  background: linear-gradient(135deg, #fef3c7, #fde68a);
  border: 1px solid var(--roman-gold);
  font-weight: 800;
  box-shadow: 0 2px 4px rgba(184,134,11,0.2);
}

.territory-bonus-tag {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 700;
  background: #f0fdf4;
  border: 1px solid #86efac;
  color: #15803d;
}

.territory-malus-tag {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 700;
  background: #fef2f2;
  border: 1px solid #fca5a5;
  color: #dc2626;
}

.map-tabs {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
  flex-wrap: wrap;
}

.map-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 12px;
}

.territory {
  position: relative;
  padding: 12px;
  border-radius: 12px;
  border: 2px solid var(--line);
  background: var(--paper);
  transition: all 0.2s ease;
  min-height: 120px;
  display: flex;
  flex-direction: column;
}

.territory.contested {
  background: linear-gradient(135deg, #fef3c7, #fde68a);
  border-color: #fbbf24;
}

.territory.hostile {
  background: linear-gradient(135deg, #fee2e2, #fecaca);
  border-color: #fca5a5;
}

.territory.hostile-hard {
  background: linear-gradient(135deg, #fef2f2, #fee2e2);
  border-color: #ef4444;
}

.territory.locked {
  background: #f9fafb;
  border-color: #d1d5db;
  opacity: 0.6;
  cursor: not-allowed;
}

.territory:not(.locked):hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.15);
}

.production-summary {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 8px;
  margin: 12px 0;
}

.production-item {
  background: white;
  border: 1px solid var(--line);
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  font-size: 12px;
}

.production-item.boosted {
  background: #f0fdf4;
  border-color: #86efac;
}

@keyframes territoryPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.02); }
}

.territory.new-event {
  animation: territoryPulse 2s ease-in-out infinite;
  box-shadow: 0 0 0 3px rgba(184,134,11,0.3);
}
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div id="wolf-icon" style="font-size:28px;cursor:pointer;user-select:none" title="Click me! üê∫">üê∫</div>
      <div>
        <h1>Founding of Rome ‚Äî Complete <span id="edition-click" style="cursor:pointer;user-select:none" title="Keep clicking...">Edition</span></h1>
        <div class="subtitle">Build through <b>Trade</b>, <b>Military</b>, <b>Settlement</b>, and <b>Resources</b>. Expand your territory across the Italian peninsula.</div>
      </div>
    
  <div class="battle-speed-controls" title="Control battle animation speed">
  <label class="fast-toggle" for="fast-battles-toggle">
    <input type="checkbox" id="fast-battles-toggle" />
    <span class="fast-switch" aria-hidden="true"></span>
    <span class="fast-label">Fast Battles</span>
  </label>
</div>
</div>
    <div id="app"></div>
  </div>

  <script>
// === Runtime error overlay ===
(function(){
  if (window.__errorOverlayInstalled__) return;
  window.__errorOverlayInstalled__ = true;
  function showError(msg, src, line, col, err){
    try{
      const box = document.createElement('div');
      box.style.position = 'fixed';
      box.style.top = '10px';
      box.style.left = '10px';
      box.style.right = '10px';
      box.style.zIndex = '999999';
      box.style.background = 'rgba(220,38,38,0.95)';
      box.style.color = '#fff';
      box.style.padding = '12px 16px';
      box.style.borderRadius = '8px';
      box.style.font = '14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial';
      box.style.boxShadow = '0 8px 24px rgba(0,0,0,0.4)';
      box.textContent = '‚ö†Ô∏è ' + msg + (src ? ('  (' + src + ':' + line + ':' + col + ')') : '');
      document.body.appendChild(box);
      setTimeout(()=>{ try{ box.remove(); }catch(e){} }, 8000);
      if (err && err.stack) console.error(err.stack);
    }catch(e){}
  }
  window.addEventListener('error', function(e){
    showError(e.message, e.filename, e.lineno, e.colno, e.error);
  });
  window.addEventListener('unhandledrejection', function(e){
    const reason = (e && e.reason) ? (e.reason.message || String(e.reason)) : 'Unhandled Promise rejection';
    showError(reason);
  });
})();

/* ==================== EASTER EGG: WOLF CLICKS ==================== */
let wolfClickCount = 0;
let editionClickCount = 0;

document.addEventListener('DOMContentLoaded', () => {
  const wolfIcon = document.getElementById('wolf-icon');
  if (wolfIcon) {
    wolfIcon.addEventListener('click', () => {
      wolfClickCount++;
      if (wolfClickCount === 5 && window.S && S.stage === 'intro') {
        S.wolfClicks = 5;
        alert('üéâ SECRET UNLOCKED! Mr. Kitchen is now available!');
        render();
      }
    });
  }
  
  const editionWord = document.getElementById('edition-click');
  if (editionWord) {
    editionWord.addEventListener('click', () => {
      editionClickCount++;
      if (editionClickCount === 20) {
        alert('üêç SNAKE GAME UNLOCKED! Use arrow keys to play. Press ESC to exit.');
        startSnakeGame();
      } else if (editionClickCount === 10) {
        console.log('Keep clicking... (' + editionClickCount + '/20)');
      } else if (editionClickCount >= 15) {
        console.log('Almost there! (' + editionClickCount + '/20)');
      }
    });
  }
});

/* ==================== SNAKE GAME ==================== */
function startSnakeGame() {
  
  // --- Patch: ensure keydown handler is cleaned up on close ---
  let __snakeKeyHandler = null;
  let __snakeInterval = null;
  const __snakeCleanup = () => {
    try { if (__snakeInterval) clearInterval(__snakeInterval); } catch(e) {}
    try { if (__snakeKeyHandler) document.removeEventListener('keydown', __snakeKeyHandler); } catch(e) {}
  };
const overlay = el('div', {class:'snake-game'});
  const scoreDisplay = el('div', {class:'snake-score'}, 'Score: 0');
  const canvas = el('canvas', {class:'snake-canvas'});
  const controls = el('div', {class:'snake-controls'}, 'üéÆ Use Arrow Keys | ESC to Exit');
  
  overlay.append(scoreDisplay, canvas, controls);
  document.body.appendChild(overlay);
  
  const ctx = canvas.getContext('2d');
  if (!ctx) {
    alert('Graphics context unavailable on this device/browser.');
    __snakeCleanup();
    if (overlay && overlay.parentNode) document.body.removeChild(overlay);
    return;
  }
  // Responsive sizing for the Snake canvas: adjust to viewport between 240‚Äì400px.
  const tileCount = 20;
  const maxSize = 400;
  const minSize = 240;
  const viewport = Math.min(window.innerWidth, window.innerHeight) - 40;
  const canvasSize = Math.max(minSize, Math.min(maxSize, Math.floor(viewport)));
  canvas.width = canvas.height = canvasSize;
  const gridSize = Math.floor(canvasSize / tileCount);
  
  let snake = [{x: 10, y: 10}];
  let direction = {x: 1, y: 0};
  let food = {x: 15, y: 15};
  let score = 0;
  // let gameLoop = null; // replaced by __snakeInterval
  
  function drawGame() {
    // Background
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Grid
    ctx.strokeStyle = '#333';
    for (let i = 0; i <= tileCount; i++) {
      ctx.beginPath();
      ctx.moveTo(i * gridSize, 0);
      ctx.lineTo(i * gridSize, canvas.height);
      ctx.moveTo(0, i * gridSize);
      ctx.lineTo(canvas.width, i * gridSize);
      ctx.stroke();
    }
    
    // Snake
    snake.forEach((segment, index) => {
      ctx.fillStyle = index === 0 ? '#b8860b' : '#7a3b00';
      ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
    });
    
    // Food
    ctx.fillStyle = '#dc2626';
    ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);
  }
  
  function moveSnake() {
    const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
    
    // Wall collision
    if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
      endGame();
      return;
    }
    
    // Self collision
    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
      endGame();
      return;
    }
    
    snake.unshift(head);
    
    // Food collision
    if (head.x === food.x && head.y === food.y) {
      score++;
      scoreDisplay.textContent = 'Score: ' + score;
      food = {
        x: Math.floor(Math.random() * tileCount),
        y: Math.floor(Math.random() * tileCount)
      };
    } else {
      snake.pop();
    }
  }
  
  function gameUpdate() {
    moveSnake();
    drawGame();
  }
  
  function endGame() {
    clearInterval(__snakeInterval);
    __snakeCleanup(); alert(`üêç Game Over!\n\nFinal Score: ${score}\n\nClick OK to close.`);
    document.body.removeChild(overlay);
  }
  
  function handleKeyPress(e) {
    if (e.key === 'Escape') {
      __snakeCleanup();
      if (overlay && overlay.parentNode) document.body.removeChild(overlay);
      return;
    }
// Prevent opposite direction
    if (e.key === 'ArrowUp' && direction.y === 0) direction = {x: 0, y: -1};
    if (e.key === 'ArrowDown' && direction.y === 0) direction = {x: 0, y: 1};
    if (e.key === 'ArrowLeft' && direction.x === 0) direction = {x: -1, y: 0};
    if (e.key === 'ArrowRight' && direction.x === 0) direction = {x: 1, y: 0};
  }
  
  __snakeKeyHandler = handleKeyPress;
document.addEventListener('keydown', __snakeKeyHandler);
  
  drawGame();
  __snakeInterval = setInterval(gameUpdate, 150);
}

/* ==================== GAME DATA ==================== */

// Latin name generator
function generateLatinName(type = 'building') {
  const prefixes = ['Magna', 'Novus', 'Antiqua', 'Prima', 'Maxima', 'Alta', 'Fortis', 'Clara', 'Sancta', 'Regia'];
  const middles = ['Via', 'Domus', 'Templum', 'Forum', 'Porticus', 'Basilica', 'Thermae', 'Atrium', 'Villa', 'Insula'];
  const suffixes = ['Romana', 'Imperialis', 'Victrix', 'Augusta', 'Nobilis', 'Vetusta', 'Pulchra', 'Firma', 'Aeterna', 'Gloria'];
  
  if (type === 'territory') {
    const territoryPrefixes = ['Ager', 'Campus', 'Collis', 'Mons', 'Silva', 'Vallis', 'Regio', 'Locus'];
    const territorySuffixes = ['Fertilis', 'Sacer', 'Magnus', 'Antiquus', 'Novus', 'Remotus', 'Ultimus', 'Proximus'];
    return rpick(territoryPrefixes) + ' ' + rpick(territorySuffixes);
  }
  
  if (Math.random() > 0.5) {
    return rpick(prefixes) + ' ' + rpick(middles);
  } else {
    return rpick(middles) + ' ' + rpick(suffixes);
  }
}

// Rarity system
function rollRarity() {
  const roll = Math.random() * 100;

  if (roll < 0.05) return {name: 'Imperial',  bonus: 3.0, class: 'rarity-imperial'};   // 0.05%
  if (roll < 0.55) return {name: 'Legendary', bonus: 2.0, class: 'rarity-legendary'};  // 0.50%
  if (roll < 3.05) return {name: 'Epic',      bonus: 1.5, class: 'rarity-epic'};       // 2.50%
  if (roll < 8.05) return {name: 'Rare',      bonus: 1.25, class: 'rarity-rare'};      // 5.00%
  if (roll < 20.05) return {name: 'Uncommon', bonus: 1.1, class: 'rarity-uncommon'};   // 12.00%
  return {name: 'Common', bonus: 1.0, class: 'rarity-common'};                         // ~80.00%
}

function getRarityBadge(rarity) {
  if (!rarity) return '';
  return `<span class="rarity ${rarity.class}">${rarity.name}</span>`;
}

// Territories with RARITY and LATIN NAMES!
const TERRITORIES = [
  {id:'palatine', latinName:'Collis Palatinus', name:'Palatine Hill', status:'owned', str:0, value:0, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Palatino_general_view.jpg/320px-Palatino_general_view.jpg',
   produces:{grain:2, livestock:1}, desc:'Your starting settlement', rarity:rollRarity()},
  {id:'aventine', latinName:'Collis Aventinus', name:'Aventine Hill', status:'contested', str:25, value:180, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Santa_Sabina_%28Rome%29_-_Apse.jpg/320px-Santa_Sabina_%28Rome%29_-_Apse.jpg',
   produces:{timber:2, clay:1}, desc:'Forested hill, good for building materials', req:0, rarity:rollRarity()},
  {id:'quirinal', latinName:'Collis Quirinalis', name:'Quirinal Hill', status:'contested', str:30, value:220, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Palazzo_del_Quirinale.jpg/320px-Palazzo_del_Quirinale.jpg',
   produces:{grain:2, wool:1}, desc:'Pastoral highlands', req:0, rarity:rollRarity()},
  {id:'tiber', latinName:'Ripa Tiberis', name:'Tiber Riverside', status:'contested', str:35, value:250, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Tevere_-_Roma.jpg/320px-Tevere_-_Roma.jpg',
   produces:{salt:2, grain:1}, desc:'River trade and fishing', req:0, rarity:rollRarity()},
  
  {id:'esquiline', latinName:'Collis Esquilinus', name:'Esquiline Hill', status:'hostile', str:45, value:300, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Santa_Maria_Maggiore_%28Rome%29_-_Front.jpg/320px-Santa_Maria_Maggiore_%28Rome%29_-_Front.jpg',
   produces:{grain:3, livestock:1}, desc:'Fertile farmland', req:1, rarity:rollRarity()},
  {id:'caelian', latinName:'Collis Caelius', name:'Caelian Hill', status:'hostile', str:40, value:280, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Santi_Giovanni_e_Paolo_%28Rome%29_-_Facade.jpg/320px-Santi_Giovanni_e_Paolo_%28Rome%29_-_Facade.jpg',
   produces:{timber:2, grain:2}, desc:'Mixed resources', req:1, rarity:rollRarity()},
  {id:'viminal', latinName:'Collis Viminalis', name:'Viminal Hill', status:'hostile', str:38, value:260, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Teatro_dell%27Opera.jpg/320px-Teatro_dell%27Opera.jpg',
   produces:{clay:2, wool:1}, desc:'Artisan quarter potential', req:1, rarity:rollRarity()},
  {id:'capitoline', latinName:'Capitolium', name:'Capitoline Hill', status:'hostile', str:55, value:400, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Piazza_del_Campidoglio.jpg/320px-Piazza_del_Campidoglio.jpg',
   produces:{grain:2, iron:1, wine:1}, desc:'Strategic citadel position', req:2, rarity:rollRarity()},
  
  {id:'ostia', latinName:'Ostia Portus', name:'Ostia Port', status:'hostile', str:65, value:500, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Ostia_Antica_-_Teatro.jpg/320px-Ostia_Antica_-_Teatro.jpg',
   produces:{salt:4, grain:2}, desc:'Coastal trade hub', req:3, rarity:rollRarity()},
  {id:'albalonga', latinName:'Alba Longa', name:'Alba Longa', status:'hostile', str:80, value:650, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/8/81/Castel_Gandolfo_-_view.jpg/320px-Castel_Gandolfo_-_view.jpg',
   produces:{wine:3, grain:2, livestock:1}, desc:'Ancient Latin city', req:4, rarity:rollRarity()},
  {id:'veii', latinName:'Veii Etrusca', name:'Veii', status:'hostile', str:100, value:850, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Veio_Santuario.jpg/320px-Veio_Santuario.jpg',
   produces:{iron:3, timber:2, grain:1}, desc:'Etruscan stronghold', req:5, rarity:rollRarity()},
  {id:'latium', latinName:'Ager Latinus', name:'Latium Plains', status:'hostile', str:90, value:750, 
   img:'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b8/Campagna_Romana.jpg/320px-Campagna_Romana.jpg',
   produces:{grain:5, livestock:2}, desc:'Breadbasket of Italy', req:5, rarity:rollRarity()},
];

// ==================== TERRITORY ENHANCEMENTS ====================

// Territory Development Levels
const TERRITORY_LEVELS = {
  1: {name:'Settlement', bonuses:{production:1.0, stability:0}},
  2: {name:'Town', bonuses:{production:1.2, stability:5}, cost:400},
  3: {name:'City', bonuses:{production:1.5, stability:10}, cost:800},
  4: {name:'Metropolis', bonuses:{production:2.0, stability:15}, cost:1500},
  5: {name:'Capital Province', bonuses:{production:3.0, stability:25}, cost:3000}
};

// Territory-Specific Buildings
const TERRITORY_BUILDINGS = [
  {id:'garrison', name:'Garrison', latinName:'Praesidium', icon:'üè∞', cost:300,
   effect:{defense:15, stability:10, troopCapacity:50}, desc:'Military garrison for defense'},
  {id:'granary', name:'Granary', latinName:'Horreum', icon:'üåæ', cost:250,
   effect:{foodStorage:100, foodBonus:1.3}, desc:'Increases food production and storage'},
  {id:'market', name:'Marketplace', latinName:'Forum Mercatorum', icon:'üè™', cost:350,
   effect:{tradeBonus:1.2, denarii:50}, desc:'Boosts trade and generates income'},
  {id:'workshop', name:'Workshop', latinName:'Officina', icon:'‚öíÔ∏è', cost:400,
   effect:{productionBonus:1.4, quality:10}, desc:'Improves resource quality'},
  {id:'walls', name:'City Walls', latinName:'Murus Civitatis', icon:'üß±', cost:600,
   effect:{defense:30, stability:15}, desc:'Strong defensive fortifications'},
  {id:'aqueduct', name:'Aqueduct', latinName:'Aquaeductus', icon:'üåä', cost:500,
   effect:{happiness:20, sanitation:15, population:50}, desc:'Fresh water supply'},
  {id:'arena', name:'Arena', latinName:'Amphitheatrum', icon:'üèüÔ∏è', cost:700,
   effect:{happiness:25, morale:15, influence:10}, desc:'Entertainment venue'},
  {id:'library', name:'Library', latinName:'Bibliotheca', icon:'üìö', cost:550,
   effect:{research:1.3, influence:15}, desc:'Center of learning'},
  {id:'temple', name:'Temple', latinName:'Templum', icon:'‚õ™', cost:450,
   effect:{piety:10, happiness:15, stability:10}, desc:'Religious center'},
  {id:'port', name:'Port', latinName:'Portus', icon:'‚öì', cost:800,
   effect:{tradeBonus:1.5, saltBonus:2, capacity:30}, desc:'Coastal trade hub'},
  {id:'mine_upgrade', name:'Advanced Mine', latinName:'Fodina Ampla', icon:'‚õèÔ∏è', cost:650,
   effect:{ironBonus:2, stoneBonus:1.5}, desc:'Enhanced mining operations'},
  {id:'farm_complex', name:'Farm Complex', latinName:'Fundus Magnus', icon:'üöú', cost:450,
   effect:{grainBonus:2, livestockBonus:1.5}, desc:'Large-scale agriculture'},
  // === ECONOMIC SPECIALIST BUILDINGS ===
  {id:'bank', name:'Banking House', latinName:'Argentaria', icon:'üè¶', cost:800,
   effect:{denarii:200, denariMultiplier:1.08, stability:5}, 
   desc:'Generate wealth through loans and finance. +8% denarii income from all sources'},
  {id:'merchant_guild', name:'Merchant Guild', latinName:'Collegium Mercatorum', icon:'‚öñÔ∏è', cost:600,
   effect:{tariffReduction:0.15, priceBonus:1.05, reputation:10}, 
   desc:'Powerful traders reduce tariffs and improve prices. -15% trade tariffs, +5% selling prices'},
  {id:'grand_market', name:'Grand Market', latinName:'Forum Magnum', icon:'üèõÔ∏è', cost:900,
   effect:{denarii:300, productionBonus:1.15, stability:10, marketBonus:true}, 
   desc:'Massive commercial center. +300 denarii/season, +15% all production, attracts merchants'},
  {id:'counting_house', name:'Counting House', latinName:'Tabularium', icon:'üìä', cost:500,
   effect:{denarii:100, taxBonus:1.05, stability:5}, 
   desc:'Efficient tax collection and record keeping. +5% tax efficiency, +100 denarii/season'}
  ,
  // New building: Census Office. Improves tax accuracy and collection through regular censuses.
  {id:'census_office', name:'Census Office', latinName:'Censum Officium', icon:'üìú', cost:550,
   effect:{taxBonus:1.10, stability:-5, denarii:0}, 
   desc:'Conducts regular censuses to improve tax collection. +10% tax efficiency but slightly reduces stability'}
];

// Territory Development Paths
const DEVELOPMENT_PATHS = {
  economic: {
    name:'Economic Focus', icon:'üí∞',
    bonuses:{tradeBonus:1.3, denariPerSeason:100, tariffReduction:0.15},
    buildings:['market', 'workshop', 'port']
  },
  military: {
    name:'Military Focus', icon:'‚öîÔ∏è',
    bonuses:{defense:25, recruitBonus:1.2, moraleBonus:10},
    buildings:['garrison', 'walls', 'arena']
  },
  cultural: {
    name:'Cultural Focus', icon:'üé≠',
    bonuses:{happiness:20, influence:15, pietyBonus:1.3},
    buildings:['temple', 'library', 'arena']
  },
  agricultural: {
    name:'Agricultural Focus', icon:'üåæ',
    bonuses:{foodProduction:2.0, population:50, grainBonus:2},
    buildings:['granary', 'farm_complex', 'aqueduct']
  }
};

// Territory Governor Traits
const GOVERNOR_TRAITS = [
  {id:'administrator', name:'Skilled Administrator', icon:'üìä',
   bonus:{stability:15, denarii:75}, malus:{}, cost:200},
  {id:'general', name:'Military General', icon:'‚öîÔ∏è',
   bonus:{defense:20, morale:10}, malus:{happiness:-5}, cost:250},
  {id:'merchant', name:'Master Merchant', icon:'üí∞',
   bonus:{tradeBonus:1.3, denarii:150}, malus:{}, cost:300},
  {id:'scholar', name:'Learned Scholar', icon:'üìö',
   bonus:{influence:20, research:1.2}, malus:{}, cost:200},
  {id:'priest', name:'High Priest', icon:'üôè',
   bonus:{piety:15, happiness:15, stability:10}, malus:{}, cost:200},
  {id:'engineer', name:'Chief Engineer', icon:'üèóÔ∏è',
   bonus:{buildCost:0.8, productionBonus:1.3}, malus:{}, cost:250},
  {id:'diplomat', name:'Skilled Diplomat', icon:'ü§ù',
   bonus:{reputation:10, tariffReduction:0.2}, malus:{}, cost:200},
  {id:'tyrant', name:'Iron Fist', icon:'üëä',
   bonus:{stability:25, defense:15}, malus:{happiness:-20}, cost:150}
];

// Territory Events
const TERRITORY_EVENTS = [
  {id:'rebellion', name:'Rebellion', icon:'‚ö†Ô∏è', chance:0.05,
   condition:t=>(t.stability||50)<30,
   effect:t=>{t.garrison=Math.floor((t.garrison||0)*0.7); t.stability=(t.stability||50)-10;},
   desc:'Unrest erupts! Garrison reduced, stability drops.'},
  {id:'plague', name:'Plague', icon:'üíÄ', chance:0.03,
   condition:t=>(t.sanitation||0)<30,
   effect:t=>{t.population=Math.floor((t.population||0)*0.8); t.happiness=(t.happiness||50)-15;},
   desc:'Disease spreads! Population and happiness fall.'},
  {id:'prosperity', name:'Prosperity', icon:'‚ú®', chance:0.08,
   condition:t=>(t.stability||50)>70,
   effect:t=>{t.denariBonus=(t.denariBonus||0)+100; t.happiness=(t.happiness||50)+10;},
   desc:'Golden age! Income and happiness rise.'},
  {id:'resource_discovery', name:'Resource Discovery', icon:'üíé', chance:0.06,
   condition:t=>true,
   effect:t=>{const resources=['grain','iron','salt','wine','oliveoil','spices']; t.bonusResource=resources[Math.floor(Math.random()*resources.length)];},
   desc:'New resources found! Production bonus.'},
  // Slave revolt: Enslaved people rise up, disrupting estates and undermining stability.
  {id:'slave_revolt', name:'Slave Revolt', icon:'‚õìÔ∏è', chance:0.04,
   condition:t=>true,
   effect:t=>{ t.population = Math.floor((t.population || 0) * 0.9); t.happiness = (t.happiness || 50) - 12; t.stability = (t.stability || 50) - 15; },
   desc:'Enslaved workers rise up! Population falls, happiness plummets, and stability drops.'},
  {id:'bandit_raid', name:'Bandit Raid', icon:'üó°Ô∏è', chance:0.07,
   condition:t=>(t.garrison||0)<20,
   effect:t=>{t.denariLoss=(t.denariLoss||0)+150; t.stability=(t.stability||50)-8;},
   desc:'Bandits attack! Gold stolen, stability drops.'},
  {id:'cultural_boom', name:'Cultural Boom', icon:'üé≠', chance:0.06,
   condition:t=>(t.happiness||50)>60,
   effect:t=>{t.influence=(t.influence||0)+15; t.piety=(t.piety||0)+10;},
   desc:'Arts flourish! Influence and piety grow.'},
  {id:'harvest_festival', name:'Harvest Festival', icon:'üéâ', chance:0.07,
   condition:t=>(t.level||1)>=2,
   effect:t=>{t.foodBonus=(t.foodBonus||0)+50; t.happiness=(t.happiness||50)+12;},
   desc:'Bountiful harvest! Food and happiness increase.'}
];

// Supply Line System
const SUPPLY_LINES = {
  cost:100, // Cost to establish
  maintenancePerSeason:20,
  bonuses:{
    tradeBonus:1.1,
    riskReduction:0.15,
    movementSpeed:1.5
  }
};

// Initialize territory data in game state
function initTerritoryEnhancements() {
  if (!S.territoryData) S.territoryData = {};
  
  S.territories.forEach(tId => {
    if (!S.territoryData[tId]) {
      S.territoryData[tId] = {
        level: 1,
        stability: 50,
        happiness: 50,
        garrison: 0,
        buildings: [],
        developmentPath: null,
        governor: null,
        population: 100,
        infrastructure: 0,
        supplyLines: [],
        lastEventRound: 0,
        modifiers: {}
      };
    }
  });
}

// Get territory display info
function getTerritoryInfo(territoryId) {
  const baseTerritory = TERRITORIES.find(t => t.id === territoryId);
  const data = S.territoryData[territoryId] || {};
  const level = TERRITORY_LEVELS[data.level || 1];
  
  return {
    ...baseTerritory,
    ...data,
    levelName: level.name,
    levelBonuses: level.bonuses,
    totalProduction: calculateTerritoryProduction(territoryId),
    defensePower: calculateTerritoryDefense(territoryId),
    netIncome: calculateTerritoryIncome(territoryId)
  };
}

// Calculate territory production with all bonuses
function calculateTerritoryProduction(territoryId) {
  const territory = TERRITORIES.find(t => t.id === territoryId);
  if (!territory || !territory.produces) return {};
  
  const data = S.territoryData[territoryId] || {};
  const level = TERRITORY_LEVELS[data.level || 1];
  const baseMult = level.bonuses.production;
  
  let production = {};
  for (let [resource, amount] of Object.entries(territory.produces)) {
    let total = amount * baseMult;
    
    // Building bonuses
    data.buildings?.forEach(bId => {
      const building = TERRITORY_BUILDINGS.find(b => b.id === bId);
      if (building?.effect?.foodBonus && (resource === 'grain' || resource === 'livestock')) {
        total *= building.effect.foodBonus;
      }
      if (building?.effect?.ironBonus && resource === 'iron') {
        total *= building.effect.ironBonus;
      }
      if (building?.effect?.grainBonus && resource === 'grain') {
        total *= building.effect.grainBonus;
      }
      if (building?.effect?.productionBonus) {
        total *= building.effect.productionBonus;
      }
    });
    
    // Development path bonuses
    if (data.developmentPath) {
      const path = DEVELOPMENT_PATHS[data.developmentPath];
      if (path?.bonuses?.foodProduction && (resource === 'grain' || resource === 'livestock')) {
        total *= path.bonuses.foodProduction;
      }
    }
    
    // Governor bonuses
    if (data.governor) {
      const gov = GOVERNOR_TRAITS.find(g => g.id === data.governor);
      if (gov?.bonus?.productionBonus) {
        total *= gov.bonus.productionBonus;
      }
    }
    
    production[resource] = Math.floor(total);
  }
  
  return production;
}

// Calculate territory defense rating
function calculateTerritoryDefense(territoryId) {
  const data = S.territoryData[territoryId] || {};
  let defense = data.garrison || 0;
  
  // Building defense bonuses
  data.buildings?.forEach(bId => {
    const building = TERRITORY_BUILDINGS.find(b => b.id === bId);
    if (building?.effect?.defense) {
      defense += building.effect.defense;
    }
  });
  
  // Development path bonuses
  if (data.developmentPath === 'military') {
    defense += DEVELOPMENT_PATHS.military.bonuses.defense;
  }
  
  // Governor bonuses
  if (data.governor) {
    const gov = GOVERNOR_TRAITS.find(g => g.id === data.governor);
    if (gov?.bonus?.defense) {
      defense += gov.bonus.defense;
    }
  }
  
  return defense;
}

// Calculate territory income
function calculateTerritoryIncome(territoryId) {
  const data = S.territoryData[territoryId] || {};
  let income = 0;
  
  // Building income
  data.buildings?.forEach(bId => {
    const building = TERRITORY_BUILDINGS.find(b => b.id === bId);
    if (building?.effect?.denarii) {
      income += building.effect.denarii;
    }
  });
  
  // Development path bonuses
  if (data.developmentPath) {
    const path = DEVELOPMENT_PATHS[data.developmentPath];
    if (path?.bonuses?.denariPerSeason) {
      income += path.bonuses.denariPerSeason;
    }
  }
  
  // Governor bonuses
  if (data.governor) {
    const gov = GOVERNOR_TRAITS.find(g => g.id === data.governor);
    if (gov?.bonus?.denarii) {
      income += gov.bonus.denarii;
    }
  }
  
  return income;
}

// Upgrade territory level
function upgradeTerritoryLevel(territoryId) {
  const data = S.territoryData[territoryId];
  const currentLevel = data.level || 1;
  const nextLevel = TERRITORY_LEVELS[currentLevel + 1];
  
  if (!nextLevel) {
    alert('‚ö†Ô∏è Territory is already at maximum level!');
    return false;
  }
  
  if (S.denarii < nextLevel.cost) {
    alert(`‚ö†Ô∏è Need ${nextLevel.cost} denarii to upgrade!`);
    return false;
  }
  
  S.denarii -= nextLevel.cost;
  data.level = currentLevel + 1;
  data.stability += 10;
  
  alert(`‚ú® Territory upgraded to ${nextLevel.name}!\n\nProduction: x${nextLevel.bonuses.production}\nStability: +${nextLevel.bonuses.stability}`);
  return true;
}

// Build territory building
function buildTerritoryBuilding(territoryId, buildingId) {
  const data = S.territoryData[territoryId];
  const building = TERRITORY_BUILDINGS.find(b => b.id === buildingId);
  
  if (!building) return false;
  
  if (data.buildings?.includes(buildingId)) {
    alert('‚ö†Ô∏è Building already constructed in this territory!');
    return false;
  }
  
  if (S.denarii < building.cost) {
    alert(`‚ö†Ô∏è Need ${building.cost} denarii!`);
    return false;
  }
  
  S.denarii -= building.cost;
  if (!data.buildings) data.buildings = [];
  data.buildings.push(buildingId);
  
  // Apply immediate effects
  if (building.effect.stability) {
    data.stability = Math.min(100, (data.stability || 50) + building.effect.stability);
  }
  if (building.effect.troopCapacity) {
    data.maxGarrison = (data.maxGarrison || 50) + building.effect.troopCapacity;
  }
  
  alert(`üèóÔ∏è Built ${building.name}!\n\n${building.desc}`);
  return true;
}

// Assign garrison to territory
function assignGarrison(territoryId, troops) {
  const data = S.territoryData[territoryId];
  const maxGarrison = data.maxGarrison || 50;
  
  if (S.troops < troops) {
    alert('‚ö†Ô∏è Not enough troops available!');
    return false;
  }
  
  if ((data.garrison || 0) + troops > maxGarrison) {
    alert(`‚ö†Ô∏è Garrison limit is ${maxGarrison} troops!`);
    return false;
  }
  
  S.troops -= troops;
  data.garrison = (data.garrison || 0) + troops;
  data.stability = Math.min(100, (data.stability || 50) + Math.floor(troops / 10));
  
  return true;
}

// Recall garrison from territory
function recallGarrison(territoryId, troops) {
  const data = S.territoryData[territoryId];
  const available = data.garrison || 0;
  
  if (available < troops) {
    alert('‚ö†Ô∏è Not enough troops garrisoned!');
    return false;
  }
  
  data.garrison -= troops;
  S.troops += troops;
  data.stability = Math.max(0, (data.stability || 50) - Math.floor(troops / 10));
  
  return true;
}

// Set territory development path
function setDevelopmentPath(territoryId, pathId) {
  const data = S.territoryData[territoryId];
  const path = DEVELOPMENT_PATHS[pathId];
  
  if (!path) return false;
  
  if (data.developmentPath) {
    if (!confirm(`Change development path from ${DEVELOPMENT_PATHS[data.developmentPath].name} to ${path.name}?\n\nThis will cost 300 denarii.`)) {
      return false;
    }
    if (S.denarii < 300) {
      alert('‚ö†Ô∏è Need 300 denarii to change path!');
      return false;
    }
    S.denarii -= 300;
  }
  
  data.developmentPath = pathId;
  alert(`üìã Territory development path set to: ${path.name}\n\n${path.icon} Bonuses applied!`);
  return true;
}

// Appoint governor
function appointGovernor(territoryId, governorId) {
  const data = S.territoryData[territoryId];
  const governor = GOVERNOR_TRAITS.find(g => g.id === governorId);
  
  if (!governor) return false;
  
  if (S.denarii < governor.cost) {
    alert(`‚ö†Ô∏è Need ${governor.cost} denarii to appoint governor!`);
    return false;
  }
  
  S.denarii -= governor.cost;
  data.governor = governorId;
  data.stability = Math.min(100, (data.stability || 50) + (governor.bonus.stability || 0));
  
  alert(`üëî Appointed ${governor.name} as governor!\n\n${governor.icon} Bonuses active.`);
  return true;
}

// Process territory events each season
function processTerritoryEvents() {
  S.territories.forEach(tId => {
    const data = S.territoryData[tId];
    if (!data) return;
    
    // Only check events every few rounds
    if (S.round - (data.lastEventRound || 0) < 3) return;
    
    TERRITORY_EVENTS.forEach(event => {
      if (Math.random() < event.chance && event.condition(data)) {
        event.effect(data);
        data.lastEventRound = S.round;
        
        // Show notification
        const territory = TERRITORIES.find(t => t.id === tId);
        showTerritoryEvent(territory.name, event);
      }
    });
    
    // Update stability based on garrison
    const expectedGarrison = 20;
    if ((data.garrison || 0) < expectedGarrison) {
      data.stability = Math.max(0, (data.stability || 50) - 2);
    } else {
      data.stability = Math.min(100, (data.stability || 50) + 1);
    }
  });
}

// Show territory event notification
function showTerritoryEvent(territoryName, event) {
  const notification = el('div', {class:'territory-event-notification'});
  notification.style.cssText = `
    position:fixed; top:20px; right:20px; z-index:10000;
    background:var(--paper); border:2px solid var(--roman-gold);
    padding:16px; border-radius:12px; max-width:300px;
    box-shadow:0 8px 24px rgba(0,0,0,0.2);
    animation:slideInRight 0.3s ease-out;
  `;
  
  notification.append(
    el('div', {style:'font-size:32px;text-align:center;margin-bottom:8px'}, event.icon),
    el('div', {style:'font-weight:900;font-size:16px;margin-bottom:6px;text-align:center;color:var(--roman-red)'}, 
      `${territoryName}: ${event.name}`),
    el('div', {style:'font-size:13px;color:#555;text-align:center'}, event.desc)
  );
  
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), 5000);
}

// Apply territory production to inventory
function applyTerritoryProduction() {
  let totalIncome = 0;
  
  S.territories.forEach(tId => {
    const production = calculateTerritoryProduction(tId);
    const income = calculateTerritoryIncome(tId);
    
    // Add resources
    for (let [resource, amount] of Object.entries(production)) {
      S.inventory[resource] = (S.inventory[resource] || 0) + amount;
    }
    
    // Add income
    totalIncome += income;
  });
  
  if (totalIncome > 0) {
    S.denarii += totalIncome;
    S.totalIncomeEarned += totalIncome;
  }
}

// Resource production buildings with RARITY and LATIN NAMES!
/*
 * Production buildings now include an explicit upkeep cost.  In the base game all
 * production structures charged the same flat maintenance, which failed to
 * reflect the varying complexity of operating a farm, a mine or a fishery.
 * Assigning a bespoke upkeep to each building makes economic planning more
 * meaningful.  Values have been chosen to roughly scale with the building‚Äôs
 * cost and expected output.
 */
const PRODUCTION_BUILDINGS = [
  {
    id: 'farm',
    latinName: 'Fundus Agricola',
    name: 'Farm',
    emoji: 'üåæ',
    cost: 150,
    produces: 'grain',
    rate: 5,
    upkeep: 5,
    desc: 'Produces grain each season',
    rarity: rollRarity()
  },
  {
    id: 'pasture',
    latinName: 'Ager Pastoralis',
    name: 'Pasture',
    emoji: 'üêë',
    cost: 180,
    produces: 'livestock',
    rate: 4,
    upkeep: 6,
    desc: 'Raises livestock for food and trade',
    rarity: rollRarity()
  },
  {
    id: 'fishery',
    latinName: 'Piscina Marina',
    name: 'Fishery',
    emoji: 'üé£',
    cost: 140,
    produces: 'salt',
    rate: 3,
    upkeep: 5,
    desc: 'Catches fish and produces salt',
    rarity: rollRarity()
  },
  {
    id: 'timbercamp',
    latinName: 'Silva Lignum',
    name: 'Timber Camp',
    emoji: 'ü™µ',
    cost: 160,
    produces: 'timber',
    rate: 3,
    upkeep: 4,
    desc: 'Harvests timber from forests',
    rarity: rollRarity()
  },
  {
    id: 'claypit',
    latinName: 'Fossa Argilla',
    name: 'Clay Pit',
    emoji: 'üß±',
    cost: 130,
    produces: 'clay',
    rate: 3,
    upkeep: 4,
    desc: 'Extracts clay for building',
    rarity: rollRarity()
  },
  {
    id: 'mine',
    latinName: 'Fodina Ferrum',
    name: 'Mine',
    emoji: '‚öíÔ∏è',
    cost: 250,
    produces: 'iron',
    rate: 2,
    upkeep: 8,
    desc: 'Mines iron ore for weapons',
    rarity: rollRarity()
  },
  {
    id: 'vineyard',
    latinName: 'Vinea Vitis',
    name: 'Vineyard',
    emoji: 'üç∑',
    cost: 220,
    produces: 'wine',
    rate: 2,
    upkeep: 6,
    desc: 'Produces wine for trade and morale',
    rarity: rollRarity()
  }
  ,
  // New building: Latifundia
  {
    id: 'latifundia',
    latinName: 'Latifundium',
    name: 'Latifundia',
    emoji: 'ü´í',
    cost: 300,
    produces: 'oliveoil',
    rate: 3,
    upkeep: 7,
    desc: 'Large estate producing olive oil for export',
    rarity: rollRarity()
  }
  ,
  // New production building: Caravanserai. Oversees caravans bringing exotic spices along long-distance trade routes„Äê128302359618401‚Ä†L199-L203„Äë.
  {
    id: 'caravanserai',
    latinName: 'Caravanserai',
    name: 'Caravanserai',
    emoji: 'üê™',
    cost: 400,
    produces: 'spices',
    rate: 2,
    upkeep: 6,
    desc: 'Organizes caravans to trade exotic spices across deserts',
    rarity: rollRarity()
  }
];

// Trading goods with expanded properties
const GOODS = [
  {id:'livestock', name:'Livestock', base:90,  vol:0.9, emoji:'üêë', foodValue:3, militaryValue:1},
  {id:'timber',    name:'Timber',    base:110, vol:1.1, emoji:'ü™µ', foodValue:0, buildingValue:3},
  {id:'clay',      name:'Clay',      base:70,  vol:0.9, emoji:'üß±', foodValue:0, buildingValue:2},
  {id:'salt',      name:'Salt',      base:140, vol:1.1, emoji:'üßÇ', foodValue:2, preserveValue:2},
  {id:'wool',      name:'Wool',      base:120, vol:1.0, emoji:'üß∂', foodValue:0, comfortValue:2},
  {id:'grain',     name:'Grain',     base:80,  vol:0.8, emoji:'üåæ', foodValue:5, militaryValue:2},
  {id:'iron',      name:'Iron',      base:200, vol:1.3, emoji:'‚öîÔ∏è', militaryValue:5, buildingValue:1},
  {id:'wine',      name:'Wine',      base:160, vol:1.2, emoji:'üç∑', happinessValue:3, tradeValue:2},
  {id:'oliveoil',  name:'Olive Oil', base:180, vol:1.1, emoji:'ü´í', foodValue:2, tradeValue:3, happinessValue:1},
  // New luxury good: Spices. Imported from the East via long caravan routes, spices were highly prized and commanded high prices„Äê128302359618401‚Ä†L131-L146„Äë„Äê128302359618401‚Ä†L199-L203„Äë.
  {id:'spices',    name:'Spices',    base:300, vol:0.9, emoji:'üå∂Ô∏è', foodValue:1, tradeValue:5, happinessValue:4},
];

// Cities with expanded attributes
const CITIES = [
  {id:'alba',  name:'Alba Longa',  tariff:0.04, risk:0.06, distance:2, 
   bias:{livestock:+6,timber:+4,clay:+8,salt:+1,wool:+6,grain:+5,iron:+0,wine:+8,oliveoil:+6},
   specialty:'wine', relation:0},
  {id:'tiber', name:'Tiber Ford',  tariff:0.05, risk:0.05, distance:1,
   bias:{livestock:+5,timber:+6,clay:+2,salt:+8,wool:+5,grain:+4,iron:+2,wine:+4,oliveoil:+4},
   specialty:'salt', relation:0},
  {id:'sabine',name:'Sabine Hills',tariff:0.04, risk:0.07, distance:3,
   bias:{livestock:+8,timber:+6,clay:+0,salt:+0,wool:+10,grain:+3,iron:+4,wine:+2,oliveoil:+2},
   specialty:'wool', relation:0},
  {id:'veii',  name:'Veii',        tariff:0.06, risk:0.08, distance:4,
   bias:{livestock:+2,timber:+10,clay:+6,salt:+4,wool:+0,grain:+2,iron:+8,wine:+0,oliveoil:+3},
   specialty:'iron', relation:-5},
  {id:'ostia', name:'Ostia Marsh', tariff:0.05, risk:0.07, distance:2,
   bias:{livestock:+0,timber:+4,clay:+4,salt:+12,wool:+0,grain:+6,iron:+0,wine:+4,oliveoil:+8},
   specialty:'salt', relation:0},
  {id:'latium',name:'Latin Village',tariff:0.03, risk:0.06, distance:2,
   bias:{livestock:+6,timber:+4,clay:+6,salt:+2,wool:+8,grain:+7,iron:+1,wine:+6,oliveoil:+4},
   specialty:'grain', relation:5},
];

// Founders with enhanced modifiers - MR. KITCHEN IS NOW TRULY OVERPOWERED!
const FOUNDERS = {
  romulus: { 
    id:'romulus', name:'Romulus', icon:'üó°Ô∏è',
    desc:'The warrior. Military conquest and aggressive expansion.',
    mods:{ 
      sellMul:0.98, tariffMul:0.97, riskMul:0.88, troopsMul:1.15, attackBonus:+5,
      recruitCost:0.9, moraleDecay:0.95, territoryBonus:1.2
    } 
  },
  remus: { 
    id:'remus', name:'Remus', icon:'üõ°Ô∏è',
    desc:'The diplomat. Trade prosperity and peaceful growth.',
    mods:{ 
      sellMul:1.06, tariffMul:1.00, riskMul:1.12, relationBonus:+8, favorGain:1.25,
      buildCost:0.85, happinessMul:1.15, productionBonus:1.15
    } 
  },
  kitchen: {
    id:'kitchen', name:'Mr. Kitchen', icon:'üë®üç≥',
    desc:'The ultimate founder. Unleash unlimited power! SUPER OVERPOWERED MODE!',
    mods:{
      sellMul:999, tariffMul:0.0001, riskMul:0.0001, troopsMul:999, attackBonus:+99999,
      recruitCost:0.0001, moraleDecay:0, territoryBonus:999, buildCost:0.0001,
      happinessMul:999, productionBonus:999, favorGain:999, relationBonus:+99999
    }
  }
};

// Technologies
const TECHNOLOGIES = [
  {id:'market',name:'Forum Market',cost:280,req:{favor:10},effect:'tradePrices',
   desc:'+5% trade prices, +10 capacity',unlocked:false},
  {id:'roads',name:'Stone Roads',cost:350,req:{forts:2},effect:'tradeRisk',
   desc:'-15% trade risk, +20 capacity',unlocked:false},
  {id:'granaries',name:'Advanced Granaries',cost:400,req:{food:250},effect:'food',
   desc:'Food decay 50% slower, +100 max food storage',unlocked:false},
  {id:'legion',name:'Legion Training',cost:520,req:{troops:100},effect:'military',
   desc:'+20% attack power, -10% recruit cost',unlocked:false},
  {id:'aqueduct',name:'Aqueduct',cost:580,req:{sanitation:55,pop:200},effect:'population',
   desc:'+2 population growth per turn, +20 max sanitation',unlocked:false},
  {id:'forge',name:'Military Forge',cost:480,req:{troops:100,supplies:40},effect:'equipment',
   desc:'Supplies last 50% longer, forge costs -20%',unlocked:false},
  {id:'walls',name:'Stone Walls',cost:720,req:{forts:4},effect:'defense',
   desc:'Forts provide +50% defense, reduce all risks -10%',unlocked:false},
  {id:'senate',name:'Senate House',cost:850,req:{favor:18,pop:280,reputation:20},effect:'governance',
   desc:'+2 favor per turn, +1% sell prices permanently',unlocked:false},
  {id:'irrigation',name:'Irrigation',cost:380,req:{territories:3},effect:'farming',
   desc:'+50% production from farms and pastures',unlocked:false},
  {id:'mining',name:'Advanced Mining',cost:520,req:{territories:4},effect:'mining',
   desc:'+100% production from mines, unlock iron weapons',unlocked:false},
  // New technology: Currency Debasement
  {id:'debasement', name:'Currency Debasement', cost:600, req:{denarii:500}, effect:'debasement',
   desc:'Debase the silver coinage to raise funds: +1000 denarii but increase inflation.', unlocked:false},
  // New technology: Slave Labour. Agricultural estates rely on enslaved labour, boosting output at social cost„Äê125891637790098‚Ä†L630-L640„Äë.
  {id:'slave_labor', name:'Slave Labour', cost:450, req:{pop:200}, effect:'slave_labor',
   desc:'Expand slave labour on estates. +20% production empire‚Äëwide but reduce happiness and increase unrest.', unlocked:false},
  // New technology: Publicani Tax Farming. Outsource taxation to private publicani, raising revenue but heightening unrest„Äê34825581980994‚Ä†L84-L87„Äë„Äê34825581980994‚Ä†L151-L155„Äë.
  {id:'tax_farming', name:'Publicani Tax Farming', cost:700, req:{denarii:400}, effect:'tax_farming',
   desc:'Contract publicani to collect taxes. +20% tax revenue but increases unrest and lowers stability.', unlocked:false},
  // New technology: Edict on Maximum Prices. Diocletian‚Äôs price controls sought to curb inflation but caused shortages„Äê51967448262050‚Ä†L123-L131„Äë„Äê51967448262050‚Ä†L145-L153„Äë.
  {id:'price_controls', name:'Edict on Maximum Prices', cost:550, req:{pop:150}, effect:'price_controls',
   desc:'Impose maximum prices to curb inflation. Reduces inflation by 10% but lowers production and happiness.', unlocked:false},
  // === New technologies introducing additional gameplay systems ===
  // Medicine advances unlock a primitive health system allowing the construction of apothecaries and hospitals.
  {id:'medicine', name:'Herbal Medicine', cost:500, req:{sanitation:40,pop:150}, effect:'medicine',
   desc:'Study herbal remedies and basic medicine. Unlocks health buildings and improves disease resistance.', unlocked:false},
  // Cultural development through entertainment venues boosts happiness and attracts migrants.
  {id:'theatre', name:'Grand Theatre', cost:650, req:{favor:15,pop:250}, effect:'theatre',
   desc:'Construct a theatre to host plays and festivals. Increases happiness and cultural prestige.', unlocked:false},
  // Naval navigation unlocks overseas trade, enabling profitable but risky maritime expeditions.
  {id:'navigation', name:'Celestial Navigation', cost:700, req:{territories:4}, effect:'navigation',
   desc:'Chart the stars and seas. Allows overseas trade routes with Europe and the Mediterranean.', unlocked:false},
  // Workshops allow crafting of advanced tools and weapons by combining base resources.
  {id:'workshop', name:'Artisan Workshops', cost:600, req:{pop:180}, effect:'workshop',
   desc:'Establish workshops where craftsmen refine raw materials into finished goods. Unlocks crafting system.', unlocked:false},
  // Diplomacy research formalises envoy training and negotiating tactics with neighbouring tribes.
  {id:'diplomacy', name:'Envoy Diplomacy', cost:550, req:{favor:12,pop:200}, effect:'diplomacy',
   desc:'Train envoys and adopt diplomatic protocols. Unlocks the Diplomacy tab to manage relations.', unlocked:false},
];

// === Apply tech perk (supports procedural techs) ===
function applyTechPerk(tech){
  if (!tech) return;
  // Built-in effects already handled elsewhere; only handle procedural or extra perks here.
  if (typeof tech._apply === 'function') {
    try { tech._apply(S); } catch(e){ console.warn('Perk apply error', e); }
  } else {
    // Map some known textual effects to state deltas for robustness
    switch (tech.effect) {
      case 'tradePrices': S.questTradeBuff = (S.questTradeBuff||1) * 1.05; break;
      case 'tradeRisk': S.proc_perk_risk = (S.proc_perk_risk||1) * 0.85; break;
      case 'food': S.maxFood += 50; break;
      case 'military': S.attackBonus = (S.attackBonus||0) + 5; break;
      case 'population': S.proc_perk_pop_growth = (S.proc_perk_pop_growth||0) + 1; break;
      case 'equipment': S.supplies = (S.supplies||0) + 10; break;
      case 'defense': S.forts += 1; break;
      case 'governance': S.favor += 2; break;
      case 'farming': S.proc_perk_prod_all = (S.proc_perk_prod_all||0) + 0.15; break;
      case 'mining': S.proc_perk_prod_all = (S.proc_perk_prod_all||0) + 0.20; break;
      case 'debasement':
        // Currency debasement: immediate monetary gain but long‚Äëterm inflation.
        S.denarii = (S.denarii || 0) + 1000;
        // Track cumulative debasement multiplier; each activation increases inflation by 10%.
        S.debasementBonus = (S.debasementBonus || 1) * 1.10;
        break;
      case 'slave_labor':
        // Intensify slave labour: boost production but increase unrest and reduce happiness.
        S.proc_perk_prod_all = (S.proc_perk_prod_all || 0) + 0.20;
        S.unrestLevel = (S.unrestLevel || 0) + 10;
        S.happiness = Math.max(0, (S.happiness || 50) - 10);
        break;
      case 'tax_farming':
        // Publicani tax farming raises revenue but spurs unrest and reduces stability across territories.
        S.taxFarmingBonus = (S.taxFarmingBonus || 1) * 1.20;
        S.unrestLevel = (S.unrestLevel || 0) + 15;
        // Reduce stability slightly in all territories to reflect unpopular tax collectors
        if (S.territoryData) {
          Object.values(S.territoryData).forEach(t => {
            if (t && typeof t.stability === 'number') {
              t.stability -= 5;
            }
          });
        }
        break;
      case 'price_controls':
        // Diocletian‚Äôs price controls lower inflation but hurt production and happiness.
        S.priceControlBonus = (S.priceControlBonus || 1) * 0.90;
        S.proc_perk_prod_all = (S.proc_perk_prod_all || 0) - 0.10;
        S.happiness = Math.max(0, (S.happiness || 50) - 15);
        break;
      case 'medicine':
        // Unlock basic health care: enable hospitals and apothecaries and improve resistance to disease.
        S.diseaseResistance = (S.diseaseResistance || 0) + 0.2;
        S.healthSystemUnlocked = true;
        break;
      case 'theatre':
        // Building a theatre boosts cultural appeal and happiness.
        S.cultureBonus = (S.cultureBonus || 0) + 0.15;
        S.happiness = (S.happiness || 0) + 10;
        break;
      case 'navigation':
        // Celestial navigation opens overseas trade and grants a modest trade price bonus.
        S.navalTradeUnlocked = true;
        S.navalTradeBonus = (S.navalTradeBonus || 0) + 0.10;
        break;
      case 'workshop':
        // Establishing workshops unlocks the crafting system for improved goods.
        S.craftingUnlocked = true;
        S.proc_perk_prod_all = (S.proc_perk_prod_all || 0) + 0.05;
        break;
      case 'diplomacy':
        // Envoy diplomacy unlocks the diplomacy interface and slightly improves relations with all tribes.
        S.diplomacyUnlocked = true;
        if (S.diplomacy) {
          Object.keys(S.diplomacy).forEach(k => {
            S.diplomacy[k] = (S.diplomacy[k] || 0) + 5;
          });
        }
        break;
    }
  }
}

// === Seeded RNG for procedural techs ===
if (typeof window !== "undefined" && window.S && !window.S.seed) { S.seed = 1337; } // default classroom seed; can be changed per save
function _srand(n){ S.seed = (S.seed ^ n) >>> 0; }
function _srand_str(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){h^=str.charCodeAt(i); h=(h*16777619)>>>0;} S.seed^=h; }
function _rand(){
  // xorshift32
  let x = (S.seed||123456789)>>>0;
  x ^= x << 13; x >>>= 0;
  x ^= x >> 17; x >>>= 0;
  x ^= x << 5;  x >>>= 0;
  S.seed = x>>>0;
  return (x>>>0) / 4294967296;
}
function _rpick(arr){ return arr[Math.floor(_rand()*arr.length)]; }

// === Procedural (seeded) technologies ===
function generateSeededTechs(count=4){
  const nouns = ['Agraria','Mercatura','Militaris','Civitas','Aqua','Ferraria','Textilis','Cultura','Viaria','Sanitas'];
  const kinds = [
    {effect:'prod_all', desc:'+10‚Äì25% all production', apply:s=>{ s.proc_perk_prod_all=(s.proc_perk_prod_all||0)+ (_rand()*0.15+0.10);} },
    {effect:'sell_bonus', desc:'+1‚Äì3% sell prices', apply:s=>{ s.proc_perk_sell=(s.proc_perk_sell||0)+ (_rand()*0.02+0.01);} },
    {effect:'capacity', desc:'+10‚Äì40 capacity', apply:s=>{ s.capacity += Math.floor(_rand()*30)+10; } },
    {effect:'happiness', desc:'+4‚Äì12 happiness', apply:s=>{ s.happiness = Math.min(100, s.happiness + Math.floor(_rand()*8)+4); } },
    {effect:'tariff', desc:'-5‚Äì15% tariffs', apply:s=>{ s.proc_perk_tariff=(s.proc_perk_tariff||1)*(1-(_rand()*0.10+0.05)); } },
    {effect:'risk', desc:'-5‚Äì15% trade risk', apply:s=>{ s.proc_perk_risk=(s.proc_perk_risk||1)*(1-(_rand()*0.10+0.05)); } },
    {effect:'food_decay', desc:'Food decay -25‚Äì50%', apply:s=>{ s.proc_perk_food_decay=(s.proc_perk_food_decay||1)*(1-(_rand()*0.25+0.25)); } },
    {effect:'morale', desc:'+5‚Äì15 morale', apply:s=>{ s.morale = Math.min(100, s.morale + Math.floor(_rand()*10)+5); } },
    {effect:'pop_growth', desc:'+1‚Äì3 pop growth per round', apply:s=>{ s.proc_perk_pop_growth=(s.proc_perk_pop_growth||0)+ Math.floor(_rand()*3)+1; } },
  ];

  const newly = [];
  for (let i=0;i<count;i++){
    const n = Math.floor(_rand()*900)+200; // cost 200‚Äì1100
    const k = _rpick(kinds);
    const name = _rpick(nouns) + ' ' + (['I','II','III','IV','V','VI','VII'][Math.floor(_rand()*7)]);
    const id = 'proc_' + name.replace(/\s+/g,'_').toLowerCase() + '_' + i;
    newly.push({id, name, cost:n, req:{}, effect:k.effect, desc:k.desc, unlocked:false, _apply:k.apply});
  }
  return newly;
}

// Events - EXPANDED!
const EVENTS = [
  { id:'wolf', name:'She-Wolf Omen', icon:'üê∫', prob:0.15,
    text:'Hearts lift; roads feel safer. The divine favor shines upon you.',
    effect:s=>{ s.riskMul=0.85; s.moraleAdd=+8; s.favorAdd=+2; s.happinessAdd=+5; } },
  { id:'harvest', name:'Bountiful Harvest', icon:'üåæ', prob:0.12,
    text:'Fields overflow with grain. All farms produce double this season.',
    effect:s=>{ s.farmBonus=2.0; s.happinessAdd=+6; } },
  { id:'drought', name:'Summer Drought', icon:'‚òÄÔ∏è', prob:0.10,
    text:'Pastures dry; grain fails. Farm production halved.',
    effect:s=>{ s.farmBonus=0.5; s.foodDelta=-30; s.popAdd=-5; } },
  { id:'migration', name:'Refugee Migration', icon:'üë®üë©üëßüë¶', prob:0.09,
    text:'Families seek safety in your settlement.',
    effect:s=>{ s.popAdd=+18; s.foodDelta=-25; } },
  { id:'trade_boom', name:'Trade Festival', icon:'üé™', prob:0.11,
    text:'Merchants flock to your forum. +10% sell prices this season.',
    effect:s=>{ s.sellBonus=1.1; } },
  { id:'plague', name:'Plague Outbreak', icon:'üíÄ', prob:0.08,
    text:'Disease spreads through the settlement. Sanitation drops.',
    effect:s=>{ s.popAdd=-15; s.sanitationDelta=-20; s.happinessAdd=-10; } },
  { id:'festival_mars', name:'Festival of Mars', icon:'‚öîÔ∏è', prob:0.10,
    text:'A grand celebration honors the god of war. Morale soars but costs mount.',
    effect:s=>{ s.moraleAdd=+15; s.denariDelta=-100; s.happinessAdd=+8; } },
  { id:'merchant_guild', name:'Merchant Guild Forms', icon:'üèõÔ∏è', prob:0.06,
    text:'Traders organize, establishing permanent trade routes.',
    effect:s=>{ s.permanentTradeBuff=true; } },
  { id:'scouts', name:'Barbarian Scouts', icon:'üëÅÔ∏è', prob:0.08,
    text:'Enemy scouts spotted near the borders. A raid approaches soon!',
    effect:s=>{ s.raidWarning=true; } },
  { id:'abundant_wildlife', name:'Abundant Wildlife', icon:'ü¶å', prob:0.09,
    text:'Hunters return with plentiful game. Livestock production increases.',
    effect:s=>{ s.livestockBonus=2.0; } },
  { id:'political_intrigue', name:'Political Intrigue', icon:'üé≠', prob:0.07,
    text:'Senate politics work in your favor. Gain influence or lose respect.',
    effect:s=>{ Math.random() > 0.5 ? s.favorAdd=+5 : s.reputationAdd=-3; } },
  { id:'construction_boom', name:'Construction Boom', icon:'üèóÔ∏è', prob:0.08,
    text:'Skilled builders arrive. Construction costs reduced this season.',
    effect:s=>{ s.buildCostMul=0.7; } },
  { id:'bandits', name:'Bandit Activity', icon:'üó°Ô∏è', prob:0.09,
    text:'Bandits raid trade routes. Risk increases, some goods stolen.',
    effect:s=>{ s.riskMul=1.3; s.foodDelta=-20; } },
  { id:'good_weather', name:'Perfect Weather', icon:'‚òÄÔ∏èüåßÔ∏è', prob:0.10,
    text:'Ideal conditions for growth. Population and food increase.',
    effect:s=>{ s.popAdd=+8; s.foodDelta=+40; s.happinessAdd=+5; } },
  { id:'iron_discovery', name:'Iron Deposit Found', icon:'‚öíÔ∏è', prob:0.05,
    text:'Prospectors discover rich iron veins near your territory.',
    effect:s=>{ s.ironBonus=3.0; } },
  { id:'religious_ceremony', name:'Sacred Ceremony', icon:'üïØÔ∏è', prob:0.08,
    text:'Priests perform rituals. The gods seem pleased.',
    effect:s=>{ s.favorAdd=+4; s.moraleAdd=+6; s.happinessAdd=+8; } },
  { id:'skilled_workers', name:'Skilled Workers Arrive', icon:'üë∑‚ôÇÔ∏è', prob:0.07,
    text:'Master craftsmen settle in your city. Production efficiency rises.',
    effect:s=>{ s.productionBuff=1.3; } },
  { id:'tax_revolt', name:'Tax Protests', icon:'üò†', prob:0.06,
    text:'Citizens protest high taxes. Happiness drops but you gain some funds.',
    effect:s=>{ s.denariDelta=+150; s.happinessAdd=-12; } },
  { id:'allied_traders', name:'Allied Traders', icon:'ü§ù', prob:0.08,
    text:'Foreign merchants offer favorable deals. Trade tariffs reduced.',
    effect:s=>{ s.tariffMul=0.7; } },
  { id:'architectural_marvel', name:'Architectural Marvel', icon:'üèõÔ∏è', prob:0.04,
    text:'A brilliant engineer designs magnificent buildings. Reputation soars!',
    effect:s=>{ s.reputationAdd=+10; s.happinessAdd=+10; } },

  // === New natural disaster events ===
  { id:'storm', name:'Mediterranean Storm', icon:'üåä', prob:0.06,
    text:'Violent storms lash the coast. Ships and trade caravans are delayed.',
    effect:s=>{ s.riskMul=1.25; s.foodDelta=-20; s.happinessAdd=-5; } },
  { id:'flood', name:'Tiber Flood', icon:'üåßÔ∏è', prob:0.07,
    text:'The Tiber overflows its banks, inundating farms and granaries.',
    effect:s=>{ s.foodDelta=-50; s.sanitationDelta=-15; s.happinessAdd=-8; } },
  { id:'locust', name:'Locust Swarm', icon:'üêõ', prob:0.06,
    text:'Ravenous locusts devour crops across your fields, threatening famine.',
    effect:s=>{ s.foodDelta=-40; s.popAdd=-10; } },
  { id:'harsh_winter', name:'Harsh Winter', icon:'‚ùÑÔ∏è', prob:0.05,
    text:'An exceptionally cold winter grips the land, straining your supplies.',
    effect:s=>{ s.foodDelta=-35; s.moraleAdd=-8; s.happinessAdd=-5; } },
];

// Achievements - NEW!
const ACHIEVEMENTS = [
  {id:'first_blood', name:'First Blood', icon:'‚öîÔ∏è', desc:'Win your first conquest',
   check:s=>s.victories>=1, reward:{denarii:100, favor:2}},
  {id:'iron_empire', name:'Iron Empire', icon:'‚öíÔ∏è', desc:'Produce 100 iron total',
   check:s=>(s.resourcesProduced.iron||0)>=100, reward:{denarii:200, reputation:5}},
  {id:'pacifist', name:'Pacifist', icon:'üïäÔ∏è', desc:'Reach season 10 without conquering beyond Palatine',
   check:s=>s.round>=10 && s.territories.length===1, reward:{happiness:15, favor:5}},
  {id:'trade_baron', name:'Trade Baron', icon:'üí∞', desc:'Earn 5000d from a single trade season',
   check:s=>false, reward:{capacity:20}}, // Checked during trade
  {id:'legendary_find', name:'Legendary Find', icon:'‚ú®', desc:'Find a Legendary or Imperial rarity item',
   check:s=>false, reward:{denarii:500, reputation:10}}, // Checked on generation
  {id:'against_odds', name:'Against All Odds', icon:'üé≤', desc:'Win a battle with less than 30% chance',
   check:s=>false, reward:{morale:20, favor:5}}, // Checked in battle
  {id:'economic_titan', name:'Economic Titan', icon:'üíé', desc:'Reach 20,000 denarii',
   check:s=>s.denarii>=20000, reward:{favor:10, reputation:10}},
  {id:'population_boom', name:'Population Boom', icon:'üë•', desc:'Reach 500 population',
   check:s=>s.pop>=500, reward:{housing:50}},
  {id:'military_might', name:'Military Might', icon:'üõ°Ô∏è', desc:'Train 200 troops',
   check:s=>s.troops>=200, reward:{morale:15, supplies:50}},
  {id:'master_builder', name:'Master Builder', icon:'üèóÔ∏è', desc:'Construct 15 production buildings',
   check:s=>s.productionBuildings.length>=15, reward:{capacity:30}},
  {id:'undefeated', name:'Undefeated', icon:'üëë', desc:'Win 5 battles in a row',
   check:s=>s.currentWinStreak>=5, reward:{denarii:300, morale:10}},
  {id:'renaissance', name:'Renaissance', icon:'üî¨', desc:'Research 8 technologies',
   check:s=>Object.values(s.techs).filter(Boolean).length>=8, reward:{favor:8, reputation:8}},
  {id:'territorial', name:'Territorial', icon:'üó∫Ô∏è', desc:'Control 10 territories',
   check:s=>s.territories.length>=10, reward:{reputation:15}},
  {id:'survivor', name:'Survivor', icon:'üí™', desc:'Survive to season 30',
   check:s=>s.round>=30, reward:{denarii:500, favor:5}},
  {id:'infinite_founder', name:'Infinite Founder', icon:'‚ôæÔ∏è', desc:'Enter infinite mode',
   check:s=>s.infiniteMode, reward:{capacity:50}},
  // Wonder Achievements
  {id:'wonder_colosseum', name:'People\'s Champion', icon:'üèüÔ∏è', desc:'Built the Colosseum',
   check:s=>s.wonders?.colosseum?.built, reward:{influence:50, piety:25}},
  {id:'wonder_pantheon', name:'Divine Architect', icon:'‚õ™', desc:'Built the Pantheon',
   check:s=>s.wonders?.pantheon?.built, reward:{piety:75, denarii:500}},
  {id:'wonder_circus_maximus', name:'Master of Games', icon:'üèá', desc:'Built Circus Maximus',
   check:s=>s.wonders?.circus_maximus?.built, reward:{population:50, denarii:400}},
  {id:'wonder_aqua_claudia', name:'Hydraulic Engineer', icon:'üåä', desc:'Built Aqua Claudia',
   check:s=>s.wonders?.aqua_claudia?.built, reward:{sanitation:50, housing:200}},
  {id:'wonder_forum_romanum', name:'Voice of Rome', icon:'üèõÔ∏è', desc:'Built Forum Romanum',
   check:s=>s.wonders?.forum_romanum?.built, reward:{influence:60, denarii:600}},
  {id:'wonder_palatine_palace', name:'Imperial Majesty', icon:'üëë', desc:'Built Palatine Palace',
   check:s=>s.wonders?.palatine_palace?.built, reward:{influence:100, luxuries:50}},
  {id:'wonder_collector', name:'Wonder Collector', icon:'üóø', desc:'Build any 3 wonders',
   check:s=>s.wonders && Object.values(s.wonders).filter(w=>w.built).length>=3, reward:{reputation:25, favor:15}},
  {id:'architectural_marvel', name:'Architectural Marvel', icon:'‚ú®', desc:'Build all 6 wonders',
   check:s=>s.wonders && Object.values(s.wonders).filter(w=>w.built).length>=6, reward:{denarii:5000, influence:200, piety:100}},
];

// Quests - NEW!
const QUEST_TEMPLATES = [
  {id:'senate_farms', name:'The Senate Requests', icon:'üåæ', desc:'Build 3 farms',
   type:'building', target:'farm', count:3, reward:{denarii:300, favor:5}},
  {id:'military_expansion', name:'Military Expansion', icon:'‚öîÔ∏è', desc:'Conquer 2 territories',
   type:'conquest', count:2, reward:{troops:100, reputation:5}},
  {id:'trade_mission', name:'Trade Mission', icon:'üí∞', desc:'Complete 5 successful trades',
   type:'trade', count:5, reward:{tradeBuff:1.1, duration:5}},
  {id:'engineering', name:'Roman Engineering', icon:'üèõÔ∏è', desc:'Research 3 technologies',
   type:'research', count:3, reward:{capacity:20, reputation:5}},
  {id:'population_growth', name:'Population Growth', icon:'üë•', desc:'Reach 250 population',
   type:'population', target:250, reward:{housing:30, happiness:10}},
  {id:'military_training', name:'Military Training', icon:'üõ°Ô∏è', desc:'Train 50 troops',
   type:'troops', target:50, reward:{morale:15, supplies:25}},
  {id:'economic_power', name:'Economic Power', icon:'üíé', desc:'Accumulate 8000 denarii',
   type:'wealth', target:8000, reward:{favor:8, reputation:8}},
  {id:'resource_stockpile', name:'Resource Stockpile', icon:'üì¶', desc:'Store 80 resources',
   type:'inventory', target:80, reward:{capacity:15}},
];

// Resource Combinations - NEW!
const RESOURCE_COMBOS = [
  {id:'forge_weapons', name:'Forge Weapons', icon:'‚öîÔ∏è', 
   cost:{iron:5, timber:2}, effect:{attackBonus:20, duration:1},
   desc:'+20% attack power for one season'},
  {id:'feast', name:'Host Feast', icon:'üçñ',
   cost:{grain:10, livestock:5}, effect:{happiness:15},
   desc:'+15% happiness permanently'},
  {id:'monument', name:'Build Monument', icon:'üóø',
   cost:{clay:10, timber:5}, effect:{reputation:5},
   desc:'+5 reputation permanently'},
  {id:'supply_cache', name:'Supply Cache', icon:'üì¶',
   cost:{grain:20, salt:5}, effect:{defense:1},
   desc:'+1 fort equivalent for defense'},
  {id:'trade_caravan', name:'Trade Caravan', icon:'üê´',
   cost:{livestock:3, wool:5}, effect:{tradeBuff:1.15, duration:3},
   desc:'+15% trade prices for 3 seasons'},
  {id:'wine_festival', name:'Wine Festival', icon:'üç∑',
   cost:{wine:8, grain:5}, effect:{morale:12, happiness:8},
   desc:'+12% morale, +8% happiness'},
];

// Seasonal Effects - NEW!
/*
 * Seasons have been expanded to better reflect how weather and climate impact
 * agricultural and maritime production.  In addition to the existing farm
 * bonus in spring, summer now boosts fishing yields, while winter reduces
 * farm and fishery output.  The description fields have been updated to
 * communicate these effects to the player.
 */
const SEASONS = [
  {
    name: 'Spring',
    icon: 'üå∏',
    effect: { farmBonus: 1.1 },
    desc: 'Farms +10% production'
  },
  {
    name: 'Summer',
    icon: '‚òÄÔ∏è',
    // Summer: slightly less food consumed, boost happiness and fish production
    effect: { foodConsumption: 0.95, happiness: 5, fishBonus: 1.1 },
    desc: 'Less food needed, +5% happiness, fisheries +10% production'
  },
  {
    name: 'Autumn',
    icon: 'üçÇ',
    effect: { tradePrices: 1.05 },
    desc: 'Trade prices +5%'
  },
  {
    name: 'Winter',
    icon: '‚ùÑÔ∏è',
    // Winter: higher upkeep, morale penalty and reduced production for farms and fisheries
    effect: { upkeepMul: 1.15, moralePenalty: 3, fishBonus: 0.9, farmBonus: 0.9 },
    desc: 'Upkeep +15%, -3% morale, farms & fisheries -10% production'
  }
];

// Territory Specializations - NEW!
const SPECIALIZATIONS = [
  {id:'military', name:'Military Outpost', icon:'‚öîÔ∏è', cost:300,
   effect:{troopBonus:0.1, fortBonus:1}, desc:'+10% troop recruitment, +1 fort'},
  {id:'trade', name:'Trade Hub', icon:'üí∞', cost:300,
   effect:{tariffReduction:0.1, reputation:3}, desc:'-10% tariffs, +3 reputation'},
  {id:'farm', name:'Breadbasket', icon:'üåæ', cost:250,
   effect:{foodBonus:0.5}, desc:'+50% food production from this territory'},
  {id:'mine', name:'Mining District', icon:'‚öíÔ∏è', cost:350,
   effect:{mineralBonus:0.5}, desc:'+50% mineral production'},
];

// Emergency Actions - NEW!
const EMERGENCY_ACTIONS = [
  {id:'emergency_tax', name:'Emergency Taxes', icon:'üí∞', cost:0,
   effect:{denarii:500, happiness:-20}, cooldown:5,
   desc:'Raise 500d, -20% happiness'},
  {id:'conscription', name:'Conscription', icon:'‚öîÔ∏è', cost:0,
   effect:{troops:100, pop:-30}, cooldown:10,
   desc:'Gain 20 troops, lose 30 population'},
  {id:'sell_territory', name:'Sell Territory', icon:'üó∫Ô∏è', cost:0,
   effect:{denarii:800, territory:-1}, cooldown:15,
   desc:'Sell a territory for 800d'},
  {id:'call_aid', name:'Call for Aid', icon:'üÜò', cost:10,
   effect:{denarii:200, troops:100, favor:-10}, cooldown:8,
   desc:'Get 200d and 15 troops, -10 favor'},
];

// Military Unit Types - NEW!
const MILITARY_UNITS = [
  {id:'militia', name:'Militia', icon:'üßëüåæ', costDenarii:80, costFood:5,
   troopsMin:8, troopsMax:12, desc:'Cheap civilian conscripts. Low training but affordable.'},
  {id:'legionaries', name:'Legionaries', icon:'‚öîÔ∏è', costDenarii:140, costFood:8,
   troopsMin:12, troopsMax:18, desc:'Standard infantry. Backbone of your army.'},
  {id:'archers', name:'Archers', icon:'üèπ', costDenarii:120, costFood:6,
   troopsMin:10, troopsMax:15, desc:'Ranged units. Good value for flexible tactics.'},
  {id:'cavalry', name:'Cavalry', icon:'üê¥', costDenarii:250, costFood:12,
   troopsMin:20, troopsMax:30, desc:'Elite mounted warriors. Expensive but powerful.'},
  {id:'praetorians', name:'Praetorian Guard', icon:'üõ°Ô∏è', costDenarii:400, costFood:15,
   troopsMin:35, troopsMax:50, desc:'Elite guards. The finest troops Rome can produce.'},
  {id:'auxiliaries', name:'Auxiliaries', icon:'üó°Ô∏è', costDenarii:100, costFood:7,
   troopsMin:10, troopsMax:16, desc:'Foreign mercenaries. Decent value with local support.'}
];

// Victory conditions
const ENDINGS = [
  {cond:s=>s.territories.length>=10 && s.pop>=500 && s.happiness>=75, 
   title:'üèõÔ∏è The Eternal City', text:'Rome dominates Italia. Ten territories under your banner. The legend begins.'},
  {cond:s=>s.denarii>=15000 && s.reputation>=35, 
   title:'üí∞ Master of Commerce', text:'Your trade empire spans the peninsula. Wealth flows like the Tiber.'},
  {cond:s=>s.territories.length>=8 && s.troops>=180, 
   title:'‚öîÔ∏è Conqueror King', text:'Your legions are unmatched. Italia trembles at your name.'},
  {cond:s=>s.pop>=600 && s.happiness>=90, 
   title:'üèòÔ∏è City of Glory', text:'A thriving metropolis of culture and prosperity. The people sing your praises.'},
  {cond:s=>s.productionBuildings.length>=15 && s.denarii>=10000, 
   title:'üè≠ Industrial Pioneer', text:'Farms, mines, and workshops fuel an economic powerhouse.'},
  {cond:s=>s.starvedRounds>=3 || s.pop<40, 
   title:'üíÄ Famine', text:'Hunger scattered your people to the winds.'},
  {cond:()=>true, 
   title:'üé≠ Legend of the Founders', text:'Though Rome did not rise as you hoped, your deeds echo in history.'},
];

/* ==================== RELIGION SYSTEM ==================== */

// Roman Gods with unique benefits
const ROMAN_GODS = [
  {id:'jupiter', name:'Jupiter', icon:'‚ö°', domain:'King of Gods', 
   favor:0, maxFavor:100,
   bonus:'Military victories grant bonus favor and piety',
   blessings:[
    {level:25, name:'Divine Thunder', effect:'troops', value:20, desc:'+20 troops'},
    {level:50, name:'Storm Shield', effect:'defense', value:15, desc:'+15% defense in battle'},
    {level:75, name:'Sky King\'s Might', effect:'morale', value:20, desc:'+20% morale'},
    {level:100, name:'Thunderbolt Strike', effect:'attack', value:25, desc:'+25% attack power'}
  ]},
  {id:'mars', name:'Mars', icon:'‚öîÔ∏è', domain:'God of War',
   favor:0, maxFavor:100,
   bonus:'Military training and recruitment cost less',
   blessings:[
    {level:25, name:'War Cry', effect:'morale', value:15, desc:'+15% morale'},
    {level:50, name:'Legion\'s Blessing', effect:'recruit', value:20, desc:'-20% recruitment cost'},
    {level:75, name:'Battle Fury', effect:'attack', value:30, desc:'+30% attack power'},
    {level:100, name:'Invincible Legion', effect:'troops', value:50, desc:'+50 troops'}
  ]},
  {id:'venus', name:'Venus', icon:'üíù', domain:'Goddess of Love',
   favor:0, maxFavor:100,
   bonus:'Increases happiness and population growth',
   blessings:[
    {level:25, name:'Love\'s Embrace', effect:'happiness', value:15, desc:'+15% happiness'},
    {level:50, name:'Fertility Rite', effect:'pop_growth', value:5, desc:'+5 population growth per season'},
    {level:75, name:'Joy of Venus', effect:'happiness', value:30, desc:'+30% happiness'},
    {level:100, name:'Divine Beauty', effect:'favor_all', value:50, desc:'+50 favor with all gods'}
  ]},
  {id:'ceres', name:'Ceres', icon:'üåæ', domain:'Goddess of Agriculture',
   favor:0, maxFavor:100,
   bonus:'Food production increased significantly',
   blessings:[
    {level:25, name:'Bountiful Harvest', effect:'food', value:100, desc:'+100 food'},
    {level:50, name:'Fertile Fields', effect:'food_production', value:50, desc:'+50% food production'},
    {level:75, name:'Never Hunger', effect:'food_decay', value:50, desc:'-50% food decay'},
    {level:100, name:'Eternal Abundance', effect:'food', value:500, desc:'+500 food'}
  ]},
  {id:'mercury', name:'Mercury', icon:'ü™Ω', domain:'God of Commerce',
   favor:0, maxFavor:100,
   bonus:'Trade prices improved, reduced tariffs',
   blessings:[
    {level:25, name:'Swift Trade', effect:'trade_risk', value:10, desc:'-10% trade risk'},
    {level:50, name:'Merchant\'s Fortune', effect:'trade_prices', value:15, desc:'+15% trade prices'},
    {level:75, name:'Golden Tongue', effect:'tariff', value:25, desc:'-25% tariffs'},
    {level:100, name:'Lord of Profit', effect:'denarii', value:2000, desc:'+2000 denarii'}
  ]},
  {id:'minerva', name:'Minerva', icon:'ü¶â', domain:'Goddess of Wisdom',
   favor:0, maxFavor:100,
   bonus:'Technology research costs reduced',
   blessings:[
    {level:25, name:'Scholarly Insight', effect:'tech_cost', value:15, desc:'-15% tech research cost'},
    {level:50, name:'Wisdom\'s Light', effect:'reputation', value:10, desc:'+10 reputation'},
    {level:75, name:'Strategic Mind', effect:'attack', value:15, desc:'+15% attack power'},
    {level:100, name:'Divine Intellect', effect:'favor', value:20, desc:'+20 favor'}
  ]}
];

// Religious Buildings
const RELIGIOUS_BUILDINGS = [
  {id:'shrine', name:'Small Shrine', latinName:'Sacellum', icon:'üïØÔ∏è', 
   cost:200, pietyGain:3, godFavorGain:2,
   desc:'A modest shrine for daily worship. Generates piety and god favor each season.',
   rarity:rollRarity()},
  {id:'temple', name:'Grand Temple', latinName:'Templum Magnum', icon:'üèõÔ∏è',
   cost:600, pietyGain:8, godFavorGain:5,
   desc:'A magnificent temple that attracts pilgrims. Significant piety and favor.',
   rarity:rollRarity()},
  {id:'oracle', name:'Oracle\'s Sanctum', latinName:'Oraculum', icon:'üîÆ',
   cost:450, pietyGain:5, godFavorGain:8,
   desc:'Divine prophecy center. Exceptional favor gain from gods.',
   rarity:rollRarity()},
  {id:'altar', name:'Sacred Altar', latinName:'Ara Sacra', icon:'‚õ©Ô∏è',
   cost:350, pietyGain:6, godFavorGain:4,
   desc:'A blessed altar for offerings. Good balance of piety and favor.',
   rarity:rollRarity()},
  {id:'augury', name:'Augury House', latinName:'Auguraculum', icon:'ü¶Ö',
   cost:500, pietyGain:7, godFavorGain:6,
   desc:'Read the omens and divine will. Strong spiritual benefits.',
   rarity:rollRarity()}
];

// Religious Actions
const RELIGIOUS_ACTIONS = [
  {id:'prayer', name:'Offer Prayers', icon:'üôè', cost:{piety:0}, cooldown:0,
   effect:{godFavor:5, happiness:3}, desc:'Pray to gain +5 favor with chosen god, +3% happiness'},
  {id:'sacrifice', name:'Animal Sacrifice', icon:'üêë', cost:{denarii:100, livestock:2}, cooldown:0,
   effect:{godFavor:15, piety:5, favor:2}, desc:'Offer livestock to gain +15 god favor, +5 piety, +2 favor'},
  {id:'festival', name:'Religious Festival', icon:'üé≠', cost:{denarii:300, wine:3, grain:5}, cooldown:3,
   effect:{godFavor:25, happiness:15, piety:10, pop:10}, desc:'Host a grand festival: +25 god favor, +15% happiness, +10 piety, +10 population'},
  {id:'divination', name:'Divine Augury', icon:'üîÆ', cost:{denarii:150, piety:20}, cooldown:2,
   effect:{reveal:true, favor:5}, desc:'Read omens to reveal future events. +5 favor'},
  {id:'pilgrimage', name:'Sacred Pilgrimage', icon:'‚õ∞Ô∏è', cost:{denarii:250, food:10}, cooldown:4,
   effect:{godFavor:30, piety:15, reputation:8}, desc:'Send pilgrims to sacred sites: +30 god favor, +15 piety, +8 reputation'},
  {id:'consecration', name:'Consecrate Territory', icon:'‚ú®', cost:{denarii:400, piety:30}, cooldown:5,
   effect:{territory_bonus:true, godFavor:20}, desc:'Bless a territory for permanent production bonus. +20 god favor'},
  {id:'invoke', name:'Invoke Divine Blessing', icon:'üåü', cost:{piety:50}, cooldown:8,
   effect:{blessing:true}, desc:'Call upon a god for immediate powerful effect (varies by god)'}
];

// Religious Events
const RELIGIOUS_EVENTS = [
  {id:'omen', name:'Favorable Omen', icon:'ü¶Ö', prob:0.12,
   effect:m=>{m.pietyAdd=10; m.happinessAdd=5; m.godFavorAdd=5}, 
   text:'Eagles circle the temple! The gods smile upon Rome. +10 piety, +5% happiness, +5 god favor'},
  {id:'eclipse', name:'Solar Eclipse', icon:'üåë', prob:0.08,
   effect:m=>{m.pietyAdd=15; m.moraleAdd=-10; m.divinationReveal=true},
   text:'Darkness covers the sun! A sign of great change. +15 piety but -10% morale. Future events revealed.'},
  {id:'comet', name:'Divine Comet', icon:'‚òÑÔ∏è', prob:0.06,
   effect:m=>{m.godFavorAdd=20; m.reputationAdd=10},
   text:'A brilliant comet crosses the sky! The gods send a message. +20 god favor, +10 reputation'},
  {id:'miracle', name:'Divine Miracle', icon:'‚ú®', prob:0.04,
   effect:m=>{m.pietyAdd=25; m.foodDelta=200; m.happinessAdd=20},
   text:'A MIRACLE! Food multiplies, wounds heal! +25 piety, +200 food, +20% happiness'},
  {id:'curse', name:'Divine Curse', icon:'üíÄ', prob:0.05,
   effect:m=>{m.pietyAdd=-20; m.foodDelta=-50; m.moraleAdd=-15},
   text:'The gods are displeased! Crops wither. -20 piety, -50 food, -15% morale. Make offerings!'},
  {id:'vision', name:'Prophetic Vision', icon:'üëÅÔ∏è', prob:0.10,
   effect:m=>{m.pietyAdd=12; m.favorAdd=8; m.techCostReduction=0.2},
   text:'A priest receives divine wisdom! +12 piety, +8 favor, -20% tech costs next research'}
];

/* ==================== GLOBAL STATE ==================== */
const S = {
  stage:'intro', founder:null, mods:null, name:'',
  round:0, maxRounds:25, wolfClicks:0, infiniteMode:false, nextTerritoryId:1000,
  
  // Economy - BALANCED
  denarii:5000, favor:10, reputation:0, capacity:120,
  priceIndex:Object.fromEntries(GOODS.map(g=>[g.id,100])),
  inventory:Object.fromEntries(GOODS.map(g=>[g.id,0])),
  inventoryFull:false,
  
  // Military - BALANCED
  troops:100, morale:70, supplies:30, victories:0,

  // Unrest & Random Market Events - NEW!
  // The unrestLevel represents simmering social tension from high taxes or
  // other unpopular policies. It grows as taxes rise and certain events
  // occur. If it becomes too high, protests or outright rebellions can
  // trigger. marketEvents holds active temporary economic modifiers such
  // as embargoes, booms or famines. These are applied when updating
  // market prices and expire automatically after their duration.
  unrestLevel:0,
  marketEvents:[],
  
  // Settlement - BALANCED
  pop:120, housing:150, sanitation:50, forts:2, happiness:70, food:400,
  starvedRounds:0, maxFood:500, maxSanitation:100,
  
  // Religion - NEW!
  piety:0, maxPiety:1000,
  religiousBuildings:[], // Array of {type, id, level}
  godFavor:Object.fromEntries(ROMAN_GODS.map(g=>[g.id, 0])), // Favor with each god
  patronGod:null, // Primary god for worship
  blessingsActive:[], // Array of active divine blessings
  lastReligiousAction:{}, // {actionId: lastRound}
  consecratedTerritories:[], // Blessed territories with bonuses
  
  // Production
  productionBuildings:[], // Start with no buildings - players must build them!
  territories:['palatine'],
  
  // Tech & state
  techs:Object.fromEntries(TECHNOLOGIES.map(t=>[t.id,false])),
  history:[], focus:'resources', season:'spring', mapTab:0,
  eventModifiers:{}, milestonesReached:[],
  lastUpkeep:0, lastTaxes:0,
  
  // Raid system
  lastRaidRound:0, nextRaidRound:5, raidsPending:false, battleActive:false,
  
  // NEW FEATURES
  achievements:[], // Array of achievement IDs earned
  activeQuests:[], // {id, progress, target, reward}
  cityRelations:Object.fromEntries(CITIES.map(c=>[c.id, c.relation || 0])),
  territorySpecializations:{}, // {territoryId: specializationType}
  seasonIndex:0, // 0=spring, 1=summer, 2=autumn, 3=winter
  advisorDismissed:false,
  lastAdvisorMessage:'',

  // Tutorial system - new!
  // Tracks whether the introductory tutorial pop‚Äëups have been shown. New players will
  // see a short sequence of contextual hints when the game first starts.
  tutorialSeen:false,
  
  // Stats tracking
  totalIncomeEarned:0,
  totalSpentOnBuildings:0,
  largestConquestValue:0,
  currentWinStreak:0,
  longestWinStreak:0,
  resourcesProduced:{}, // By type
  tradeCount:0,
  emergencyActionsUsed:{},

  // === DIPLOMACY & NEW SYSTEMS ===
  // Diplomacy relations with neighbouring tribes. Values range roughly from -100 (hostile) to +100 (ally).
  diplomacy: {
    etruscans: 0,
    sabines: 0,
    gauls: 0
  },
  // Flags and bonuses for new systems unlocked via technologies.
  healthSystemUnlocked: false,
  diseaseResistance: 0,
  cultureBonus: 0,
  navalTradeUnlocked: false,
  navalTradeBonus: 0,
  craftingUnlocked: false,
  diplomacyUnlocked: false,
  
  // Trade system state
  tradeState: {
    upgrades: { wagons: 0, guards: 0, negotiation: 0 },
    reputation: {},
    routes: [],
    activeCaravan: null
  },
  
  // Territory Enhancement System - NEW!
  territoryData: {}, // Territory management data {territoryId: {level, stability, garrison, buildings, etc}}
  selectedTerritory: null, // Currently viewing territory in detail
  territoryTab: 'overview', // Current tab in territory detail view
  
  // === ECONOMIC SYSTEMS - NEW! ===
  taxationRate: 0.10, // 10% base tax rate (adjustable from 0-30%)
  lastTaxRevenue: 0, // Track tax income
  marketVolatility: 1.0, // Price fluctuation multiplier (1.0 = normal)
  supplyDemand: Object.fromEntries(GOODS.map(g=>[g.id, 100])), // Supply/demand index per good (100 = balanced)
  lastMarketUpdate: 0 // Track when prices were last updated
};

// Ensure the global `S` reference exists on `window` for external modules and
// click handlers that expect `window.S`. In non-module scripts, `const` and
// `let` declarations are not automatically assigned to `window`, so if other
// parts of the game rely on `window.S` being defined (e.g. easter eggs, map
// systems, or saved state loaders), they would encounter `undefined` and
// potentially throw errors. Assign `window.S` only if it has not already
// been set (for example, by a restored save). This avoids overwriting any
// existing game state while still providing a safe fallback for fresh loads.
if (typeof window !== 'undefined' && typeof window.S === 'undefined') {
  window.S = S;
}

// Load persistent tutorial flag from localStorage. Even if the player starts a new
// game, we respect their choice not to show the tutorial again on this device.
try {
  if (localStorage.getItem('founding_of_rome_tutorial_seen')) {
    S.tutorialSeen = true;
  }
} catch (e) {
  // ignore storage errors (e.g. private browsing)
}

// === Initialize procedural techs once on load ===
if (!S._procTechsAdded) {
  const proc = generateSeededTechs(5);
  if (typeof TECHNOLOGIES !== 'undefined' && Array.isArray(TECHNOLOGIES)) {
    proc.forEach(t => TECHNOLOGIES.push(t));
  }
  if (S.techs) {
    proc.forEach(t => { S.techs[t.id] = false; });
  }
  S._procTechsAdded = true;
}

/* ==================== UTILITIES ==================== */
// === Food consumption helper (early grace + seasonal realism + softer base) ===
function calcFoodConsumption() {
  const seasonalEffects = SEASONS[S.seasonIndex]?.effect || {};
  const seasonMul = seasonalEffects.foodConsumption || 1;

  // Gentle early-game rations: first 6 seasons 60%, next 6 seasons 80%
  const earlyMul = S.round <= 6 ? 0.6 : (S.round <= 12 ? 0.8 : 1);

  // Softer base coefficients vs previous 0.5/0.7 (pop/troops)
  const base = (S.pop * 0.42) + (S.troops * 0.55);

  return Math.floor(base * seasonMul * earlyMul);
}

const app = document.getElementById('app');
const el = (t,a={},...kids)=>{
  const n=document.createElement(t);
  for(const k in a){
    if(k==="class")n.className=a[k];
    else if(k.startsWith("on")&&typeof a[k]==="function")n.addEventListener(k.slice(2).toLowerCase(),a[k]);
    else if(k==="html")n.innerHTML=a[k];
    else if(k==="disabled"||k==="checked"||k==="selected")n[k]=a[k];
    else if(k==="style"&&typeof a[k]==="object")Object.assign(n.style,a[k]);
    else if(k!=="onClick")n.setAttribute(k,a[k]);
  }
  kids.flat().forEach(c=>n.append(c instanceof Node?c:document.createTextNode(String(c))));
  return n;
};

const clamp = (v,a,b) => Math.max(a,Math.min(b,v));
const fmt = n => new Intl.NumberFormat('en-US',{maximumFractionDigits:0}).format(Math.round(n));
const rpick = arr => arr[Math.floor(Math.random()*arr.length)];
const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);

/* ==================== ECONOMIC SYSTEMS ==================== */

// Dynamic Market Pricing System
function updateMarketPrices() {
  if (!window.S || !window.GOODS) {
    console.error('Cannot update market prices - missing game state');
    return;
  }
  
  const round = S.round || 0;
  
  // Ensure economy state is valid before updating
  validateEconomyState();
  
  // Check if enough time has passed (avoid too frequent updates)
  if (S.lastMarketUpdate && round - S.lastMarketUpdate < 1) {
    return; // Skip update if called multiple times in same round
  }
  
  // Update supply/demand based on inventory levels
  GOODS.forEach(good => {
    const inventoryAmount = S.inventory?.[good.id] || 0;
    const maxInventory = Math.max(1, S.capacity || 1000); // Prevent division by zero
    const inventoryRatio = inventoryAmount / maxInventory;
    
    // Get current demand with safety check
    let demandIndex = S.supplyDemand[good.id] || 100;
    if (isNaN(demandIndex)) {
      console.warn(`Resetting NaN demand for ${good.id}`);
      demandIndex = 100;
    }
    
    // Natural drift toward balance (10% of distance to 100)
    demandIndex += (100 - demandIndex) * 0.1;
    
    // Inventory influence
    if (inventoryRatio > 0.7) {
      // Oversupply - demand drops
      demandIndex -= 5 + Math.random() * 10;
    } else if (inventoryRatio < 0.3) {
      // Scarcity - demand rises
      demandIndex += 5 + Math.random() * 10;
    }
    
    // Random market fluctuation (¬±4)
    demandIndex += (Math.random() - 0.5) * 8;
    
    // Seasonal effects
    if (window.SEASONS && S.seasonIndex !== undefined) {
      const season = SEASONS[S.seasonIndex];
      if (season) {
        if (season.name === 'Winter' && (good.id === 'grain' || good.id === 'livestock')) {
          demandIndex += 15; // Food more valuable in winter
        }
        if (season.name === 'Summer' && good.id === 'wine') {
          demandIndex += 10; // Wine more valuable in summer
        }
      }
    }
    
    // Clamp demand index to valid range
    demandIndex = Math.max(50, Math.min(200, demandIndex));
    
    // Safety check before saving
    if (!isNaN(demandIndex)) {
      S.supplyDemand[good.id] = demandIndex;
    } else {
      console.error(`Failed to calculate valid demand for ${good.id}`);
      S.supplyDemand[good.id] = 100; // Emergency fallback
    }
  });
  
  S.lastMarketUpdate = round;
}

// Get market-adjusted price for a good
function getMarketPrice(goodId, basePrice, action = 'sell') {
  // Validate inputs
  if (typeof basePrice !== 'number' || isNaN(basePrice) || basePrice < 0) {
    console.warn(`Invalid basePrice for ${goodId}: ${basePrice}, using default 100`);
    basePrice = 100;
  }
  
  // Safely get demand index
  const demandIndexValue = S.supplyDemand?.[goodId];
  let demandIndex = 100; // Default
  
  if (demandIndexValue === undefined || demandIndexValue === null) {
    console.warn(`Missing demand index for ${goodId}, initializing to 100`);
    if (!S.supplyDemand) S.supplyDemand = {};
    S.supplyDemand[goodId] = 100;
  } else if (isNaN(demandIndexValue)) {
    console.error(`NaN demand index for ${goodId}, resetting to 100`);
    S.supplyDemand[goodId] = 100;
  } else {
    demandIndex = demandIndexValue;
  }
  
  const demandMult = demandIndex / 100;
  
  // Apply volatility (higher in infinite mode)
  const volatility = S.infiniteMode ? 1.5 : 1.0;
  
  // Calculate price with demand
  let price = basePrice * demandMult * volatility;
  
  // Merchant guild bonus
  let merchantBonus = 1.0;
  
  if (S.territories && Array.isArray(S.territories)) {
    S.territories.forEach(tId => {
      const data = S.territoryData?.[tId];
      if (data?.buildings && Array.isArray(data.buildings)) {
        if (data.buildings.includes('merchant_guild') && action === 'sell') {
          merchantBonus = Math.max(merchantBonus, 1.05);
        }
        if (data.buildings.includes('grand_market')) {
          merchantBonus = Math.max(merchantBonus, 1.08);
        }
      }
    });
  }
  
  if (action === 'sell') {
    price *= merchantBonus;
  }
  
  const finalPrice = Math.max(1, Math.floor(price));
  
  // Final NaN check
  if (isNaN(finalPrice)) {
    console.error('NaN final price for', goodId, '- returning minimum');
    return 1;
  }
  
  return finalPrice;
}

// Economy State Validation Function
function validateEconomyState() {
  if (!window.S) {
    console.error('Game state S is undefined!');
    return false;
  }
  
  let errors = [];
  let fixed = [];
  
  // Validate supply/demand
  if (!S.supplyDemand) {
    errors.push('supplyDemand object missing');
    S.supplyDemand = {};
  }
  
  // Validate price index
  if (!S.priceIndex) {
    errors.push('priceIndex object missing');
    S.priceIndex = {};
  }
  
  // Check each good
  if (window.GOODS && Array.isArray(GOODS)) {
    GOODS.forEach(g => {
      // Check supply/demand
      if (S.supplyDemand[g.id] === undefined || S.supplyDemand[g.id] === null) {
        errors.push(`Missing demand for ${g.id}`);
        S.supplyDemand[g.id] = 100;
        fixed.push(`Initialized demand for ${g.id}`);
      } else if (isNaN(S.supplyDemand[g.id])) {
        errors.push(`NaN demand for ${g.id}`);
        S.supplyDemand[g.id] = 100;
        fixed.push(`Fixed NaN demand for ${g.id}`);
      }
      
      // Check price index
      if (S.priceIndex[g.id] === undefined || S.priceIndex[g.id] === null) {
        errors.push(`Missing price index for ${g.id}`);
        S.priceIndex[g.id] = 100;
        fixed.push(`Initialized price index for ${g.id}`);
      } else if (isNaN(S.priceIndex[g.id])) {
        errors.push(`NaN price index for ${g.id}`);
        S.priceIndex[g.id] = 100;
        fixed.push(`Fixed NaN price index for ${g.id}`);
      }
    });
  }
  
  if (errors.length > 0) {
    console.warn('Economy validation found issues:', errors);
  }
  
  if (fixed.length > 0) {
    console.info('Economy validation auto-fixed:', fixed);
  }
  
  return errors.length === 0;
}

// Taxation System
function calculateTaxRevenue() {
  // --- Non‚Äëlinear Taxation System ---
  // Compute base tax revenue from population and territories. In the original
  // game this value scaled linearly with the tax rate, which led to
  // unrealistic gains at high rates. Here we still accumulate a base
  // amount proportional to population and territory population, but will
  // later apply an efficiency curve that plateaus at higher rates.
  let baseTax = S.pop * S.taxationRate * 10;
  S.territories.forEach(tId => {
    const data = S.territoryData[tId];
    if (data && data.population) {
      baseTax += (data.population || 100) * S.taxationRate * 5;
    }
  });

  // Tax efficiency bonuses from buildings (counting houses improve
  // collection). We keep this as a multiplier to base tax.
  let taxBonus = 1.0;
  S.territories.forEach(tId => {
    const data = S.territoryData[tId];
      if (data && data.buildings) {
        // Counting House increases tax efficiency by 5%
        if (data.buildings.includes('counting_house')) {
          taxBonus = Math.max(taxBonus, 1.05);
        }
        // Census Office further boosts tax efficiency by 10%
        if (data.buildings.includes('census_office')) {
          taxBonus = Math.max(taxBonus, 1.10);
        }
      }
  });

  // Apply a logistic efficiency curve to model diminishing returns.
  // At low tax rates (0‚Äì20%) the economy functions efficiently and most
  // revenue is collected. As rates climb above ~20%, productivity
  // declines and tax evasion increases, flattening returns. The curve
  // parameters (20 centre, width 5) were chosen to roughly match
  // historic observations where tax systems collapse beyond 30% rates.
  const effectiveRate = S.taxationRate * 100;
  const efficiency = 1 / (1 + Math.exp((effectiveRate - 20) / 5));

  // Calculate average stability to scale revenue. High stability boosts
  // tax receipts while instability halves them. If no territories are
  // owned the default is neutral (50).
  let avgStability = 50;
  if (S.territories.length > 0) {
    let totalStability = 0;
    S.territories.forEach(tId => {
      const data = S.territoryData[tId];
      totalStability += (data && data.stability) || 50;
    });
    avgStability = totalStability / S.territories.length;
  }
  const stabilityMult = 0.5 + (avgStability / 100);

  // Banking multiplier from owning banks (8% increase) and inflation
  // reduction for long games. These modifiers are calculated in their
  // respective helper functions to centralise logic.
  const bankingMult = getBankingMultiplier();
  const inflationMult = getInflationMultiplier();

  // Combine all modifiers. Note that inflationMultiplier > 1 reduces the
  // effective value of denarii in infinite mode; hence we divide rather
  // than multiply.
  // Apply Publicani tax farming bonus (from technology) as a multiplier
  const taxFarmingMul = (typeof S.taxFarmingBonus === 'number' ? S.taxFarmingBonus : 1.0);
  const total = baseTax * taxBonus * efficiency * stabilityMult * bankingMult * taxFarmingMul;
  const adjusted = total / inflationMult;
  const totalTax = Math.floor(adjusted);
  S.lastTaxRevenue = totalTax;
  return totalTax;
}

// Taxation impact on happiness
function getTaxationHappinessPenalty() {
  // --- Progressive happiness penalty & unrest ---
  // Tax dissatisfaction is no longer a simple linear function. Low tax
  // rates have modest impact on happiness, but pushing beyond certain
  // thresholds angers the populace and increases unrest. Below 15%
  // taxation the penalty is softened; between 15‚Äì25% the penalty rises
  // sharply and unrest accrues; above 25% the penalty escalates steeply
  // and may provoke rebellion.
  const rate = S.taxationRate; // decimal 0‚Äì0.30
  let penalty = 0;
  if (rate <= 0.15) {
    // Up to 15%: modest penalty scaled down
    penalty = rate * 50;
  } else if (rate <= 0.25) {
    // 15‚Äì25%: increasing penalty and unrest accumulation
    penalty = (0.15 * 50) + ((rate - 0.15) * 150);
    S.unrestLevel = Math.min(100, (S.unrestLevel || 0) + 10);
  } else {
    // Above 25%: severe penalty and heavy unrest accumulation
    penalty = (0.15 * 50) + (0.10 * 150) + ((rate - 0.25) * 300);
    S.unrestLevel = Math.min(100, (S.unrestLevel || 0) + 25);
  }
  return Math.floor(penalty);
}

// Apply taxation effects
function applyTaxation() {
  const taxRevenue = calculateTaxRevenue();
  S.denarii += taxRevenue;

  // Apply happiness penalty based on progressive tax rates. The
  // getTaxationHappinessPenalty function updates S.unrestLevel as a
  // side effect when taxes are high.
  const happinessPenalty = getTaxationHappinessPenalty();
  S.happiness = Math.max(0, S.happiness - happinessPenalty);

  // Process potential protests or rebellions triggered by unrest.
  if (typeof processUnrestEvents === 'function') processUnrestEvents();

  return taxRevenue;
}

// Banking income multiplier
function getBankingMultiplier() {
  let mult = 1.0;
  S.territories.forEach(tId => {
    const data = S.territoryData[tId];
    if (data && data.buildings && data.buildings.includes('bank')) {
      mult = Math.max(mult, 1.08);
    }
  });
  return mult;
}

// Inflation system for infinite mode
function getInflationMultiplier() {
  // Base inflation: no inflation in finite mode or early rounds
  let base = 1.0;
  if (S.infiniteMode && S.round > 25) {
    // 0.5% inflation per round after round 25, capped at 3x
    const inflation = 1 + ((S.round - 25) * 0.005);
    base = Math.min(inflation, 3.0);
  }
  // Additional inflation from currency debasement. Each debasement increases this factor by 10%.
  const deb = (typeof S.debasementBonus === 'number' && S.debasementBonus > 0) ? S.debasementBonus : 1.0;
  // Price controls reduce inflation; a value less than 1.0 decreases the multiplier
  const pc = (typeof S.priceControlBonus === 'number' && S.priceControlBonus > 0) ? S.priceControlBonus : 1.0;
  return base * deb * pc;
}

// === Unrest & Rebellion Mechanics ===
// If taxes or other policies drive unrestLevel high, the city may
// experience protests or outright rebellions. This helper runs at
// the end of each taxation cycle to convert unrest into events. It
// reduces unrest when an event triggers, so multiple seasons of high
// taxes are required to build toward a major uprising.
function processUnrestEvents() {
  // Ensure unrestLevel exists
  if (typeof S.unrestLevel !== 'number') S.unrestLevel = 0;
  const unrest = S.unrestLevel;
  // Mild protests if unrest > 40: reduce happiness and productivity
  if (unrest > 40 && Math.random() < unrest / 200) {
    const lossHappiness = Math.floor(3 + Math.random() * 5);
    S.happiness = Math.max(0, S.happiness - lossHappiness);
    // Slight morale drop
    S.morale = Math.max(0, S.morale - 3);
    S.unrestLevel = Math.max(0, unrest - 20);
    alert(`üò† Citizen Protests!\n\nHigh taxes anger the populace.\n-${lossHappiness}% happiness, -3% morale`);
  }
  // Major rebellion if unrest > 75: possible loss of territory or buildings
  if (unrest > 75 && Math.random() < unrest / 100) {
    let msg = 'üî• Rebellion!\n\nOppressed citizens rise against your rule.';
    // Lose random territory (not Palatine) if available
    const available = S.territories.filter(t => t !== 'palatine');
    if (available.length > 0 && Math.random() < 0.4) {
      const index = Math.floor(Math.random() * available.length);
      const lost = available[index];
      // Remove from S.territories and mark as neutral
      S.territories = S.territories.filter(t => t !== lost);
      if (S.territoryData[lost]) S.territoryData[lost].status = 'neutral';
      msg += `\nLost control of ${lost}!`;
    }
    // Destroy random production building
    if (S.productionBuildings.length > 0 && Math.random() < 0.5) {
      const idx = Math.floor(Math.random() * S.productionBuildings.length);
      const destroyed = S.productionBuildings.splice(idx, 1)[0];
      msg += `\nA ${destroyed.type} was destroyed by rioters!`;
    }
    // Loot some gold
    if (Math.random() < 0.6) {
      const loot = Math.floor(S.denarii * 0.1);
      S.denarii = Math.max(0, S.denarii - loot);
      msg += `\n${loot} denarii looted!`;
    }
    // Reduce happiness and morale sharply
    S.happiness = Math.max(0, S.happiness - 15);
    S.morale = Math.max(0, S.morale - 10);
    S.unrestLevel = Math.max(0, unrest - 50);
    alert(msg);
  }
}

// === Ensure quests are initialized and progressed passively ===
function _quest_passive_update(){
  if (typeof initializeQuests === 'function') initializeQuests();
  if (typeof updateQuestProgress === 'function'){
    updateQuestProgress('population');
    updateQuestProgress('troops');
    updateQuestProgress('wealth');
    updateQuestProgress('inventory');
  }
}

// Call once on load
document.addEventListener('DOMContentLoaded', ()=>{ try{ _quest_passive_update(); }catch(e){} });

// Also call at the end of each food/round cycle
(function(){
  const _origProcess = (typeof processFoodCycle === 'function') ? processFoodCycle : null;
  if (_origProcess){
    window.processFoodCycle = function(){
      const res = _origProcess.apply(this, arguments);
      try{ _quest_passive_update(); }catch(e){}
      return res;
    };
  }
})();

// === Apply ongoing procedural perks each round ===
(function(){
  const _origProcess2 = (typeof processFoodCycle === 'function') ? processFoodCycle : null;
  if (_origProcess2){
    window.processFoodCycle = function(){
      // before original: apply continuous growth perks
      if (S.proc_perk_pop_growth){ S.pop += S.proc_perk_pop_growth; }
      const ret = _origProcess2.apply(this, arguments);
      return ret;
    };
  }
})();

function ensureTab(label, focusKey){
  const appRoot = document.getElementById('app') || document.body;
  // Don't create or re-insert tabs while on the intro (first) stage.
  try{
    if (window.S && window.S.stage === 'intro'){
      // If a tab with this focusKey exists, remove it to avoid cycling
      const existingTab = (appRoot.querySelectorAll('.tabs .tab') || []).length ? appRoot.querySelector(`.tabs .tab[data-focus="${focusKey}"]`) : null;
      if (existingTab && existingTab.parentNode) existingTab.parentNode.removeChild(existingTab);
      return null;
    }
  }catch(e){/* noop */}
  let tabs = appRoot.querySelector('.tabs');
  if (!tabs){
    tabs = el('div', {class:'tabs'});
    appRoot.prepend(tabs);
  }
  // If already present, return it
  const exists = Array.from(tabs.querySelectorAll('.tab')).find(b => b.dataset && b.dataset.focus === focusKey);
  if (exists) return exists;
  // Create new tab button
  const btn = el('div', {class:'tab', 'data-focus': focusKey, onClick:()=>{ S.focus = focusKey; render(); }}, label);
  tabs.appendChild(btn);
  return btn;
}

function renderTrackerScreen(root){
    if (!root) root = document.getElementById('app');
    if (!root) return;
    
    root.append(
      el('h2', {}, 'üì¶ Resource Tracker'),
      el('div', {class:'small'}, 'Live view of your stored resources and capacity.')
    );
    
    // Build a simple grid of goods
    const grid = el('div', {class:'grid g3'});
    (GOODS||[]).forEach(g=>{
      const qty = S.inventory[g.id] || 0;
      const price = (S.priceIndex && S.priceIndex[g.id]) ? S.priceIndex[g.id] : 100;
      grid.append(
        el('div', {class:'choice'}, [
          el('div', {class:'pill'}, `${g.emoji} ${g.name}`),
          el('div', {class:'small'}, `Qty: ${qty}`),
          el('div', {class:'tiny'}, `Market index: ${price}`)
        ])
      );
    });
    const cap = el('div', {class:'info'}, `Capacity used: ${Object.values(S.inventory).reduce((a,b)=>a+b,0)} / ${S.capacity}`);
    root.append(grid, cap);
  }

  function renderMilitaryScreen(){
    const appRoot = document.getElementById('app');
    if (!appRoot) return;
    const card = el('div', {class:'card'});
    card.append(
      el('h2', {}, 'üõ°Ô∏è Military Overview'),
      el('div', {class:'grid g3'}, [
        el('div', {class:'choice'}, [el('div', {class:'pill'}, 'üë• Troops'), el('div', {class:'small'}, `${S.troops}`)]),
        el('div', {class:'choice'}, [el('div', {class:'pill'}, '‚öîÔ∏è Morale'), el('div', {class:'small'}, `${S.morale}`)]),
        el('div', {class:'choice'}, [el('div', {class:'pill'}, 'üì¶ Supplies'), el('div', {class:'small'}, `${S.supplies}`)]),
        el('div', {class:'choice'}, [el('div', {class:'pill'}, 'üè∞ Forts'), el('div', {class:'small'}, `${S.forts}`)]),
        el('div', {class:'choice'}, [el('div', {class:'pill'}, 'üèÖ Win Streak'), el('div', {class:'small'}, `${S.currentWinStreak||0}`)]),
        el('div', {class:'choice'}, [el('div', {class:'pill'}, 'üéñÔ∏è Victories'), el('div', {class:'small'}, `${S.victories||0}`)]),
      ])
    );
    if (S.nextRaidRound !== undefined && S.round !== undefined){
      const till = Math.max(0, (S.nextRaidRound||0) - (S.round||0));
      card.append(el('div', {class:'info'}, `Next raid in ~${till} round(s).`));
    }
    appRoot.appendChild(card);
  }

  // Tracker and Military tabs are now part of main navigation
  // No need for separate injection


// Save/Load system
function saveGame() {
  try {
    const saveData = JSON.stringify(S);
    localStorage.setItem('founding_of_rome_save', saveData);
    alert('‚úÖ Game saved successfully!');
  } catch (e) {
    alert('‚ùå Failed to save game: ' + e.message);
  }
}

function loadGame() {
  try {
    const saveData = localStorage.getItem('founding_of_rome_save');
    if (!saveData) {
      alert('‚ùå No saved game found!');
      return false;
    }
    const loaded = JSON.parse(saveData);
    Object.assign(S, loaded);
    alert('‚úÖ Game loaded successfully!');
    render();
    return true;
  } catch (e) {
    alert('‚ùå Failed to load game: ' + e.message);
    return false;
  }
}

function deleteSave() {
  if (confirm('Are you sure you want to delete your saved game?')) {
    localStorage.removeItem('founding_of_rome_save');
    alert('üóëÔ∏è Save deleted!');
  }
}

/* ==================== NEW FEATURES - ACHIEVEMENTS ==================== */
function checkAchievements() {
  ACHIEVEMENTS.forEach(achievement => {
    if (!S.achievements.includes(achievement.id) && achievement.check(S)) {
      unlockAchievement(achievement);
    }
  });
}

function unlockAchievement(achievement) {
  S.achievements.push(achievement.id);
  showAchievementNotification(achievement);
  
  // Apply rewards
  if (achievement.reward.denarii) {
    S.denarii += achievement.reward.denarii;
    S.totalIncomeEarned += achievement.reward.denarii;
  }
  if (achievement.reward.favor) S.favor += achievement.reward.favor;
  if (achievement.reward.reputation) S.reputation += achievement.reward.reputation;
  if (achievement.reward.happiness) S.happiness = Math.min(100, S.happiness + achievement.reward.happiness);
  if (achievement.reward.morale) S.morale = Math.min(100, S.morale + achievement.reward.morale);
  if (achievement.reward.housing) S.housing += achievement.reward.housing;
  if (achievement.reward.capacity) S.capacity += achievement.reward.capacity;
  if (achievement.reward.supplies) S.supplies += achievement.reward.supplies;
}

function showAchievementNotification(achievement) {
  const notification = el('div', {class:'achievement-notification'});
  notification.append(
    el('div', {class:'achievement-icon'}, achievement.icon),
    el('div', {class:'achievement-title'}, 'üèÜ Achievement Unlocked!'),
    el('div', {class:'achievement-title'}, achievement.name),
    el('div', {class:'achievement-desc'}, achievement.desc),
    el('div', {class:'achievement-reward'}, 
      'Reward: ' + Object.entries(achievement.reward).map(([k,v])=>`+${v} ${k}`).join(', '))
  );
  
  document.body.appendChild(notification);
  setTimeout(() => {
    if (notification.parentNode) notification.parentNode.removeChild(notification);
  }, 5000);
}

/* ==================== NEW FEATURES - QUEST SYSTEM ==================== */
function initializeQuests() {
  if (S.activeQuests.length < 2) {
    const available = QUEST_TEMPLATES.filter(q => 
      !S.activeQuests.find(aq => aq.id === q.id)
    );
    if (available.length > 0) {
      const newQuest = rpick(available);
      S.activeQuests.push({
        id: newQuest.id,
        progress: 0,
        target: newQuest.count || newQuest.target,
        template: newQuest
      });
    }
  }
}

function updateQuestProgress(type, amount = 1) {
  S.activeQuests.forEach(quest => {
    const template = quest.template;
    if (template.type === type) {
      if (type === 'building' && template.target) {
        // Count specific building types
        const count = S.productionBuildings.filter(b => b.type === template.target).length;
        quest.progress = count;
      } else if (type === 'population' || type === 'troops' || type === 'wealth' || type === 'inventory') {
        // Direct value checks
        if (type === 'population') quest.progress = S.pop;
        if (type === 'troops') quest.progress = S.troops;
        if (type === 'wealth') quest.progress = S.denarii;
        if (type === 'inventory') {
          quest.progress = Object.values(S.inventory).reduce((sum, qty) => sum + qty, 0);
        }
      } else {
        // Count-based quests
        quest.progress += amount;
      }
      
      // Check completion
      if (quest.progress >= quest.target) {
        completeQuest(quest);
      }
    }
  });
}

function completeQuest(quest) {
  const template = quest.template;
  
  // Apply rewards
  if (template.reward.denarii) {
    S.denarii += template.reward.denarii;
    S.totalIncomeEarned += template.reward.denarii;
  }
  if (template.reward.troops) S.troops += template.reward.troops;
  if (template.reward.favor) S.favor += template.reward.favor;
  if (template.reward.reputation) S.reputation += template.reward.reputation;
  if (template.reward.housing) S.housing += template.reward.housing;
  if (template.reward.happiness) S.happiness = Math.min(100, S.happiness + template.reward.happiness);
  if (template.reward.capacity) S.capacity += template.reward.capacity;
  if (template.reward.tradeBuff) {
    S.questTradeBuff = template.reward.tradeBuff;
    S.questTradeBuffDuration = template.reward.duration || 5;
  }
  
  alert(`üìú QUEST COMPLETE!\n\n${template.icon} ${template.name}\n\nReward: ${Object.entries(template.reward).map(([k,v])=>`+${v} ${k}`).join(', ')}`);
  
  // Remove from active quests
  S.activeQuests = S.activeQuests.filter(q => q.id !== quest.id);
  
  // Try to add a new quest
  initializeQuests();
}

/* ==================== NEW FEATURES - ADVISOR SYSTEM ==================== */
function updateAdvisor() {
  if (S.advisorDismissed) return;
  
  let message = '';
  
  // Priority warnings
  if (S.food < S.pop * 0.5) {
    message = 'üåæ Your food stores are critically low! Build farms or trade for grain.';
  } else if (S.denarii < 500 && S.lastUpkeep > S.lastTaxes) {
    message = 'üí∞ You\'re losing money each turn. Reduce troops or build production.';
  } else if (S.morale < 40) {
    message = '‚öîÔ∏è Morale is poor. Win battles or recruit more troops to boost it.';
  } else if (S.happiness < 40) {
    message = 'üò¢ Happiness is low. Build housing, improve sanitation, or host feasts.';
  } else if (S.pop > S.housing) {
    message = 'üè† Overcrowding! Build more housing to keep citizens happy.';
  } else if (S.inventoryFull) {
    message = 'üì¶ Inventory nearly full! Trade goods before production is wasted.';
  } else if (S.raidWarning) {
    message = '‚öîÔ∏è Enemy scouts spotted! A raid is coming. Prepare your defenses!';
  }
  
  // Helpful tips (lower priority)
  else if (S.round > 5 && S.productionBuildings.length === 0) {
    message = 'üèóÔ∏è Consider building production facilities for passive income.';
  } else if (S.territories.length > 3 && !S.techs.roads) {
    message = 'üõ£Ô∏è Research Stone Roads to reduce trade risk and increase capacity.';
  } else if (S.denarii > 3000 && S.territories.length < 5) {
    message = 'üó∫Ô∏è You have wealth to spare. Consider expanding your territory!';
  }
  
  if (message && message !== S.lastAdvisorMessage) {
    S.lastAdvisorMessage = message;
    showAdvisor(message);
  }
}

function showAdvisor(message) {
  // Remove existing advisor
  const existing = document.querySelector('.advisor');
  if (existing) existing.remove();
  
  const advisor = el('div', {class:'advisor'});
  advisor.append(
    el('div', {class:'advisor-header'},
      el('div', {class:'advisor-title'}, 'üßô Advisor'),
      el('div', {class:'advisor-close', onClick:dismissAdvisor}, '√ó')
    ),
    el('div', {class:'advisor-text'}, message)
  );
  
  document.body.appendChild(advisor);
}

function dismissAdvisor() {
  S.advisorDismissed = true;
  const advisor = document.querySelector('.advisor');
  if (advisor) advisor.remove();
}

/* ==================== NEW FEATURE - INTRO TUTORIAL ==================== */
// Present a short series of pop‚Äëups to orient new players to the core mechanics. The
// tutorial runs only once per game (as tracked by S.tutorialSeen). Each step
// displays a message and a button to proceed. No elements are modified directly,
// but the content points out important interface locations.
function startTutorial() {
  const steps = [
    { text: 'Welcome to <em>Founding of Rome</em>! Each season you‚Äôll guide your people by building, trading, and surviving. Let‚Äôs begin!' },
    { text: 'This is your Economy tab ‚Äî build farms and pastures to produce food and income. Watch your inventory and upkeep closely.' },
    { text: 'When you‚Äôre ready, click <strong>Simulate Season</strong> to advance time and see your city grow. Monitor food, happiness and denarii!' }
  ];
  showTutorialStep(0, steps);
}

function showTutorialStep(i, steps) {
  const step = steps[i];
  // Create overlay box
  const box = document.createElement('div');
  box.className = 'tutorialPopup';
  const p = document.createElement('p');
  p.innerHTML = step.text;
  const button = document.createElement('button');
  button.textContent = i < steps.length - 1 ? 'Next' : 'Finish';
  button.addEventListener('click', () => {
    box.remove();
    if (i < steps.length - 1) {
      showTutorialStep(i + 1, steps);
    } else {
      // Mark tutorial complete
      S.tutorialSeen = true;
      // Persist the tutorial flag silently. We avoid using saveGame() because it
      // displays an alert. Instead, write directly to localStorage so the
      // tutorial will not repeat on future visits. Errors are ignored.
      try {
        // Remember that the tutorial has been completed on this device
        localStorage.setItem('founding_of_rome_tutorial_seen', '1');
      } catch (e) {
        // silently ignore storage errors
      }
    }
  });
  box.appendChild(p);
  box.appendChild(button);
  document.body.appendChild(box);
}

/* ==================== NEW FEATURES - RESOURCE COMBINATIONS ==================== */
function canAffordCombo(combo) {
  for (const [resource, amount] of Object.entries(combo.cost)) {
    if ((S.inventory[resource] || 0) < amount) return false;
  }
  return true;
}

function useResourceCombo(combo) {
  if (!canAffordCombo(combo)) return false;
  
  // Deduct resources
  for (const [resource, amount] of Object.entries(combo.cost)) {
    S.inventory[resource] -= amount;
  }
  
  // Apply effects
  if (combo.effect.attackBonus) {
    S.comboAttackBonus = combo.effect.attackBonus;
    S.comboAttackDuration = combo.effect.duration || 1;
  }
  if (combo.effect.happiness) {
    S.happiness = Math.min(100, S.happiness + combo.effect.happiness);
  }
  if (combo.effect.reputation) {
    S.reputation += combo.effect.reputation;
  }
  if (combo.effect.defense) {
    S.comboDefenseBonus = (S.comboDefenseBonus || 0) + combo.effect.defense;
  }
  if (combo.effect.tradeBuff) {
    S.comboTradeBuff = combo.effect.tradeBuff;
    S.comboTradeDuration = combo.effect.duration || 1;
  }
  if (combo.effect.morale) {
    S.morale = Math.min(100, S.morale + combo.effect.morale);
  }
  
  alert(`‚ú® ${combo.icon} ${combo.name}\n\n${combo.desc}`);
  return true;
}

/* ==================== NEW FEATURES - BUILDING UPGRADES ==================== */
function getBuildingLevel(buildingId) {
  const building = S.productionBuildings.find(b => b.id === buildingId);
  return building ? (building.level || 1) : 0;
}

function upgradeBuilding(buildingInstance) {
  const currentLevel = buildingInstance.level || 1;
  if (currentLevel >= 3) return false;
  
  const baseCost = PRODUCTION_BUILDINGS.find(b => b.id === buildingInstance.type).cost;
  const upgradeCost = Math.floor(baseCost * (currentLevel + 1) * 0.8);
  
  if (S.denarii < upgradeCost) return false;
  
  S.denarii -= upgradeCost;
  S.totalSpentOnBuildings += upgradeCost;
  buildingInstance.level = currentLevel + 1;
  
  return true;
}

/* ==================== NEW FEATURES - CITY RELATIONSHIPS ==================== */
function adjustCityRelation(cityId, amount) {
  S.cityRelations[cityId] = (S.cityRelations[cityId] || 0) + amount;
  S.cityRelations[cityId] = clamp(S.cityRelations[cityId], -20, 20);
}

function getCityRelationMultiplier(cityId) {
  const relation = S.cityRelations[cityId] || 0;
  if (relation > 10) return 0.8; // 20% discount on tariffs
  if (relation < -5) return 1.2; // 20% penalty
  return 1.0;
}

/* ==================== NEW FEATURES - TERRITORY SPECIALIZATION ==================== */
function specializeTerritory(territoryId, specializationType) {
  const spec = SPECIALIZATIONS.find(s => s.id === specializationType);
  if (!spec || S.denarii < spec.cost) return false;
  
  S.denarii -= spec.cost;
  S.territorySpecializations[territoryId] = specializationType;
  
  // Apply immediate effects
  if (spec.effect.fortBonus) S.forts += spec.effect.fortBonus;
  if (spec.effect.reputation) S.reputation += spec.effect.reputation;
  
  alert(`‚ú® Territory Specialized!\n\n${spec.icon} ${spec.name}\n${spec.desc}`);
  return true;
}

/* ==================== NEW FEATURES - EMERGENCY ACTIONS ==================== */
function canUseEmergencyAction(actionId) {
  const lastUsed = S.emergencyActionsUsed[actionId] || 0;
  const action = EMERGENCY_ACTIONS.find(a => a.id === actionId);
  return (S.round - lastUsed) >= action.cooldown;
}

function useEmergencyAction(actionId) {
  const action = EMERGENCY_ACTIONS.find(a => a.id === actionId);
  if (!action || !canUseEmergencyAction(actionId)) return false;
  
  // Check favor cost
  if (action.cost && S.favor < action.cost) return false;
  
  if (action.cost) S.favor -= action.cost;
  
  // Apply effects
  if (action.effect.denarii) S.denarii += action.effect.denarii;
  if (action.effect.happiness) S.happiness = Math.max(0, S.happiness + action.effect.happiness);
  if (action.effect.troops) S.troops += action.effect.troops;
  if (action.effect.pop) S.pop = Math.max(20, S.pop + action.effect.pop);
  if (action.effect.favor) S.favor += action.effect.favor;
  
  if (action.effect.territory && S.territories.length > 1) {
    // Remove a random territory (not Palatine)
    const removable = S.territories.filter(t => t !== 'palatine');
    if (removable.length > 0) {
      const removed = rpick(removable);
      S.territories = S.territories.filter(t => t !== removed);
      const territory = TERRITORIES.find(t => t.id === removed);
      if (territory) territory.status = 'hostile';
    }
  }
  
  S.emergencyActionsUsed[actionId] = S.round;
  alert(`üö® ${action.icon} ${action.name}\n\n${action.desc}`);
  return true;
}

/* ==================== NEW FEATURES - SEASONAL EFFECTS ==================== */
function getSeasonalEffects() {
  const season = SEASONS[S.seasonIndex];
  return season.effect;
}

function advanceSeason() {
  S.seasonIndex = (S.seasonIndex + 1) % SEASONS.length;
  S.season = SEASONS[S.seasonIndex].name.toLowerCase();
}

function countRarities() {
  const counts = {
    Imperial: 0,
    Legendary: 0,
    Epic: 0,
    Rare: 0,
    Uncommon: 0,
    Common: 0
  };
  
  // Count territories
  S.territories.forEach(tId => {
    const territory = TERRITORIES.find(t => t.id === tId);
    if (territory && territory.rarity) {
      counts[territory.rarity.name]++;
    }
  });
  
  // Count production buildings
  S.productionBuildings.forEach(b => {
    const building = PRODUCTION_BUILDINGS.find(pb => pb.id === b.type);
    if (building && building.rarity) {
      counts[building.rarity.name]++;
    }
  });
  
  return counts;
}

function exportStats() {
  const rarities = countRarities();
  const totalItems = Object.values(rarities).reduce((a, b) => a + b, 0);
  
  const territoryList = S.territories.map((tId, i) => {
    const t = TERRITORIES.find(x => x.id === tId);
    const rarityText = t && t.rarity ? ` [${t.rarity.name}]` : '';
    const latinText = t && t.latinName ? ` (${t.latinName})` : '';
    return `${i + 1}. ${t ? t.name : tId}${latinText}${rarityText}`;
  }).join('\n');
  
  const buildingList = S.productionBuildings.map((b, i) => {
    const building = PRODUCTION_BUILDINGS.find(pb => pb.id === b.type);
    const rarityText = building && building.rarity ? ` [${building.rarity.name}]` : '';
    const latinText = building && building.latinName ? ` (${building.latinName})` : '';
    return `${i + 1}. ${building ? building.name : b.type}${latinText}${rarityText}`;
  }).join('\n');
  
  const techList = TECHNOLOGIES.filter(t => S.techs[t.id]).map(t => `‚úì ${t.name}`).join('\n');
  
  const imperialStars = rarities.Imperial > 0 ? Array(rarities.Imperial).fill('üåü').join('') : '';
  const imperialBonus = rarities.Imperial > 0 ? '\nüéâ INCREDIBLE! You found ' + rarities.Imperial + ' IMPERIAL item(s)! üéâ\n' : '';
  
  const stats = `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          üèõÔ∏è FOUNDING OF ROME - RUN SUMMARY üèõÔ∏è
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üëë FOUNDER: ${S.name} (${S.founder})
üìÖ FINAL SEASON: ${S.round}
${S.infiniteMode ? '‚ôæÔ∏è MODE: INFINITE' : 'üèÅ MODE: STANDARD (25 SEASONS)'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        üí∞ ECONOMY
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Denarii: ${fmt(S.denarii)}
Reputation: ${S.reputation}
Favor: ${S.favor}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        ‚öîÔ∏è MILITARY
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Troops: ${S.troops}
Morale: ${Math.round(S.morale)}%
Victories: ${S.victories}
Forts: ${S.forts}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                       üèòÔ∏è SETTLEMENT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Population: ${S.pop}
Housing: ${S.housing}
Happiness: ${Math.round(S.happiness)}%
Sanitation: ${Math.round(S.sanitation)}%
Food Stores: ${Math.floor(S.food)}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                      üó∫Ô∏è TERRITORIES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Territories Controlled: ${S.territories.length}
${territoryList}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    üè≠ PRODUCTION BUILDINGS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Total Buildings: ${S.productionBuildings.length}
${buildingList}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                     ‚ú® RARITY BREAKDOWN
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Total Items Found: ${totalItems}

üî¥ Imperial (0.05%):    ${rarities.Imperial} ${imperialStars}
üü† Legendary (0.5%):    ${rarities.Legendary}
üü£ Epic (2.5%):         ${rarities.Epic}
üîµ Rare (5%):           ${rarities.Rare}
üü¢ Uncommon (12%):      ${rarities.Uncommon}
‚ö™ Common (80%):        ${rarities.Common}
${imperialBonus}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                      üìä TECHNOLOGIES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Researched: ${Object.values(S.techs).filter(Boolean).length}/${TECHNOLOGIES.length}
${techList}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        üéØ FINAL SCORE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Economic Power:   ${Math.floor(S.denarii / 100)}
Military Power:   ${S.troops + S.victories * 10}
Cultural Power:   ${Math.floor(S.pop / 2 + S.happiness)}
Imperial Power:   ${S.territories.length * 50}
                  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
TOTAL SCORE:      ${Math.floor(S.denarii / 100) + S.troops + S.victories * 10 + Math.floor(S.pop / 2 + S.happiness) + S.territories.length * 50}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Generated: ${new Date().toLocaleString()}
Game: Founding of Rome - Complete Edition
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
`;
  
  // Create download
  const blob = new Blob([stats], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `rome_run_season${S.round}_${Date.now()}.txt`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  alert('üìä Stats exported! Check your downloads folder.');
}

// Raid system
function checkForRaid() {
  if (S.round >= S.nextRaidRound && !S.raidsPending) {
    S.raidsPending = true;
    S.nextRaidRound = S.round + 5;
    return true;
  }
  return false;
}

function calculateRaidStrength() {
  // --- Adaptive Enemy AI & Raid Strength ---
  // Base strength scales with time
  const baseStrength = 30 + (S.round * 2);
  const territoryBonus = S.territories.length * 3;
  const wealthBonus = Math.floor(S.denarii / 500);

  // Adapt scaling to the player's military prowess. As you amass more
  // troops or attack bonuses, the enemy responds with larger forces.
  let adaptive = 1 + Math.min(S.troops / 500, 1);
  if (S.mods && S.mods.attackBonus) adaptive += S.mods.attackBonus;
  if (S.techs && S.techs.legion) adaptive += 0.1;
  if (S.techs && S.techs.forge) adaptive += 0.05;

  // Infinite mode and late game still amplify difficulty.
  const infiniteMultiplier = S.infiniteMode ? 1.3 : 1.0;
  const lateGameMultiplier = S.round > 25 ? 1.0 + ((S.round - 25) * 0.002) : 1.0;

  // Occasional invasion wave adds unpredictability: 5% chance of 1.5x size.
  const invasionWave = Math.random() < 0.05 ? 1.5 : 1.0;

  const totalStrength = Math.floor((baseStrength + territoryBonus + wealthBonus) * adaptive * infiniteMultiplier * lateGameMultiplier * invasionWave);
  return totalStrength;
}

function calculateBattleOdds() {
  // --- Battle Odds with Supplies, Technology & Weather ---
  let ourStrength = S.troops * (S.morale / 100);
  let enemyStrength = calculateRaidStrength();

  // Scale our strength by supplies: abundant supplies (>=100) grant
  // proportional bonuses, while shortages (<100) reduce effective
  // strength. Supplies above troops*0.5 grant a 20% boost in conquest,
  // so here we normalise by 100.
  const supplies = typeof S.supplies === 'number' ? S.supplies : 0;
  if (supplies >= 100) {
    ourStrength *= 1 + ((supplies - 100) / 100);
  } else if (supplies > 0) {
    ourStrength *= supplies / 100;
  }

  // Attack and technology bonuses also affect raid defence, not just
  // conquests. Use additive attackBonus and multiplicative tech buffs.
  if (S.mods && S.mods.attackBonus) ourStrength += S.mods.attackBonus;
  if (S.techs && S.techs.legion) ourStrength *= 1.2;
  if (S.techs && S.techs.forge) ourStrength *= 1.1;

  // Apply random weather/terrain factor: symmetrical modifiers ensure
  // neither side is unfairly advantaged but introduce unpredictability.
  const weather = 0.9 + Math.random() * 0.2; // 0.9‚Äì1.1
  ourStrength *= weather;
  enemyStrength *= (2 - weather); // 0.9‚Äì1.1 inverted

  // Final clamping and conversion to integers
  ourStrength = Math.max(0, Math.floor(ourStrength));
  enemyStrength = Math.max(0, Math.floor(enemyStrength));

  const strengthRatio = ourStrength / (ourStrength + enemyStrength);
  const winChance = Math.floor(clamp(strengthRatio * 100, 10, 95));

  return {
    ourStrength,
    enemyStrength,
    winChance
  };
}

function executeBattle() {
  const odds = calculateBattleOdds();
  const roll = Math.random() * 100;
  const victory = roll < odds.winChance;
  
  const baseCasualties = Math.floor(5 + Math.random() * 15);
  const casualties = victory ? baseCasualties : Math.floor(baseCasualties * 1.5);
  
  S.troops = Math.max(0, S.troops - casualties);
  
  if (victory) {
    const goldReward = Math.floor(150 + (S.round * 10) + Math.random() * 200);
    S.denarii += goldReward;
    S.reputation += 5;
    S.favor += 3;
    S.morale = Math.min(100, S.morale + 8);
    S.victories++;
    
    // Divine blessings on victory - NEW!
    if (S.patronGod) {
      const god = ROMAN_GODS.find(g => g.id === S.patronGod);
      const godFavor = S.godFavor[S.patronGod] || 0;
      
      // Jupiter bonus (military victories)
      if (god.id === 'jupiter' && godFavor >= 25) {
        S.godFavor[S.patronGod] = Math.min(100, godFavor + 3);
        S.piety = Math.min(S.maxPiety, S.piety + 5);
      }
      
      // Mars bonus (war god)
      if (god.id === 'mars' && godFavor >= 25) {
        S.morale = Math.min(100, S.morale + 5);
        S.godFavor[S.patronGod] = Math.min(100, godFavor + 5);
      }
    }
    
    setTimeout(() => {
      alert(`‚öîÔ∏è VICTORY!\n\nüí∞ Plunder: +${fmt(goldReward)} denarii\nüíÄ Casualties: ${casualties} troops\nüéñÔ∏è +5 reputation, +3 favor\n\nYour legions prevail!`);
      S.battleActive = false;
      S.raidsPending = false;
      render();
    }, 100);
  } else {
    // Defeat consequences: morale and happiness drop, population loss
    S.morale = Math.max(0, S.morale - 20);
    S.happiness = Math.max(0, S.happiness - 15);
    const popLoss = Math.floor(10 + Math.random() * 20);
    S.pop = Math.max(20, S.pop - popLoss);

    // Additional consequences such as territory loss or looting
    let extraMsg = '';
    if (typeof applyDefeatConsequences === 'function') {
      extraMsg = applyDefeatConsequences();
    }

    setTimeout(() => {
      alert(`üíÄ DEFEAT!\n\nüíÄ Casualties: ${casualties} troops\nüò¢ Population: -${popLoss}\nüìâ Morale: -20%, Happiness: -15%${extraMsg ? '\n' + extraMsg : ''}\n\nRegroup and rebuild!`);
      S.battleActive = false;
      S.raidsPending = false;
      render();
    }, 100);
  }
}

// === Defeat Consequence Handler ===
// When the player loses a raid, additional punishment beyond the
// standard morale/happiness/population losses makes defence more
// meaningful. This helper returns a message summarising extra losses.
function applyDefeatConsequences() {
  let msg = '';
  // Chance to lose a territory (except the starting Palatine) if more
  // than one is owned. This loss represents enemy raiders seizing
  // control of an outlying region.
  const available = S.territories.filter(t => t !== 'palatine');
  if (available.length > 0 && Math.random() < 0.2) {
    const idx = Math.floor(Math.random() * available.length);
    const lost = available[idx];
    S.territories = S.territories.filter(t => t !== lost);
    if (S.territoryData[lost]) S.territoryData[lost].status = 'neutral';
    msg += `\nüè≥Ô∏è Territory lost: ${lost}`;
  }
  // Chance to destroy a random production building
  if (S.productionBuildings && S.productionBuildings.length > 0 && Math.random() < 0.25) {
    const idx2 = Math.floor(Math.random() * S.productionBuildings.length);
    const destroyed = S.productionBuildings.splice(idx2, 1)[0];
    msg += `\nüèöÔ∏è Building destroyed: ${destroyed.type}`;
  }
  // Loot some gold and goods
  if (Math.random() < 0.3) {
    const stolenGold = Math.floor(S.denarii * 0.1);
    S.denarii = Math.max(0, S.denarii - stolenGold);
    msg += `\nüí∞ Raiders plundered ${stolenGold} denarii`;
  }
  if (Math.random() < 0.3) {
    // Reduce each inventory good by up to 20%
    for (const key in S.inventory) {
      const amt = S.inventory[key];
      if (amt > 0) {
        const stolen = Math.floor(amt * 0.2);
        S.inventory[key] = Math.max(0, amt - stolen);
      }
    }
    msg += `\nüì¶ Goods have been stolen`;
  }
  return msg;
}

function renderBattleScreen() {
  const odds = calculateBattleOdds();
  const enemyName = `Raiding ${['Bandits', 'Barbarians', 'Marauders', 'Invaders', 'Raiders'][Math.floor(Math.random() * 5)]}`;
  
  const battleScreen = el('div', {class:'battle-screen'});
  const battleCard = el('div', {class:'battle-card'});
  
  const winChanceClass = odds.winChance >= 70 ? 'win-high' : odds.winChance >= 40 ? 'win-medium' : 'win-low';
  
  battleCard.append(
    el('h2', {style:'text-align:center;color:var(--roman-red);margin:0 0 16px 0'}, '‚öîÔ∏è ENEMY RAID!'),
    el('div', {class:'info', style:'background:#fef2f2;border-color:#fca5a5'},
      `${enemyName} attack your borders! Defend Rome!`
    ),
    
    el('div', {class:'battle-animation'},
      el('div', {class:'battle-unit unit-left'}, 'üõ°Ô∏è'),
      el('div', {class:'battle-unit unit-right'}, '‚öîÔ∏è'),
      el('div', {class:'battle-effects'},
        el('div', {class:'battle-spark'}, 'üí•')
      )
    ),
    
    el('div', {class:'grid g2', style:'margin:16px 0'},
      el('div', {},
        el('h3', {style:'margin:4px 0;text-align:center'}, 'üõ°Ô∏è Your Forces'),
        el('div', {class:'small', style:'text-align:center'}, `Troops: ${S.troops}`),
        el('div', {class:'small', style:'text-align:center'}, `Morale: ${Math.round(S.morale)}%`),
        el('div', {class:'small', style:'text-align:center;font-weight:700;color:#16a34a'}, `Strength: ${odds.ourStrength}`)
      ),
      el('div', {},
        el('h3', {style:'margin:4px 0;text-align:center'}, '‚öîÔ∏è Enemy Forces'),
        el('div', {class:'small', style:'text-align:center'}, `${enemyName}`),
        el('div', {class:'small', style:'text-align:center'}, `Season ${S.round}`),
        el('div', {class:'small', style:'text-align:center;font-weight:700;color:#dc2626'}, `Strength: ${odds.enemyStrength}`)
      )
    ),
    
    el('div', {class:`win-chance ${winChanceClass}`},
      `Victory Chance: ${odds.winChance}%`
    ),
    
    el('div', {class:'info', style:'font-size:12px'},
      `‚ö†Ô∏è Victory: Gain gold and reputation\nüíÄ Defeat: Lose troops and population`
    ),
    
    el('div', {style:'display:flex;gap:12px;margin-top:16px'},
      el('button', {
        class:'btn btn-primary',
        style:'flex:1',
        onClick: executeBattle
      }, '‚öîÔ∏è FIGHT!'),
      el('button', {
        class:'btn',
        style:'flex:1',
        onClick: () => {
          if (confirm('Retreat? You will lose 20% of your troops and all morale!')) {
            const losses = Math.floor(S.troops * 0.2);
            S.troops = Math.max(0, S.troops - losses);
            S.morale = Math.max(0, S.morale - 30);
            S.happiness = Math.max(0, S.happiness - 20);
            alert(`Retreat! Lost ${losses} troops deserting. -30% morale, -20% happiness.`);
            S.battleActive = false;
            S.raidsPending = false;
            render();
          }
        }
      }, 'üèÉ Retreat')
    )
  );
  
  battleScreen.append(battleCard);
  app.textContent = '';
  app.append(battleScreen);
}

/* ==================== PRODUCTION & TERRITORY MECHANICS ==================== */

function produceResources() {
  const seasonalEffects = getSeasonalEffects();
  
  // Produce from buildings
  S.productionBuildings.forEach(b => {
    const building = PRODUCTION_BUILDINGS.find(pb => pb.id === b.type);
    if (building) {
      let rate = building.rate;
      
      // Apply building level (1x, 1.5x, 2x)
      const level = b.level || 1;
      rate = Math.floor(rate * (1 + (level - 1) * 0.5));
      
      // Apply rarity bonus!
      if (building.rarity) {
        rate = Math.floor(rate * building.rarity.bonus);
      }
      
      // Tech bonuses
      if (building.produces === 'grain' && S.techs.irrigation) rate = Math.floor(rate * 1.5);
      if (building.produces === 'iron' && S.techs.mining) rate *= 2;
      
      // Event bonuses
      if ((building.produces === 'grain' || building.produces === 'livestock') && S.eventModifiers.farmBonus) {
        rate = Math.floor(rate * S.eventModifiers.farmBonus);
      }
      if (building.produces === 'livestock' && S.eventModifiers.livestockBonus) {
        rate = Math.floor(rate * S.eventModifiers.livestockBonus);
      }
      if (building.produces === 'iron' && S.eventModifiers.ironBonus) {
        rate = Math.floor(rate * S.eventModifiers.ironBonus);
      }
      if (S.eventModifiers.productionBuff) {
        rate = Math.floor(rate * S.eventModifiers.productionBuff);
      }
      
      // Seasonal effects
      // Apply farm bonus to grain and livestock
      if ((building.produces === 'grain' || building.produces === 'livestock') && seasonalEffects.farmBonus) {
        rate = Math.floor(rate * seasonalEffects.farmBonus);
      }
      // Apply fish bonus to fisheries (salt production).  This models good
      // conditions for fishing in summer and rough seas in winter.
      if (building.produces === 'salt' && seasonalEffects.fishBonus) {
        rate = Math.floor(rate * seasonalEffects.fishBonus);
      }
      
      // Founder bonuses
      if (S.mods && S.mods.productionBonus) rate = Math.floor(rate * S.mods.productionBonus);
      
      // Track production for achievements
      S.resourcesProduced[building.produces] = (S.resourcesProduced[building.produces] || 0) + rate;
      
      // Add to inventory with capacity check
      const current = S.inventory[building.produces] || 0;
      const totalResources = Object.values(S.inventory).reduce((sum, qty) => sum + qty, 0);
      
      if (totalResources + rate <= S.capacity) {
        S.inventory[building.produces] = current + rate;
      } else {
        const space = Math.max(0, S.capacity - totalResources);
        S.inventory[building.produces] = current + space;
        // Track wasted production for warning
        if (!S.wastedProduction) S.wastedProduction = {};
        S.wastedProduction[building.produces] = (S.wastedProduction[building.produces] || 0) + (rate - space);
      }
    }
  });
  
  // Show warning if production was wasted
  if (S.wastedProduction && Object.keys(S.wastedProduction).length > 0) {
    const wasted = Object.entries(S.wastedProduction)
      .map(([res, amt]) => `${res}: ${amt}`)
      .join(', ');
    S.lastProductionWarning = `‚ö†Ô∏è Production wasted due to full inventory: ${wasted}. Sell goods or build warehouses!`;
  } else {
    S.lastProductionWarning = null;
  }
  
  // Reset wasted production tracker
  S.wastedProduction = {};
  
  // Produce from territories
  S.territories.forEach(tId => {
    const territory = TERRITORIES.find(t => t.id === tId);
    if (!territory || !territory.produces || territory.status !== 'owned') return; // Skip if invalid
    
    Object.entries(territory.produces).forEach(([resource, amount]) => {
        let prodAmount = amount;
        
        // Apply rarity bonus!
        if (territory.rarity) {
          prodAmount = Math.floor(prodAmount * territory.rarity.bonus);
        }
        
        // Territory specialization bonuses
        const spec = S.territorySpecializations[tId];
        if (spec === 'farm' && (resource === 'grain' || resource === 'livestock')) {
          prodAmount = Math.floor(prodAmount * 1.5);
        }
        if (spec === 'mine' && (resource === 'iron' || resource === 'clay' || resource === 'salt')) {
          prodAmount = Math.floor(prodAmount * 1.5);
        }
        
        // Event bonuses
        if ((resource === 'grain' || resource === 'livestock') && S.eventModifiers.farmBonus) {
          prodAmount = Math.floor(prodAmount * S.eventModifiers.farmBonus);
        }
        
        // Seasonal effects
        if ((resource === 'grain' || resource === 'livestock') && seasonalEffects.farmBonus) {
          prodAmount = Math.floor(prodAmount * seasonalEffects.farmBonus);
        }
        
        // Founder bonuses
        if (S.mods && S.mods.territoryBonus) {
          prodAmount = Math.floor(prodAmount * S.mods.territoryBonus);
        }
        
        // Track production for achievements
        S.resourcesProduced[resource] = (S.resourcesProduced[resource] || 0) + prodAmount;
        
        // Add to inventory with capacity check
        const current = S.inventory[resource] || 0;
        const totalResources = Object.values(S.inventory).reduce((sum, qty) => sum + qty, 0);
        
        if (totalResources + prodAmount <= S.capacity) {
          S.inventory[resource] = current + prodAmount;
        } else {
          const space = Math.max(0, S.capacity - totalResources);
          S.inventory[resource] = current + space;
        }
      });
  });
  
  // Produce from religious buildings - NEW!
  S.religiousBuildings.forEach(b => {
    const building = RELIGIOUS_BUILDINGS.find(rb => rb.id === b.type);
    if (building) {
      let pietyGain = building.pietyGain;
      let godFavorGain = building.godFavorGain;
      
      // Apply building level
      const level = b.level || 1;
      pietyGain = Math.floor(pietyGain * (1 + (level - 1) * 0.5));
      godFavorGain = Math.floor(godFavorGain * (1 + (level - 1) * 0.5));
      
      // Apply rarity bonus
      if (building.rarity) {
        pietyGain = Math.floor(pietyGain * building.rarity.bonus);
        godFavorGain = Math.floor(godFavorGain * building.rarity.bonus);
      }
      
      // Add piety
      S.piety = Math.min(S.maxPiety, S.piety + pietyGain);
      
      // Add god favor to patron god or distribute if no patron
      if (S.patronGod) {
        S.godFavor[S.patronGod] = Math.min(100, (S.godFavor[S.patronGod] || 0) + godFavorGain);
      } else {
        // Distribute favor to all gods
        ROMAN_GODS.forEach(god => {
          S.godFavor[god.id] = Math.min(100, (S.godFavor[god.id] || 0) + Math.floor(godFavorGain / ROMAN_GODS.length));
        });
      }
    }
  });
  
  // Apply consecrated territory bonuses
  S.consecratedTerritories.forEach(tId => {
    const territory = TERRITORIES.find(t => t.id === tId);
    if (territory && territory.produces && territory.status === 'owned') {
      Object.entries(territory.produces).forEach(([resource, amount]) => {
        const bonus = Math.floor(amount * 0.25); // 25% bonus from consecration
        const current = S.inventory[resource] || 0;
        const totalResources = Object.values(S.inventory).reduce((sum, qty) => sum + qty, 0);
        
        if (totalResources + bonus <= S.capacity) {
          S.inventory[resource] = current + bonus;
        } else {
          const space = Math.max(0, S.capacity - totalResources);
          S.inventory[resource] = current + space;
        }
      });
    }
  });
  
  // Check if inventory is at or near capacity
  const totalInventory = Object.values(S.inventory).reduce((sum, qty) => sum + qty, 0);
  
// --- Auto-convert a portion of stored grain/livestock into edible food (early buffer) ---
(function __auto_convert_food_buffer__(){
  // Compute an early-game target buffer (~3x pop), but never exceed max storage
  let maxFood = S.maxFood;
  if (S.techs && S.techs.granaries) maxFood += 100;
  const targetBuffer = Math.floor(Math.min(maxFood, S.pop * 3));

  if (S.food < targetBuffer) {
    let needed = targetBuffer - S.food;

    // Convert grain first (5 food each), then livestock (3 food each)
    let useGrain = Math.min(S.inventory.grain || 0, Math.ceil(needed / 5));
    if (useGrain > 0) {
      S.inventory.grain -= useGrain;
      S.food += useGrain * 5;
      needed = Math.max(0, targetBuffer - S.food);
    }

    let useLivestock = Math.min(S.inventory.livestock || 0, Math.ceil(needed / 3));
    if (useLivestock > 0) {
      S.inventory.livestock -= useLivestock;
      S.food += useLivestock * 3;
    }

    // Respect the hard cap
    // Early-game extra storage headroom
    if (S.round <= 6) maxFood += 100;
    else if (S.round <= 12) maxFood += 50;
  // Hidden dynamic cap scaling for students
  maxFood += (S.round * 200);
    S.food = Math.min(S.food, maxFood);
  }
})(); // end auto-convert

S.inventoryFull = totalInventory >= S.capacity * 0.95;  // 95% full counts as "full"
}

function recalcHappiness() {
  let base = 50;
  
  if (S.pop > S.housing) base -= 20;
  else if (S.housing > S.pop * 1.5) base += 10;
  
  if (S.sanitation >= 70) base += 15;
  else if (S.sanitation < 40) base -= 15;
  
  if (S.food > S.pop * 2) base += 10;
  else if (S.food < S.pop) base -= 15;
  
  if (S.morale >= 70) base += 10;
  else if (S.morale < 40) base -= 10;
  
  if (S.denarii > 5000) base += 10;
  else if (S.denarii < 500) base -= 10;
  
  if (S.mods && S.mods.happinessMul) base *= S.mods.happinessMul;
  S.happiness = clamp(base, 0, 100);
}

function processFoodCycle(consumptionMul = 1.0) {
  
  // Early-game assistance: provide a small food bonus only in the first few rounds
  // to help the fledgling settlement survive.  After round 2 the bonus is 0.
  let earlyBuff = 0;
  if (S.round < 3) earlyBuff = 100;
  S.food = (S.food || 0) + earlyBuff;

  // Determine base consumption
  let baseConsumption = calcFoodConsumption() * consumptionMul;
  // Apply a simple rationing mechanic: if food stocks are low relative to
  // consumption, automatically reduce consumption at the cost of happiness.  If
  // stocks are plentiful, consumption increases slightly as citizens feast.
  let rationMultiplier = 1.0;
  if (S.food < baseConsumption) {
    rationMultiplier = 0.9;
    // happiness penalty for rationing
    S.happiness = Math.max(0, S.happiness - 1);
  } else if (S.food > baseConsumption * 4) {
    rationMultiplier = 1.05;
    // slight happiness bonus for abundance
    S.happiness = Math.min(100, S.happiness + 1);
  }
  let consumption = Math.floor(baseConsumption * rationMultiplier);
  
  // First, deduct consumption from food stores
  S.food -= consumption;
  
  // If food goes negative, try to use inventory
  if (S.food < 0) {
    let foodDeficit = Math.abs(S.food);
    S.food = 0;  // Reset to 0
    
    // Try to cover deficit with livestock first (more efficient)
    let livestock = S.inventory.livestock || 0;
    if (livestock > 0 && foodDeficit > 0) {
      let livestockNeeded = Math.ceil(foodDeficit / 3);
      let livestockUsed = Math.min(livestock, livestockNeeded);
      S.inventory.livestock = Math.max(0, livestock - livestockUsed);
      foodDeficit -= livestockUsed * 3;
    }
    
    // Then use grain if still in deficit
    if (foodDeficit > 0) {
      let grain = S.inventory.grain || 0;
      if (grain > 0) {
        let grainNeeded = Math.ceil(foodDeficit / 5);  // Changed from 4 to 5 to match foodValue
        let grainUsed = Math.min(grain, grainNeeded);
        S.inventory.grain = Math.max(0, grain - grainUsed);
        foodDeficit -= grainUsed * 5;  // Changed from 4 to 5
      }
    }
    
    // If still in deficit after using inventory = STARVATION
    if (foodDeficit > 0) {
      S.starvedRounds++;
      const loss = Math.floor(4 + Math.random() * 8);
      S.pop = Math.max(20, S.pop - loss);
      S.happiness = Math.max(0, S.happiness - 15);
      S.morale = Math.max(0, S.morale - 10);
      return {starved: true, loss};
    } else {
      // We covered the deficit with inventory
      S.food = Math.max(0, -foodDeficit);  // Any excess becomes food
      S.starvedRounds = Math.max(0, S.starvedRounds - 1);
    }
  } else {
    // Food was positive, no deficit
    S.starvedRounds = Math.max(0, S.starvedRounds - 1);
  }
  
  // Cap food at maximum
  let maxFood = S.maxFood;
  if (S.techs.granaries) maxFood += 100;
  // Early-game extra storage headroom
  if (S.round <= 6) maxFood += 100;
  else if (S.round <= 12) maxFood += 50;
  // Hidden dynamic cap scaling for students
  maxFood += (S.round * 200);
  S.food = Math.min(S.food, maxFood);
  
  return {starved: false};
}

function processPopGrowth() {
  if (S.happiness < 30 || S.food < S.pop) return 0;
  
  let growth = 0;
  if (S.happiness >= 75) growth += 4;
  else if (S.happiness >= 60) growth += 2;
  else if (S.happiness >= 45) growth += 1;
  
  if (S.housing < S.pop) growth = 0;
  else if (S.housing > S.pop * 1.2) growth += 1;
  
  if (S.sanitation >= 60) growth += 1;
  if (S.techs.aqueduct) growth += 2;
  if (S.food > S.pop * 3) growth += 1;
  
  S.pop += growth;
  return growth;
}

function updateMorale() {
  let decay = 2;
  if (S.food < S.troops * 1.5) decay += 3;
  if (S.supplies >= S.troops * 0.5) decay -= 1;
  if (S.happiness >= 70) decay -= 1;
  else if (S.happiness < 40) decay += 2;
  if (S.techs.legion) decay *= 0.8;
  if (S.mods && S.mods.moraleDecay) decay *= S.mods.moraleDecay;
  S.morale = clamp(S.morale - decay, 0, 100);
}

function conquestTerritory(territory) {
  if (!territory) {
    alert('Error: Invalid territory');
    return;
  }
  
  // Show confirmation dialog with odds
  const odds = calculateConquestOdds(territory);
  const confirm_msg = `Conquer ${territory.name}?\n\n` +
    `Win Chance: ${Math.round(odds.winProb * 100)}%\n` +
    `Your Strength: ${Math.round(odds.ourStr)}\n` +
    `Enemy Strength: ${Math.round(odds.enemyStr)}\n\n` +
    `Expected casualties: 3-6 (victory) or 8-12 (defeat)\n\n` +
    `Proceed with attack?`;
  
  if (!confirm(confirm_msg)) {
    return;
  }
  
  const victory = Math.random() < odds.winProb;
  
  const loss = victory ? Math.floor(3 + Math.random() * 6) : Math.floor(8 + Math.random() * 12);
  S.troops = Math.max(0, S.troops - loss);
  
  if (victory) {
    S.territories.push(territory.id);
    territory.status = 'owned';
    
    
    try { window.dispatchEvent(new CustomEvent('territory:conquered', {detail:{id: territory.id}})); } catch(e) {}
    // Apply rarity bonus to conquest reward!
    let reward = territory.value;
    if (territory.rarity) {
      reward = Math.floor(reward * territory.rarity.bonus);
    }
    
    S.denarii += reward;
    S.morale = Math.min(100, S.morale + 10);
    S.reputation += 8;
    S.favor += 4;
    S.victories++;
    
    const rarityText = territory.rarity ? ` [${territory.rarity.name} rarity!]` : '';
    alert(`‚öîÔ∏è VICTORY!\n\nConquered ${territory.name}${rarityText}\n+${fmt(reward)} denarii\nLosses: ${loss} troops`);
    
    S.history.push({
      round: S.round + 1,
      kind: 'Conquest',
      action: territory.name,
      note: `Victory! +${reward}d, Losses: ${loss}`
    });
  } else {
    S.morale = Math.max(0, S.morale - 15);
    S.happiness = Math.max(0, S.happiness - 10);
    
    alert(`üíÄ DEFEAT!\n\nFailed to take ${territory.name}\nLosses: ${loss} troops\n-15% morale, -10% happiness`);
    
    S.history.push({
      round: S.round + 1,
      kind: 'Conquest',
      action: territory.name,
      note: `Defeat. Losses: ${loss} troops`
    });
  }
  
  endSeason();
}

function calculateConquestOdds(territory) {
  let ourStr = S.troops * (S.morale / 100);
  if (S.supplies >= S.troops * 0.5) ourStr *= 1.2;
  if (S.techs.legion) ourStr *= 1.2;
  if (S.techs.forge) ourStr *= 1.1;
  if (S.mods && S.mods.attackBonus) ourStr += S.mods.attackBonus;
  if (S.mods && S.mods.territoryBonus) ourStr *= S.mods.territoryBonus;
  
  // Divine blessings - NEW!
  if (S.patronGod) {
    const god = ROMAN_GODS.find(g => g.id === S.patronGod);
    const godFavor = S.godFavor[S.patronGod] || 0;
    
    // Apply god-specific attack bonuses based on favor level
    if (god.id === 'jupiter') {
      if (godFavor >= 100) ourStr *= 1.25; // Thunderbolt Strike
      else if (godFavor >= 75) ourStr *= 1.20; // Sky King's Might
      else if (godFavor >= 50) ourStr *= 1.15; // Storm Shield
      else if (godFavor >= 25) ourStr += 20; // Divine Thunder
    }
    else if (god.id === 'mars') {
      if (godFavor >= 100) ourStr += 50; // Invincible Legion
      else if (godFavor >= 75) ourStr *= 1.30; // Battle Fury
      else if (godFavor >= 50) ourStr *= 1.20; // Legion's Blessing (recruitment bonus applied elsewhere)
      else if (godFavor >= 25) ourStr *= 1.15; // War Cry
    }
    else if (god.id === 'minerva') {
      if (godFavor >= 75) ourStr *= 1.15; // Strategic Mind
    }
  }
  
  const enemyStr = territory.str;
  const winProb = clamp(ourStr / (ourStr + enemyStr), 0.1, 0.9);
  return {ourStr, enemyStr, winProb};
}

/* ==================== SEASON ENDING ==================== */

function endSeason() {
  // Advance season
  advanceSeason();
  const seasonalEffects = getSeasonalEffects();
  
  // Production
  produceResources();
  
  // Food & population
  let foodConsumptionMul = 1.0;
  if (seasonalEffects.foodConsumption) foodConsumptionMul = seasonalEffects.foodConsumption;
  
  const foodResult = processFoodCycle(foodConsumptionMul);
  if (foodResult.starved) {
    alert(`‚ö†Ô∏è FAMINE!\n\nYour people starve!\nLost ${foodResult.loss} population\n-15% happiness, -10% morale`);
  }
  processPopGrowth();
  
  // Morale & happiness
  updateMorale();
  
  // Apply seasonal morale penalty (winter)
  if (seasonalEffects.moralePenalty) {
    S.morale = Math.max(0, S.morale - seasonalEffects.moralePenalty);
  }
  
  // Apply seasonal happiness boost (summer)
  if (seasonalEffects.happiness) {
    S.happiness = Math.min(100, S.happiness + seasonalEffects.happiness);
  }
  
  recalcHappiness();
  
  // === ECONOMIC SYSTEMS UPDATE ===
  // Update market prices based on supply/demand
  updateMarketPrices();
  
  // Track income for stats
  const prevDenarii = S.denarii;
  
  // Apply dynamic taxation system
  const taxRevenue = applyTaxation();
  S.totalIncomeEarned += taxRevenue;
  
  // Apply banking multiplier to denarii gains this season
  const bankingMult = getBankingMultiplier();
  if (bankingMult > 1.0) {
    const bankBonus = Math.floor(taxRevenue * (bankingMult - 1.0));
    S.denarii += bankBonus;
    S.totalIncomeEarned += bankBonus;
  }
  
  if (S.techs.senate) S.favor += 2;
  
  // UPKEEP COSTS - Critical for game balance!
  let upkeep = 0;
  
  // Building maintenance: sum the upkeep of each production building rather than a flat cost
  const buildingUpkeepTotal = S.productionBuildings.reduce((sum, b) => {
    const bDef = PRODUCTION_BUILDINGS.find(pb => pb.id === b.type);
    const up = (bDef && typeof bDef.upkeep === 'number') ? bDef.upkeep : 6;
    return sum + up;
  }, 0);
  upkeep += buildingUpkeepTotal;
  
  // Troop wages (2d per soldier - reduced from 3d)
  upkeep += S.troops * 2;
  
  // Housing maintenance (1d per 15 housing - reduced from 10)
  upkeep += Math.floor(S.housing / 15);
  
  // Infrastructure costs (forts, sanitation)
  upkeep += S.forts * 4;  // reduced from 5d
  upkeep += Math.floor(S.sanitation / 8);  // reduced from 5
  
  // Seasonal upkeep multiplier (winter)
  if (seasonalEffects.upkeepMul) {
    upkeep = Math.floor(upkeep * seasonalEffects.upkeepMul);
  }
  
  // Infinite mode has 1.4x upkeep costs
  if (S.infiniteMode) {
    upkeep = Math.floor(upkeep * 1.4);
  }
  
  // Event upkeep reduction
  if (S.eventModifiers.buildCostMul) {
    // Construction boom affects upkeep too
    upkeep = Math.floor(upkeep * Math.min(1.0, S.eventModifiers.buildCostMul + 0.2));
  }
  
  // Deduct upkeep
  S.denarii -= upkeep;
  
  // Bankruptcy check
  if (S.denarii < 0) {
    S.denarii = 0;
    S.happiness = Math.max(0, S.happiness - 25);
    S.morale = Math.max(0, S.morale - 15);
    alert(`üí∏ BANKRUPTCY!\n\nCannot afford upkeep of ${upkeep}d!\nYour denarii: 0\n\n-25% happiness\n-15% morale`);
  }
  
  // Store upkeep for display
  S.lastUpkeep = upkeep;
  S.lastTaxes = taxRevenue;
  
  // Events
  S.eventModifiers = {};
  S.raidWarning = false;
  
  if (Math.random() < 0.35) {  // Increased from 0.3 for more events
    const event = rpick(EVENTS.filter(e => Math.random() < e.prob));
    if (event) {
      event.effect(S.eventModifiers);
      
      // Apply event effects
      if (S.eventModifiers.popAdd) S.pop += S.eventModifiers.popAdd;
      if (S.eventModifiers.foodDelta) S.food = Math.max(0, S.food + S.eventModifiers.foodDelta);
      if (S.eventModifiers.moraleAdd) S.morale = clamp(S.morale + S.eventModifiers.moraleAdd, 0, 100);
      if (S.eventModifiers.happinessAdd) S.happiness = clamp(S.happiness + S.eventModifiers.happinessAdd, 0, 100);
      if (S.eventModifiers.favorAdd) S.favor += S.eventModifiers.favorAdd;
      if (S.eventModifiers.reputationAdd) S.reputation += S.eventModifiers.reputationAdd;
      if (S.eventModifiers.denariDelta) {
        S.denarii = Math.max(0, S.denarii + S.eventModifiers.denariDelta);
        if (S.eventModifiers.denariDelta > 0) S.totalIncomeEarned += S.eventModifiers.denariDelta;
      }
      if (S.eventModifiers.sanitationDelta) {
        S.sanitation = clamp(S.sanitation + S.eventModifiers.sanitationDelta, 0, S.maxSanitation);
      }
      if (S.eventModifiers.permanentTradeBuff) {
        S.permanentTradeBuff = 1.05; // Permanent 5% trade boost
      }
      
      // Show event notification
      alert(`${event.icon} ${event.name.toUpperCase()}\n\n${event.text}`);
    }
  }
  
  // Religious events - NEW!
  if (S.religiousBuildings.length > 0 && Math.random() < 0.20) {
    const religiousEvent = rpick(RELIGIOUS_EVENTS.filter(e => Math.random() < e.prob));
    if (religiousEvent) {
      const religModifiers = {};
      religiousEvent.effect(religModifiers);
      
      // Apply religious event effects
      if (religModifiers.pietyAdd) S.piety = clamp(S.piety + religModifiers.pietyAdd, 0, S.maxPiety);
      if (religModifiers.godFavorAdd && S.patronGod) {
        S.godFavor[S.patronGod] = clamp((S.godFavor[S.patronGod] || 0) + religModifiers.godFavorAdd, 0, 100);
      }
      if (religModifiers.happinessAdd) S.happiness = clamp(S.happiness + religModifiers.happinessAdd, 0, 100);
      if (religModifiers.moraleAdd) S.morale = clamp(S.morale + religModifiers.moraleAdd, 0, 100);
      if (religModifiers.foodDelta) S.food = Math.max(0, S.food + religModifiers.foodDelta);
      if (religModifiers.reputationAdd) S.reputation += religModifiers.reputationAdd;
      if (religModifiers.favorAdd) S.favor += religModifiers.favorAdd;
      
      // Show religious event
      alert(`${religiousEvent.icon} ${religiousEvent.name.toUpperCase()}\n\n${religiousEvent.text}`);
    }
  }
  
  // Price fluctuations
  GOODS.forEach(g => {
    let volatilityMultiplier = 1.0;
    if (S.infiniteMode) volatilityMultiplier = 2.5;
    
    // Seasonal trade price bonus (autumn)
    if (seasonalEffects.tradePrices && Math.random() > 0.5) {
      S.priceIndex[g.id] *= seasonalEffects.tradePrices;
    }
    
    const drift = (Math.random() - 0.5) * g.vol * 20 * volatilityMultiplier;
    S.priceIndex[g.id] = clamp(S.priceIndex[g.id] + drift, 60, 180);
  });
  // Gently nudge price indices toward the underlying supply/demand targets.  This
  // ties the random price index to the market demand calculated in
  // updateMarketPrices(), so that oversupplied goods trend downward and scarce
  // goods trend upward over time.  Only adjust goods that exist in the
  // supplyDemand table.
  GOODS.forEach(g => {
    if (S.supplyDemand && S.supplyDemand[g.id] !== undefined) {
      const target = S.supplyDemand[g.id];
      const current = S.priceIndex[g.id] || 100;
      // Move 10% of the distance toward the target
      const adjusted = current + (target - current) * 0.1;
      S.priceIndex[g.id] = clamp(adjusted, 60, 180);
    }
  });
  
  // Decrease temporary buff durations
  if (S.comboAttackDuration) {
    S.comboAttackDuration--;
    if (S.comboAttackDuration <= 0) {
      S.comboAttackBonus = 0;
      S.comboAttackDuration = 0;
    }
  }
  if (S.comboTradeDuration) {
    S.comboTradeDuration--;
    if (S.comboTradeDuration <= 0) {
      S.comboTradeBuff = 1.0;
      S.comboTradeDuration = 0;
    }
  }
  if (S.questTradeBuffDuration) {
    S.questTradeBuffDuration--;
    if (S.questTradeBuffDuration <= 0) {
      S.questTradeBuff = 1.0;
      S.questTradeBuffDuration = 0;
    }
  }
  
  // Process Trade Routes
  if (S.tradeState && S.tradeState.routes) {
    S.tradeState.routes.forEach((route, idx) => {
      // Check if we have goods
      if (S.inventory[route.goodId] >= route.qty) {
        // Deduct goods
        S.inventory[route.goodId] -= route.qty;
        // Add income
        S.denarii += route.income;
        S.totalIncomeEarned += route.income;
        // Decrease duration
        route.duration--;
      } else {
        // Not enough goods, route paused
        route.duration--;
      }
    });
    // Remove expired routes
    S.tradeState.routes = S.tradeState.routes.filter(r => r.duration > 0);
  }
  
  // Process Active Caravan
  if (S.tradeState && S.tradeState.activeCaravan) {
    S.tradeState.activeCaravan.duration--;
    
    if (S.tradeState.activeCaravan.duration <= 0) {
      // Caravan returns!
      const caravan = S.tradeState.activeCaravan;
      const success = Math.random() > caravan.risk;
      
      if (success) {
        let totalRevenue = 0;
        caravan.goods.forEach(g => {
          const price = getTradePrice(g.gid, caravan.cityId);
          totalRevenue += price * g.qty;
        });
        
        totalRevenue = Math.floor(totalRevenue * caravan.reward);
        S.denarii += totalRevenue;
        S.totalIncomeEarned += totalRevenue;
        
        // Improve reputation
        S.tradeState.reputation[caravan.cityId] = (S.tradeState.reputation[caravan.cityId] || 0) + 3;
        
        alert(`üê´ Caravan Returns!\n\n${caravan.cityName} expedition successful!\n\nEarned: ${fmt(totalRevenue)} denarii\nReputation +3`);
      } else {
        S.tradeState.reputation[caravan.cityId] = (S.tradeState.reputation[caravan.cityId] || 0) - 2;
        alert(`üíÄ Caravan Lost!\n\n${caravan.cityName} expedition failed!\nGoods lost to bandits.\n\nReputation -2`);
        S.happiness = Math.max(0, S.happiness - 8);
      }
      
      S.tradeState.activeCaravan = null;
    }
  }
  
  // ==================== TERRITORY SYSTEM PROCESSING ====================
  // Initialize territory data if not exists
  if (!S.territoryData) {
    initTerritoryEnhancements();
  }
  
  // Process territory events
  processTerritoryEvents();
  
  // Apply territory production
  applyTerritoryProduction();
  
  // ==================== END TERRITORY SYSTEM ====================
  
  S.round++;
  
  // Check achievements & update quests
  checkAchievements();
  updateQuestProgress('population');
  updateQuestProgress('troops');
  updateQuestProgress('wealth');
  updateQuestProgress('inventory');
  initializeQuests();
  
  // Update advisor
  updateAdvisor();
  
  // Check for raids
  if (checkForRaid()) {
    S.battleActive = true;
    render();
    return;
  }
  
  // Infinite mode: Generate new content
  if (S.infiniteMode) {
    if (S.round % 7 === 0) {
      generateNewTerritory();
    }
    if (S.round % 10 === 0 && PRODUCTION_BUILDINGS.length < 50) {
      generateNewProductionBuilding();
    }
    if (S.round % 15 === 0 && TECHNOLOGIES.length < 40) {
      generateNewTechnology();
    }
    if (S.round % 20 === 0 && CITIES.length < 20) {
      generateNewCity();
    }
  }
  
  // Check ending
  if (S.round >= S.maxRounds || checkEarlyEnding()) {
    S.stage = 'results';
  }
  
  render();
}

function checkEarlyEnding() {
  if (S.starvedRounds >= 3) return true;
  if (S.pop < 40) return true;
  if (S.happiness <= 20) return true;
  return false;
}

function simulateSeason() {
  // Auto-produce and auto-trade
  const availableGoods = Object.entries(S.inventory)
    .filter(([id, qty]) => qty > 0 && id !== 'iron')
    .sort((a, b) => b[1] - a[1]);
  
  if (availableGoods.length > 0) {
    const cities = CITIES.filter(c => c.id !== 'tiber');
    let bestDeal = {city: null, revenue: 0, goods: []};
    
    cities.forEach(city => {
      let revenue = 0;
      let goods = [];
      
      availableGoods.slice(0, 3).forEach(([gid, qty]) => {
        const sellQty = Math.min(qty, 5);
        const price = priceFor(gid, city.id) * sellQty;
        revenue += price;
        goods.push({gid, qty: sellQty});
      });
      
      if (revenue > bestDeal.revenue) {
        bestDeal = {city, revenue, goods};
      }
    });
    
    if (bestDeal.city) {
      let totalRevenue = 0;
      bestDeal.goods.forEach(({gid, qty}) => {
        const price = priceFor(gid, bestDeal.city.id);
        totalRevenue += price * qty;
        S.inventory[gid] -= qty;
      });
      
      const risk = riskFor(bestDeal.city.id);
      const success = Math.random() > risk;
      
      if (success) {
        let finalRevenue = totalRevenue;
        if (S.mods && S.mods.sellMul) finalRevenue *= S.mods.sellMul;
        if (S.techs.market) finalRevenue *= 1.05;
        if (S.techs.senate) finalRevenue *= 1.01;
        
        const tariff = bestDeal.city.tariff * (S.mods && S.mods.tariffMul ? S.mods.tariffMul : 1) * (S.proc_perk_tariff ? S.proc_perk_tariff : 1);
        finalRevenue = Math.floor(finalRevenue * (1 - tariff));
        
        S.denarii += finalRevenue;
        S.reputation += 3;
        S.favor += Math.floor(finalRevenue / 500);

        // Adjust price index for goods sold to reflect oversupply.  Selling
        // decreases demand in the short term, nudging the price index down.
        bestDeal.goods.forEach(({gid}) => {
          if (S.priceIndex && typeof S.priceIndex[gid] === 'number') {
            S.priceIndex[gid] = clamp(S.priceIndex[gid] * 0.97, 60, 180);
          }
        });
      }
    }
  }
  
  endSeason();
}

function priceFor(gid, cid) {
  const good = GOODS.find(g=>g.id===gid);
  if (!good) {
    console.error('Invalid good ID in priceFor:', gid);
    return 10; // Minimum fallback price
  }
  
  // Use base price with fallback to regular price
  const base = good.base || good.price || 100;
  
  // Safely get price index with fallback
  const priceIndexValue = S.priceIndex?.[gid] ?? 100;
  if (isNaN(priceIndexValue)) {
    console.warn(`NaN priceIndex for ${gid}, using 100`);
    S.priceIndex[gid] = 100;
  }
  const idx = (S.priceIndex[gid] || 100) / 100;
  
  const city = CITIES.find(c=>c.id===cid);
  if (!city) {
    console.warn('Invalid city ID in priceFor:', cid);
    return Math.max(10, Math.round(base * idx));
  }
  
  const bias = city.bias?.[gid] || 0;
  
  let price = base * idx + bias;
  
  // Apply tech bonuses
  if (S.techs?.market) price += 5;
  
  // Add trade system bonuses if available
  if (S.tradeState?.upgrades?.negotiation) {
    const negBonus = S.tradeState.upgrades.negotiation * 0.05;
    if (!isNaN(negBonus)) {
      price *= (1 + negBonus);
    }
  }
  
  if (S.tradeState?.reputation?.[cid]) {
    const rep = S.tradeState.reputation[cid];
    if (!isNaN(rep)) {
      const repBonus = Math.floor(rep / 10) * 0.05;
      price *= (1 + repBonus);
    }
  }
  
  const finalPrice = Math.max(10, Math.round(price));
  
  // Final NaN check
  if (isNaN(finalPrice)) {
    console.error('NaN price calculated for', gid, 'in', cid, '- using fallback');
    return 10;
  }
  
  return finalPrice;
}

function riskFor(cid) {
  const city = CITIES.find(c=>c.id===cid);
  let risk = city.risk;
  risk += city.distance * 0.01;
  if (S.techs.roads) risk *= 0.85;
  if (S.techs.walls) risk *= 0.9;
  risk -= S.forts * 0.005;
  if (S.eventModifiers.riskMul) risk *= S.eventModifiers.riskMul;
  if (S.mods && S.mods.riskMul) risk *= S.mods.riskMul;
  
  // Add trade system bonuses if available
  if (S.tradeState?.upgrades?.guards) {
    risk *= (1 - S.tradeState.upgrades.guards * 0.10);
  }
  return clamp(risk, 0.01, 0.5);
}

/* ==================== INFINITE MODE GENERATION ==================== */

function generateNewTerritory() {
  const rarity = rollRarity();
  
  const newId = 'generated_' + S.nextTerritoryId;
  S.nextTerritoryId++;
  
  const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 
                         'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX'];
  const latinBaseName = generateLatinName('territory');
  const numeralIndex = Math.floor((S.nextTerritoryId - 1000) / 10);
  const numeral = romanNumerals[numeralIndex % 20];
  const latinName = latinBaseName + ' ' + numeral;
  const name = latinName; // Use Latin name as the main name!
  
  const difficultyFactor = Math.floor(S.territories.length / 8);
  const baseStrength = 40 + (S.territories.length * 8) + (difficultyFactor * 15);
  const strength = Math.floor(baseStrength + Math.random() * 30);
  const value = Math.floor((200 + strength * 2.5 + difficultyFactor * 50) * rarity.bonus);
  
  const resources = ['grain', 'livestock', 'timber', 'clay', 'salt', 'wool', 'iron', 'wine', 'oliveoil', 'spices'];
  const produces = {};
  const numResources = Math.min(2 + Math.floor(Math.random() * 3) + Math.floor(difficultyFactor / 2), 5);
  const selectedResources = [];
  for (let i = 0; i < numResources; i++) {
    let resource = rpick(resources);
    let attempts = 0;
    while (selectedResources.includes(resource) && attempts < 10) {
      resource = rpick(resources);
      attempts++;
    }
    if (!selectedResources.includes(resource)) {
      selectedResources.push(resource);
      const baseAmount = 1 + Math.random() * 3 + (difficultyFactor * 0.5);
      produces[resource] = Math.floor(baseAmount * rarity.bonus);
    }
  }
  
  let status = 'hostile';
  if (strength < 50) status = 'contested';
  
  const newTerritory = {
    id: newId,
    latinName: latinName,
    name: name,
    status: status,
    str: strength,
    value: value,
    img: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Italia_Antica.jpg/320px-Italia_Antica.jpg',
    produces: produces,
    desc: `A ${strength > 100 ? 'formidable' : 'promising'} territory discovered through expansion`,
    req: Math.max(0, S.territories.length - 5),
    rarity: rarity
  };
  
  TERRITORIES.push(newTerritory);
  
  const territoriesPerTab = 12;
  const newTabIndex = Math.floor((TERRITORIES.length - 1) / territoriesPerTab);
  if (newTabIndex > S.mapTab) {
    S.mapTab = newTabIndex;
  }
}

function generateNewProductionBuilding() {
  const resources = ['grain', 'livestock', 'timber', 'clay', 'salt', 'wool', 'iron', 'wine', 'oliveoil', 'spices'];
  const resource = rpick(resources);
  const good = GOODS.find(g => g.id === resource);
  
  const rarity = rollRarity();
  
  const buildingEmojis = ['üè≠', '‚öôÔ∏è', 'üî®', 'üë∑', 'üèõÔ∏è', '‚öíÔ∏è', 'üèóÔ∏è', 'üèòÔ∏è'];
  const emoji = rpick(buildingEmojis);
  
  const latinName = generateLatinName('building');
  const name = `${latinName} (${good.name})`;
  
  const baseCost = 150 + (PRODUCTION_BUILDINGS.length * 30);
  const cost = Math.floor(baseCost + Math.random() * 100);
  
  const baseRate = 2 + Math.random() * 3;
  const rate = Math.floor(baseRate * rarity.bonus);
  
  const newBuilding = {
    id: 'gen_building_' + PRODUCTION_BUILDINGS.length,
    latinName: latinName,
    name: name,
    emoji: emoji,
    cost: cost,
    produces: resource,
    rate: rate,
    desc: `Advanced facility producing ${rate} ${resource} per season`,
    rarity: rarity
  };
  
  PRODUCTION_BUILDINGS.push(newBuilding);
}

function generateNewTechnology() {
  const techTypes = [
    'Advanced Logistics', 'Imperial Roads', 'Master Craftsmanship',
    'Elite Training', 'Divine Favor', 'Market Dominance',
    'Military Innovation', 'Agricultural Revolution', 'Trade Networks',
    'Cultural Heritage', 'Engineering Mastery', 'Diplomatic Relations'
  ];
  
  const effects = ['economy', 'military', 'farming', 'mining', 'population', 'trade'];
  const baseCost = 400 + (TECHNOLOGIES.length * 50);
  const cost = Math.floor(baseCost + Math.random() * 200);
  
  const newTech = {
    id: 'gen_tech_' + TECHNOLOGIES.length,
    name: rpick(techTypes) + ' ' + (TECHNOLOGIES.length - 9),
    cost: cost,
    req: {denarii: Math.floor(cost * 0.8), territories: Math.floor(TECHNOLOGIES.length / 3)},
    effect: rpick(effects),
    desc: `Advanced technology providing strategic bonuses`,
    unlocked: false
  };
  
  TECHNOLOGIES.push(newTech);
}

function generateNewCity() {
  const cityNames = [
    'Distant Market', 'Far Trading Post', 'Remote Harbor', 'Frontier Settlement',
    'Border Town', 'Merchant Outpost', 'Trade Hub', 'Commercial Center',
    'Coastal Port', 'Mountain Village', 'River City', 'Forest Settlement'
  ];
  
  const newCity = {
    id: 'gen_city_' + CITIES.length,
    name: rpick(cityNames) + ' ' + (CITIES.length - 5),
    tariff: 0.03 + Math.random() * 0.05,
    risk: 0.05 + Math.random() * 0.06,
    distance: 2 + Math.floor(Math.random() * 4),
    bias: Object.fromEntries(GOODS.map(g => [g.id, Math.floor((Math.random() - 0.5) * 12)])),
    specialty: rpick(GOODS).id,
    relation: Math.floor((Math.random() - 0.5) * 10)
  };
  
  CITIES.push(newCity);
}

/* ==================== RENDER ==================== */

function render() {
  try{ if (window.CapSystem) CapSystem.computeCaps(); }catch(e){} if (S.battleActive) {
    renderBattleScreen();
    return;
  }
  
  if (S.stage === 'intro') renderIntro();
  else if (S.stage === 'game') renderGame();
  else if (S.stage === 'results') renderResults();
}

function renderIntro() {
  const card = el('div', {class:'card'});
  // Render intro without the long features text box. Players now get a brief in‚Äëgame
  // tutorial upon starting, so the heavy features list has been removed.
  card.append(
    el('h2', {}, 'Choose Your Founder'),
    el('div', {class:'grid g2'})
  );
  
  const grid = card.querySelector('.g2');
  
  // Show normal founders
  ['romulus', 'remus'].forEach(founderId => {
    const f = FOUNDERS[founderId];
    const box = el('div', {class:'choice'});
    box.append(
      el('div', {style:'font-size:32px;text-align:center;margin-bottom:8px'}, f.icon),
      el('h3', {}, f.name),
      el('div', {class:'small', style:'margin:8px 0'}, f.desc),
      el('button', {class:'btn btn-primary', onClick:()=>startGame(f)}, 'Select ' + f.name)
    );
    grid.append(box);
  });
  
  // Show Mr. Kitchen if unlocked
  if (S.wolfClicks >= 5) {
    const f = FOUNDERS.kitchen;
    const box = el('div', {class:'choice', style:'outline:3px solid gold;background:linear-gradient(135deg,#fef3c7,#fde68a);animation:imperial-glow 2s ease-in-out infinite'});
    box.append(
      el('div', {style:'font-size:32px;text-align:center;margin-bottom:8px'}, f.icon),
      el('h3', {style:'color:#dc2626'}, f.name + ' ‚≠ê‚≠ê‚≠ê'),
      el('div', {class:'small', style:'margin:8px 0;font-weight:900;color:#b45309'}, f.desc),
      el('div', {class:'tiny', style:'color:#dc2626;margin:4px 0;font-weight:900'}, 'SECRET CHARACTER UNLOCKED! SUPER OVERPOWERED!'),
      el('div', {class:'tiny', style:'color:#7a1f1f;margin:4px 0'}, '999x multipliers on EVERYTHING! Instant win mode!'),
      el('button', {class:'btn btn-primary', style:'background:linear-gradient(90deg,#dc2626,#ea580c,#eab308);border:none;font-weight:900', onClick:()=>startGame(f)}, 'üî• SELECT MR. KITCHEN üî•')
    );
    grid.append(box);
  }
  
  app.textContent = '';
  app.append(card);
}

function startGame(founder) {
  S.stage = 'game';
  S.founder = founder.id;
  S.mods = founder.mods;
  S.name = founder.name;
  
  // Mr. Kitchen gets TRULY OVERPOWERED stats!
  if (founder.id === 'kitchen') {
    S.denarii = 999999999;
    S.favor = 999999;
    S.reputation = 999999;
    S.troops = 999999;
    S.morale = 100;
    S.supplies = 999999;
    S.pop = 999999;
    S.housing = 999999;
    S.sanitation = 100;
    S.forts = 9999;
    S.happiness = 100;
    S.food = 999999;
    S.capacity = 999999;
    S.maxFood = 999999;
    S.maxSanitation = 100;
  }
  
  recalcHappiness();
  validateEconomyState(); // Ensure economy is properly initialized
  render();

  // After rendering the main game screen, trigger a short tutorial sequence for new players.
  // The tutorial consists of a few pop‚Äëups explaining core mechanics. It only runs once
  // per save file. A small delay ensures the DOM is ready before creating overlays.
  if (!S.tutorialSeen && typeof startTutorial === 'function') {
    setTimeout(() => {
      try { startTutorial(); } catch(e) { console.error(e); }
    }, 200);
  }
}

function renderGame() {
  const root = el('div');
  
  // Save/Load buttons
  const saveLoadBtns = el('div', {class:'save-load-btn'},
    el('button', {class:'btn', style:'background:#2563eb;color:#fff;font-size:12px;padding:8px 12px', onClick:saveGame}, 'üíæ Save'),
    el('button', {class:'btn', style:'background:#16a34a;color:#fff;font-size:12px;padding:8px 12px', onClick:loadGame}, 'üìÅ Load'),
    el('button', {class:'btn', style:'background:#dc2626;color:#fff;font-size:12px;padding:8px 12px', onClick:deleteSave}, 'üóëÔ∏è Delete')
  );
  document.body.appendChild(saveLoadBtns);
  
  // Status card
  const currentSeason = SEASONS[S.seasonIndex];
  const statusCard = el('div', {class:'card'});
  statusCard.append(
    el('div', {style:'display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:12px'},
      el('div', {},
        el('h2', {style:'margin:0 0 4px 0'}, `Season ${S.round}/${S.infiniteMode ? '‚àû' : S.maxRounds} ‚Äî ${S.name}`),
        el('div', {class:'season-indicator'},
          currentSeason.icon + ' ',
          currentSeason.name,
          el('span', {class:'tiny', style:'margin-left:8px'}, currentSeason.desc)
        )
      ),
      el('div', {style:'display:flex;gap:8px;flex-wrap:wrap'},
        el('button', {
          class:'btn',
          style:'background:#16a34a;color:#fff',
          onClick: simulateSeason
        }, '‚è≠Ô∏è Simulate Season'),
        el('button', {
          class:'btn',
          style:'background:#2563eb;color:#fff',
          onClick: () => {
            const help = `üèõÔ∏è GAME GUIDE üèõÔ∏è\n\n` +
              `GOAL: Build a thriving Roman empire!\n\n` +
              `‚è≠Ô∏è SIMULATE: Auto-trade + advance season\n` +
              `üè≠ RESOURCES: Build production facilities\n` +
              `üó∫Ô∏è MAP: Conquer territories for bonuses\n` +
              `üí∞ TRADE: Sell goods to cities\n` +
              `‚öîÔ∏è MILITARY: Recruit troops, defend raids\n` +
              `üèòÔ∏è SETTLEMENT: Build housing, sanitation\n` +
              `üî¨ TECH: Research upgrades\n\n` +
              `TIPS:\n` +
              `‚Ä¢ Keep food > population\n` +
              `‚Ä¢ Build warehouses for capacity\n` +
              `‚Ä¢ Trade before inventory fills\n` +
              `‚Ä¢ Watch your upkeep costs!\n` +
              `‚Ä¢ Balanced growth = success`;
            alert(help);
          }
        }, '‚ùì Help')
      )
    ),
    el('div', {class:'grid g5'},
      statPill('üí∞', 'Denarii', S.denarii, 'gold'),
      statPill('üë•', 'Population', S.pop, S.pop > S.housing ? 'warning' : 'normal'),
      statPill('üòä', 'Happiness', Math.round(S.happiness) + '%', S.happiness < 40 ? 'warning' : 'success'),
      statPill('‚öîÔ∏è', 'Troops', S.troops, 'normal'),
      statPill('üåæ', 'Food', Math.floor(S.food), S.food < S.pop ? 'warning' : 'normal')
    ),
    el('div', {class:'grid g5', style:'margin-top:8px'},
      statPill('‚ú®', 'Piety', S.piety, 'normal'),
      statPill('üèõÔ∏è', 'Favor', S.favor, 'normal'),
      statPill('üìä', 'Reputation', S.reputation, 'normal'),
      statPill('üì¶', 'Capacity', Object.values(S.inventory).reduce((a,b)=>a+b,0) + '/' + S.capacity, 'normal'),
      S.patronGod ? statPill(ROMAN_GODS.find(g=>g.id===S.patronGod).icon, 
        ROMAN_GODS.find(g=>g.id===S.patronGod).name, 
        (S.godFavor[S.patronGod]||0) + '/100', 'normal') : 
        statPill('‚õ™', 'No Patron', 'Choose in Religion tab', 'warning')
    )
  );
  root.append(statusCard);
  
  // Show production warning if any
  if (S.lastProductionWarning) {
    root.append(
      el('div', {class:'info', style:'background:#fee2e2;border-color:#dc2626;margin-bottom:12px;animation:pulse 2s ease-in-out infinite'},
        S.lastProductionWarning
      )
    );
  }
  
  // Focus tabs - ENHANCED with new tabs
  const tabs = el('div', {class:'tabs'});
  ['resources', 'economy', 'map', 'trade', 'military', 'settlement', 'diplomacy', 'religion', 'wonders', 'tech', 'tracker', 'achievements', 'quests'].forEach(f => {
    tabs.append(
      el('div', {
        class: 'tab' + (S.focus === f ? ' active' : ''),
        onClick: () => { S.focus = f; render(); }
      }, capitalize(f))
    );
  });
  root.append(tabs);
  
  // Focus content
  const focusCard = el('div', {class:'card'});
  if (S.focus === 'resources') renderResourcesFocus(focusCard);
  else if (S.focus === 'economy') renderEconomyFocus(focusCard);
  else if (S.focus === 'map') renderMapFocus(focusCard);
  else if (S.focus === 'trade') renderTradeFocus(focusCard);
  else if (S.focus === 'military') renderMilitaryFocus(focusCard);
  else if (S.focus === 'settlement') renderSettlementFocus(focusCard);
  else if (S.focus === 'diplomacy') renderDiplomacyFocus(focusCard);
  else if (S.focus === 'religion') renderReligionFocus(focusCard);
  else if (S.focus === 'territory_detail') renderTerritoryDetail(focusCard);
  else if (S.focus === 'wonders') {
    if (typeof window.WondersSystem !== 'undefined' && window.WondersSystem.renderWonders) {
      focusCard.innerHTML = window.WondersSystem.renderWonders();
    } else {
      focusCard.innerHTML = '<p>Wonders system loading...</p>';
    }
  }
  else if (S.focus === 'tech') renderTechnologies(focusCard);
  else if (S.focus === 'tracker') renderTrackerScreen(focusCard);
  else if (S.focus === 'achievements') renderAchievements(focusCard);
  else if (S.focus === 'quests') renderQuests(focusCard);
  root.append(focusCard);
  
  app.textContent = '';
  app.append(root);
}

function renderResourcesFocus(root) {
  root.append(
    el('h2', {}, 'üè≠ Production Buildings'),
    el('div', {class:'info'},
      'Build facilities to automatically produce resources each season. Rarity affects production rate!'
    )
  );
  
  // Show economy summary
  const consumption = calcFoodConsumption();
  // Compute upkeep based on individual building upkeep values instead of a flat per-building cost.
  const buildingsUpkeep = S.productionBuildings.reduce((sum, b) => {
    const bDef = PRODUCTION_BUILDINGS.find(pb => pb.id === b.type);
    const up = (bDef && typeof bDef.upkeep === 'number') ? bDef.upkeep : 6;
    return sum + up;
  }, 0);
  const estimatedUpkeep = buildingsUpkeep + S.troops * 2 + Math.floor(S.housing / 15) + S.forts * 4 + Math.floor(S.sanitation / 8);
  const estimatedTaxes = Math.floor(S.pop * 0.7 + (S.happiness > 70 ? S.pop * 0.2 : 0));
  const netIncome = estimatedTaxes - estimatedUpkeep;
  
  // Calculate total production
  let totalProduction = {};
  S.productionBuildings.forEach(b => {
    const building = PRODUCTION_BUILDINGS.find(pb => pb.id === b.type);
    if (building) {
      let rate = building.rate;
      const level = b.level || 1;
      rate = Math.floor(rate * (1 + (level - 1) * 0.5));
      if (building.rarity) rate = Math.floor(rate * building.rarity.bonus);
      if (building.produces === 'grain' && S.techs.irrigation) rate = Math.floor(rate * 1.5);
      if (building.produces === 'iron' && S.techs.mining) rate *= 2;
      totalProduction[building.produces] = (totalProduction[building.produces] || 0) + rate;
    }
  });
  
  const totalInventory = Object.values(S.inventory).reduce((sum, qty) => sum + qty, 0);
  const capacityPercent = Math.round((totalInventory / S.capacity) * 100);
  const capacityWarning = capacityPercent >= 80 ? ' ‚ö†Ô∏è NEAR FULL!' : '';
  
  const economyChildren = [
    el('b', {}, `üìä Economy Status: ${capacityWarning}`),
    el('br'),
    el('div', {style:'margin-top:4px'}, 
      `Food: ${Math.floor(S.food)} | Consumption: ${consumption}/season`
    ),
    el('div', {style:'margin-top:4px'}, 
      `Inventory: ${totalInventory}/${S.capacity} (${capacityPercent}%) | Grain:${S.inventory.grain||0} Livestock:${S.inventory.livestock||0}`
    )
  ];
  
  if (totalProduction && Object.keys(totalProduction).length > 0) {
    economyChildren.push(
      el('div', {style:'margin-top:4px;color:#16a34a;font-weight:700'}, 
        `Production/season: ${Object.entries(totalProduction).map(([k,v])=>`${k}:${v}`).join(' ')}`
      )
    );
  }
  
  economyChildren.push(
    el('div', {style:'margin-top:4px;padding-top:4px;border-top:1px solid #fbbf24'}, 
      `Income: ${estimatedTaxes}d/season (taxes) | Upkeep: ${estimatedUpkeep}d/season`
    ),
    el('div', {style:'margin-top:4px;font-weight:700', html: netIncome >= 0 ? 
      `<span style="color:#16a34a">Net: +${netIncome}d/season ‚úì</span>` : 
      `<span style="color:#dc2626">Net: ${netIncome}d/season ‚ö†Ô∏è</span>`
    }),
    el('div', {style:'margin-top:4px;font-size:11px;color:#7a3b00'}, 
      'Grain/livestock auto-feed your people when food runs low. Each production building has its own upkeep cost, so choose wisely! Sell goods before inventory fills up.'
    )
  );
  
  root.append(
    el('div', {class:'info', style:`background:${capacityPercent >= 80 ? '#fef2f2' : '#fef3c7'};border-color:${capacityPercent >= 80 ? '#dc2626' : '#fbbf24'};margin:12px 0`},
      ...economyChildren
    )
  );
  
  const buildGrid = el('div', {class:'grid g3'});
  PRODUCTION_BUILDINGS.forEach(building => {
    const inflationMult = getInflationMultiplier();
    const adjustedCost = Math.floor(building.cost * inflationMult);
    const canAfford = S.denarii >= adjustedCost;
    const rarityText = building.rarity ? ` [${building.rarity.name}]` : '';
    
    const box = el('div', {class:'choice', style: !canAfford ? 'opacity:0.6' : ''});
    box.append(
      el('div', {style:'font-size:24px;text-align:center;margin-bottom:8px'}, building.emoji),
      el('div', {style:'font-weight:800;margin-bottom:4px'}, building.name + rarityText),
      building.latinName ? el('div', {class:'tiny', style:'font-style:italic;color:#7a3b00;margin-bottom:4px'}, building.latinName) : '',
      el('div', {class:'small', style:'margin:4px 0'}, building.desc),
      el('div', {class:'small', style:'margin:4px 0'}, `Cost: ${adjustedCost} denarii${inflationMult > 1 ? ` (${Math.round((inflationMult-1)*100)}% inflation)` : ''}`),
      el('div', {class:'small', style:'margin:4px 0;color:#16a34a;font-weight:700'}, `Produces: ${building.rate} ${building.produces}/season`),
      // Display the upkeep specific to this building.  All production buildings now
      // define an `upkeep` property, so we interpolate that value here.  This
      // makes the economic cost transparent to the player.
      el('div', {class:'tiny', style:'margin:4px 0;color:#dc2626'}, `Upkeep: ${building.upkeep}d/season`),
      el('button', {
        class:'btn btn-primary',
        style:'margin-top:10px;width:100%',
        disabled: !canAfford,
        onClick: !canAfford ? null : () => {
          if (S.denarii < adjustedCost) return alert('Not enough denarii');
          S.denarii -= adjustedCost;
          S.productionBuildings.push({type: building.id, level: 1});
          // Inform the player of the actual upkeep rather than a flat number
          alert(`Built ${building.name}! Will produce ${building.rate} ${building.produces} per season.\n\nUpkeep: ${building.upkeep} denarii/season`);
          render();
        }
      }, canAfford ? 'Build' : 'Build (locked)')
    );
    buildGrid.append(box);
  });
  root.append(buildGrid);
  
  // Show owned buildings
  if (S.productionBuildings.length > 0) {
    root.append(
      el('h3', {style:'margin-top:16px'}, 'üì¶ Your Buildings'),
      el('div', {class:'grid g4'},
        ...S.productionBuildings.map(b => {
          const building = PRODUCTION_BUILDINGS.find(pb => pb.id === b.type);
          const rarityBadge = building && building.rarity ? getRarityBadge(building.rarity) : '';
          const latinText = building && building.latinName ? building.latinName : '';
          return el('div', {class:'choice'},
            el('div', {style:'font-size:24px;text-align:center'}, building.emoji),
            el('div', {class:'small', style:'font-weight:700;text-align:center', html:building.name + rarityBadge}),
            latinText ? el('div', {class:'tiny', style:'color:#7a3b00;font-style:italic;text-align:center'}, latinText) : '',
            el('div', {class:'tiny', style:'text-align:center;color:#16a34a'}, `+${building.rate} ${building.produces}/season`)
          );
        })
      )
    );
  }
  
  // Resource Combinations section
  root.append(
    el('div', {class:'divider', style:'margin:24px 0'}),
    el('h2', {}, '‚öôÔ∏è Resource Combinations'),
    el('div', {class:'info'}, 'Combine resources for powerful bonuses!')
  );
  
  const comboGrid = el('div', {class:'grid g2'});
  RESOURCE_COMBOS.forEach(combo => {
    const canAfford = canAffordCombo(combo);
    const card = el('div', {class:'combo-card', style: canAfford ? '' : 'opacity:0.6'});
    
    const costDisplay = el('div', {class:'combo-cost'});
    Object.entries(combo.cost).forEach(([resource, amount]) => {
      const have = S.inventory[resource] || 0;
      const good = GOODS.find(g => g.id === resource);
      costDisplay.append(
        el('div', {class:'combo-cost-item', style: have >= amount ? 'background:#dcfce7' : 'background:#fee2e2'},
          `${good.emoji} ${amount} (have: ${have})`
        )
      );
    });
    
    card.append(
      el('div', {style:'font-weight:900;margin-bottom:6px'}, `${combo.icon} ${combo.name}`),
      el('div', {class:'small', style:'margin-bottom:8px'}, combo.desc),
      costDisplay,
      el('button', {
        class:'btn btn-primary',
        style:'margin-top:10px;width:100%',
        disabled: !canAfford,
        onClick: canAfford ? () => {
          if (useResourceCombo(combo)) render();
        } : null
      }, canAfford ? 'Use Combination' : 'Need Resources')
    );
    comboGrid.append(card);
  });
  root.append(comboGrid);
}

/* ==================== ECONOMY FOCUS RENDERING ==================== */
function renderEconomyFocus(root) {
  root.append(
    el('h2', {}, 'üí∞ Economic Management'),
    el('div', {class:'info'},
      'Control taxation, monitor markets, and build specialist economic buildings for wealth!'
    )
  );
  
  // === TAXATION SYSTEM ===
  root.append(el('h3', {style:'margin-top:16px'}, 'üìä Taxation Policy'));
  
  const taxRate = (S.taxationRate || 0.1) * 100;
  const projectedRevenue = calculateTaxRevenue();
  const happinessPenalty = getTaxationHappinessPenalty();
  
  const taxCard = el('div', {class:'card', style:'background:linear-gradient(135deg,#fef3c7,#fde68a);border:2px solid var(--roman-gold);margin:12px 0'});
  
  taxCard.append(
    el('div', {style:'display:flex;justify-content:space-between;align-items:center;margin-bottom:12px'},
      el('div', {},
        el('div', {style:'font-weight:900;font-size:18px;color:var(--roman-red)'}, 
          `Current Tax Rate: ${Math.round(taxRate)}%`
        ),
        el('div', {class:'small', style:'margin-top:4px'}, 
          `Projected Revenue: ${fmt(projectedRevenue)}üí∞/season`
        ),
        el('div', {class:'small', style:'margin-top:4px;color:' + (happinessPenalty > 15 ? '#dc2626' : '#7a3b00')}, 
          `Happiness Impact: -${happinessPenalty}% ${happinessPenalty > 15 ? '‚ö†Ô∏è' : ''}`
        ),
        el('div', {class:'tiny', style:'margin-top:8px;font-style:italic'}, 
          'Lower taxes = happier citizens but less revenue. Higher taxes = more money but unrest!'
        )
      )
    ),
    el('div', {style:'margin-top:12px'},
      el('label', {style:'display:block;margin-bottom:8px;font-weight:700'}, 
        'Adjust Tax Rate (0-30%):'
      ),
      el('input', {
        type:'range',
        min:'0',
        max:'30',
        value:Math.round(taxRate),
        style:'width:100%;cursor:pointer',
        onInput:(e) => {
          const newRate = parseInt(e.target.value) / 100;
          S.taxationRate = newRate;
          render();
        }
      }),
      el('div', {class:'grid g3', style:'margin-top:8px'},
        el('button', {
          class:'btn',
          style:'background:#16a34a;color:#fff',
          onClick:() => { S.taxationRate = 0.05; render(); }
        }, 'üìâ Low (5%)'),
        el('button', {
          class:'btn',
          style:'background:#fbbf24;color:#78350f',
          onClick:() => { S.taxationRate = 0.15; render(); }
        }, '‚öñÔ∏è Balanced (15%)'),
        el('button', {
          class:'btn',
          style:'background:#dc2626;color:#fff',
          onClick:() => { S.taxationRate = 0.25; render(); }
        }, 'üìà High (25%)')
      )
    )
  );
  
  root.append(taxCard);
  
  // === MARKET DYNAMICS ===
  root.append(
    el('div', {class:'divider', style:'margin:24px 0'}),
    el('h3', {}, 'üìà Market Prices & Supply/Demand')
  );
  
  const marketCard = el('div', {class:'card', style:'background:#f9fafb;margin:12px 0'});
  marketCard.append(
    el('div', {class:'info', style:'margin-bottom:12px'},
      'üîÑ Prices fluctuate based on your inventory levels and seasonal demand. High inventory = lower prices. Scarcity = higher prices!'
    )
  );
  
  const marketGrid = el('div', {class:'grid g3'});
  GOODS.forEach(good => {
    const basePrice = good.base;
    const currentPrice = getMarketPrice(good.id, basePrice, 'sell');
    const demandIndex = S.supplyDemand[good.id] || 100;
    const inventoryQty = S.inventory[good.id] || 0;
    
    let priceColor = '#16a34a';
    let priceIndicator = 'üìä';
    let demandText = 'Normal';
    
    if (demandIndex > 130) {
      priceColor = '#16a34a';
      priceIndicator = 'üìà';
      demandText = 'High Demand';
    } else if (demandIndex > 110) {
      priceColor = '#16a34a';
      priceIndicator = '‚ÜóÔ∏è';
      demandText = 'Rising';
    } else if (demandIndex < 70) {
      priceColor = '#dc2626';
      priceIndicator = 'üìâ';
      demandText = 'Oversupply';
    } else if (demandIndex < 90) {
      priceColor = '#f59e0b';
      priceIndicator = '‚ÜòÔ∏è';
      demandText = 'Falling';
    }
    
    const priceChange = currentPrice - basePrice;
    const priceChangeText = priceChange > 0 ? `+${priceChange}` : priceChange;
    
    const goodCard = el('div', {class:'choice', style:`border-color:${priceColor}`});
    goodCard.append(
      el('div', {style:'text-align:center;font-size:28px;margin-bottom:8px'}, good.emoji),
      el('div', {style:'font-weight:800;text-align:center;margin-bottom:4px'}, good.name),
      el('div', {class:'tiny', style:'text-align:center;color:#7a3b00;margin-bottom:8px'}, 
        `Base: ${basePrice}üí∞ | Inventory: ${inventoryQty}`
      ),
      el('div', {style:`text-align:center;font-weight:900;font-size:18px;color:${priceColor};margin-bottom:4px`}, 
        `${priceIndicator} ${currentPrice}üí∞`
      ),
      el('div', {class:'small', style:`text-align:center;color:${priceColor};font-weight:700`}, 
        demandText
      ),
      el('div', {class:'tiny', style:'text-align:center;margin-top:4px;color:#6b7280'}, 
        priceChange !== 0 ? `${priceChangeText}üí∞ from base` : 'At base price'
      )
    );
    marketGrid.append(goodCard);
  });
  
  root.append(marketCard, marketGrid);
  
  // === SPECIALIST ECONOMIC BUILDINGS ===
  root.append(
    el('div', {class:'divider', style:'margin:24px 0'}),
    el('h3', {}, 'üèõÔ∏è Economic Specialist Buildings')
  );
  
  const economicBuildings = TERRITORY_BUILDINGS.filter(b => 
    ['bank', 'merchant_guild', 'grand_market', 'counting_house', 'census_office'].includes(b.id)
  );
  
  root.append(
    el('div', {class:'info', style:'margin-bottom:12px'},
      'Build these special structures in your territories for powerful economic bonuses! Visit the Map tab to construct them.'
    )
  );
  
  // Show which territories have economic buildings
  let economicBuildingsBuilt = [];
  S.territories.forEach(tId => {
    const data = S.territoryData[tId];
    if (data && data.buildings) {
      data.buildings.forEach(bId => {
        if (['bank', 'merchant_guild', 'grand_market', 'counting_house', 'census_office'].includes(bId)) {
          const building = TERRITORY_BUILDINGS.find(b => b.id === bId);
          const territory = TERRITORIES.find(t => t.id === tId);
          if (building && territory) {
            economicBuildingsBuilt.push({building, territory});
          }
        }
      });
    }
  });
  
  if (economicBuildingsBuilt.length > 0) {
    root.append(
      el('h4', {style:'color:var(--roman-red);margin-top:16px'}, '‚úì Active Economic Buildings')
    );
    const activeGrid = el('div', {class:'grid g2', style:'margin-bottom:16px'});
    economicBuildingsBuilt.forEach(({building, territory}) => {
      const card = el('div', {class:'choice', style:'background:linear-gradient(135deg,#dcfce7,#f0fdf4);border-color:#86efac'});
      card.append(
        el('div', {style:'font-weight:900;margin-bottom:4px'}, 
          `${building.icon} ${building.name}`
        ),
        el('div', {class:'tiny', style:'font-style:italic;color:#7a3b00;margin-bottom:4px'}, 
          building.latinName || ''
        ),
        el('div', {class:'small', style:'color:#16a34a;margin-bottom:4px'}, 
          `üìç ${territory.name}`
        ),
        el('div', {class:'tiny'}, building.desc)
      );
      activeGrid.append(card);
    });
    root.append(activeGrid);
  }
  
  // Show all available economic buildings
  root.append(el('h4', {style:'margin-top:16px'}, 'Available Economic Buildings:'));
  const buildingsGrid = el('div', {class:'grid g2'});
  economicBuildings.forEach(building => {
    const hasBuilding = economicBuildingsBuilt.some(b => b.building.id === building.id);
    const card = el('div', {class:'choice', style: hasBuilding ? 'opacity:0.7' : ''});
    
    const effectsList = [];
    if (building.effect.denarii) effectsList.push(`+${building.effect.denarii}üí∞/season`);
    if (building.effect.denariMultiplier) effectsList.push(`+${Math.round((building.effect.denariMultiplier - 1) * 100)}% all income`);
    if (building.effect.tariffReduction) effectsList.push(`-${Math.round(building.effect.tariffReduction * 100)}% tariffs`);
    if (building.effect.priceBonus) effectsList.push(`+${Math.round((building.effect.priceBonus - 1) * 100)}% sell prices`);
    if (building.effect.taxBonus) effectsList.push(`+${Math.round((building.effect.taxBonus - 1) * 100)}% tax efficiency`);
    if (building.effect.productionBonus) effectsList.push(`+${Math.round((building.effect.productionBonus - 1) * 100)}% production`);
    
    card.append(
      el('div', {style:'font-size:32px;text-align:center;margin-bottom:8px'}, building.icon),
      el('div', {style:'font-weight:900;margin-bottom:4px;text-align:center'}, building.name),
      building.latinName ? el('div', {class:'tiny', style:'font-style:italic;color:#7a3b00;text-align:center;margin-bottom:6px'}, 
        building.latinName
      ) : '',
      el('div', {class:'small', style:'margin-bottom:8px'}, building.desc),
      el('div', {class:'small', style:'margin-bottom:8px;color:var(--roman-gold);font-weight:700'}, 
        `Cost: ${fmt(building.cost)}üí∞`
      ),
      el('div', {class:'tiny', style:'color:#16a34a'}, 
        effectsList.map(e => `‚Ä¢ ${e}`).join('\n')
      ),
      hasBuilding ? el('div', {class:'tag', style:'background:#dcfce7;border-color:#86efac;color:#166534;margin-top:8px;width:100%;text-align:center'}, 
        '‚úì Already Built'
      ) : el('button', {
        class:'btn btn-primary',
        style:'margin-top:10px;width:100%',
        onClick:() => {
          alert(`üìç Go to the Map tab and select a territory to build ${building.name}!`);
          S.focus = 'map';
          render();
        }
      }, 'View in Map ‚Üí')
    );
    buildingsGrid.append(card);
  });
  root.append(buildingsGrid);
}

function renderMapFocus(root) {
  root.append(
    el('h2', {}, 'üó∫Ô∏è Territory Map'),
    el('div', {class:'info'},
      'Conquer territories for resources and glory! Each territory has a RARITY and LATIN NAME!'
    )
  );
  
  const mapContainer = el('div', {class:'map-container'});
  
  // Map tabs (pagination)
  const territoriesPerTab = 12;
  const numTabs = Math.ceil(TERRITORIES.length / territoriesPerTab);
  
  if (numTabs > 1) {
    const mapTabs = el('div', {class:'map-tabs'});
    for (let i = 0; i < numTabs; i++) {
      mapTabs.append(
        el('div', {
          class: 'tab' + (S.mapTab === i ? ' active' : ''),
          onClick: () => { S.mapTab = i; render(); }
        }, `Region ${i + 1}`)
      );
    }
    mapContainer.append(mapTabs);
  }
  
  const startIdx = S.mapTab * territoriesPerTab;
  const endIdx = Math.min(startIdx + territoriesPerTab, TERRITORIES.length);
  const territoriesToShow = TERRITORIES.slice(startIdx, endIdx);
  
  const mapGrid = el('div', {class:'map-grid'});
  
  territoriesToShow.forEach(territory => {
    const owned = S.territories.includes(territory.id);
    const canConquer = !owned && territory.status !== 'owned';
    const locked = territory.req && S.territories.length < territory.req;
    
    let bgClass = '';
    if (owned) bgClass = 'owned';
    else if (locked) bgClass = 'locked';
    else if (territory.status === 'contested') bgClass = 'contested';
    else if (territory.str >= 80) bgClass = 'hostile-hard';
    else bgClass = 'hostile';
    
    const territoryDiv = el('div', {
      class: `territory ${bgClass}`,
      onClick: () => {
        if (owned) {
          // Show territory management screen
          showTerritoryDetails(territory.id);
        } else if (locked) {
          alert(`üîí Locked!\nRequires ${territory.req} territories to unlock.`);
        } else if (canConquer) {
          const odds = calculateConquestOdds(territory);
          const rarityText = territory.rarity ? ` [${territory.rarity.name} rarity]` : '';
          const latinText = territory.latinName ? `\n(${territory.latinName})` : '';
          if (confirm(`‚öîÔ∏è Attack ${territory.name}?${latinText}${rarityText}\n\nEnemy Strength: ${territory.str}\nYour Strength: ${Math.floor(odds.ourStr)}\nWin Chance: ${Math.floor(odds.winProb * 100)}%\n\nProceed with conquest?`)) {
            conquestTerritory(territory);
          }
        }
      }
    });
    
    const rarityHTML = territory.rarity ? getRarityBadge(territory.rarity) : '';
    const nameDisplay = territory.name + rarityHTML;
    const latinDisplay = territory.latinName ? `<div class="tiny" style="font-style:italic;color:#7a3b00">${territory.latinName}</div>` : '';
    
    // Dynamic font sizing based on name length
    const nameLength = territory.name.length;
    let fontSize = 13;
    if (nameLength > 20) fontSize = 9;
    else if (nameLength > 16) fontSize = 10;
    else if (nameLength > 12) fontSize = 11;
    else if (nameLength > 8) fontSize = 12;
    
    territoryDiv.append(
      el('div', {style:`font-weight:800;font-size:${fontSize}px;margin-bottom:4px;line-height:1.2`, html:nameDisplay}),
      latinDisplay ? el('div', {html:latinDisplay}) : '',
      el('div', {class:'tiny', style:'font-size:10px;line-height:1.3'}, territory.desc)
    );
    
    if (!owned && !locked) {
      territoryDiv.append(
        el('div', {class:'tiny', style:'margin-top:6px;font-weight:700'}, 
          `‚öîÔ∏è ${territory.str}`
        ),
        el('div', {class:'tiny', style:'font-size:10px'}, 
          `üí∞ ${fmt(territory.value)}d`
        )
      );
    }
    
    if (owned && territory.produces) {
      const productionText = Object.entries(territory.produces)
        .map(([r, a]) => {
          const g = GOODS.find(go => go.id === r);
          return `${(g && g.emoji) || ''} ${a}`;
        }).join(' ');
      territoryDiv.append(
        el('div', {class:'tiny', style:'margin-top:6px;color:#15803d;font-weight:700;font-size:11px'}, 
          '‚úì ' + productionText
        )
      );
    }
    
    mapGrid.append(territoryDiv);
  });
  
  mapContainer.append(
    el('h3', {}, `Controlled: ${S.territories.length}/${TERRITORIES.length} territories | Viewing: ${startIdx + 1}-${endIdx}`),
    mapGrid
  );
  
  root.append(mapContainer);
}

// ==================== TERRITORY MANAGEMENT UI ====================

function showTerritoryDetails(territoryId) {
  // Ensure territory data exists before showing details
  if (!S.territoryData) S.territoryData = {};
  if (!S.territoryData[territoryId]) {
    S.territoryData[territoryId] = {
      level: 1,
      stability: 50,
      happiness: 50,
      garrison: 0,
      buildings: [],
      developmentPath: null,
      governor: null,
      population: 100,
      infrastructure: 0,
      supplyLines: [],
      lastEventRound: 0,
      modifiers: {}
    };
  }
  
  S.selectedTerritory = territoryId;
  S.focus = 'territory_detail';
  render();
}

function renderTerritoryDetail(root) {
  if (!S.selectedTerritory) {
    S.focus = 'map';
    render();
    return;
  }
  
  // Ensure territory data exists
  if (!S.territoryData[S.selectedTerritory]) {
    console.error('Territory data not found for:', S.selectedTerritory);
    S.focus = 'map';
    render();
    return;
  }
  
  const info = getTerritoryInfo(S.selectedTerritory);
  const data = S.territoryData[S.selectedTerritory];
  
  // Header
  root.append(
    el('div', {style:'display:flex;align-items:center;gap:12px;margin-bottom:16px'},
      el('button', {
        class:'btn',
        onClick:() => { S.focus = 'map'; render(); }
      }, '‚Üê Back to Map'),
      el('h2', {style:'margin:0;flex:1'}, `üèõÔ∏è ${info.name}`),
      el('div', {class:'pill'}, `Level ${data.level}: ${info.levelName}`)
    ),
    info.latinName ? el('div', {class:'small', style:'font-style:italic;color:#7a3b00;margin-bottom:12px'}, info.latinName) : ''
  );
  
  // Status Overview Card
  const statusCard = el('div', {class:'card', style:'margin-bottom:16px'});
  statusCard.append(
    el('div', {class:'grid g4'},
      statPill('üìä', 'Stability', `${data.stability||50}%`, data.stability >= 70 ? 'success' : data.stability < 40 ? 'warning' : 'normal'),
      statPill('üòä', 'Happiness', `${data.happiness||50}%`, data.happiness >= 70 ? 'success' : data.happiness < 40 ? 'warning' : 'normal'),
      statPill('üõ°Ô∏è', 'Defense', info.defensePower, info.defensePower >= 50 ? 'success' : 'normal'),
      statPill('üí∞', 'Income', `${info.netIncome}/season`, info.netIncome > 0 ? 'success' : 'normal')
    )
  );
  root.append(statusCard);
  
  // Tabs for different management aspects
  if (!S.territoryTab) S.territoryTab = 'overview';
  
  const tabs = el('div', {class:'tabs', style:'margin-bottom:16px'});
  ['overview', 'buildings', 'garrison', 'development', 'governor'].forEach(tabId => {
    const labels = {
      overview:'üìã Overview',
      buildings:'üèóÔ∏è Buildings',
      garrison:'‚öîÔ∏è Garrison',
      development:'üéØ Development',
      governor:'üëî Governor'
    };
    const tab = el('div', {
      class:'tab' + (S.territoryTab === tabId ? ' active' : ''),
      onClick:() => { S.territoryTab = tabId; render(); }
    }, labels[tabId]);
    tabs.append(tab);
  });
  root.append(tabs);
  
  // Render appropriate tab
  if (S.territoryTab === 'overview') renderTerritoryOverview(root, info, data);
  else if (S.territoryTab === 'buildings') renderTerritoryBuildings(root, info, data);
  else if (S.territoryTab === 'garrison') renderTerritoryGarrison(root, info, data);
  else if (S.territoryTab === 'development') renderTerritoryDevelopment(root, info, data);
  else if (S.territoryTab === 'governor') renderTerritoryGovernor(root, info, data);
}

function renderTerritoryOverview(root, info, data) {
  const card = el('div', {class:'card'});
  
  card.append(
    el('h3', {}, 'üìä Territory Status'),
    el('div', {class:'info'}, info.desc)
  );
  
  // Production
  if (Object.keys(info.totalProduction).length > 0) {
    card.append(el('h4', {style:'margin-top:16px'}, 'üåæ Resource Production'));
    const prodGrid = el('div', {class:'grid g4'});
    
    for (let [resource, amount] of Object.entries(info.totalProduction)) {
      const good = GOODS.find(g => g.id === resource);
      prodGrid.append(
        el('div', {class:'pill', style:'background:#f0fdf4;border-color:#86efac'},
          `${good?.emoji||''} ${amount}/season ${good?.name||resource}`
        )
      );
    }
    card.append(prodGrid);
  }
  
  // Level Upgrade
  const currentLevel = data.level || 1;
  const nextLevel = TERRITORY_LEVELS[currentLevel + 1];
  
  if (nextLevel) {
    card.append(
      el('h4', {style:'margin-top:16px'}, '‚¨ÜÔ∏è Upgrade Territory'),
      el('div', {class:'grid g2'},
        el('div', {class:'info'},
          el('div', {style:'font-weight:800;margin-bottom:6px'}, `Next Level: ${nextLevel.name}`),
          el('div', {class:'small'}, `Production: x${nextLevel.bonuses.production}`),
          el('div', {class:'small'}, `Stability: +${nextLevel.bonuses.stability}`),
          el('div', {class:'small'}, `Cost: ${nextLevel.cost} denarii`)
        ),
        el('div', {style:'display:flex;align-items:center;justify-content:center'},
          el('button', {
            class:'btn btn-success',
            style:'width:100%',
            disabled: S.denarii < nextLevel.cost,
            onClick:() => {
              if (upgradeTerritoryLevel(S.selectedTerritory)) render();
            }
          }, `Upgrade (${fmt(nextLevel.cost)}d)`)
        )
      )
    );
  } else {
    card.append(
      el('div', {class:'info', style:'margin-top:16px;background:linear-gradient(135deg,#fef3c7,#fde68a);border-color:var(--roman-gold)'},
        '‚≠ê Territory is at maximum level!'
      )
    );
  }
  
  root.append(card);
}

function renderTerritoryBuildings(root, info, data) {
  root.append(
    el('h3', {}, 'üèóÔ∏è Territory Buildings'),
    el('div', {class:'info'}, 'Construct specialized buildings to enhance this territory.')
  );
  
  // Existing buildings
  if (data.buildings && data.buildings.length > 0) {
    root.append(el('h4', {style:'margin-top:16px'}, '‚úì Constructed Buildings'));
    const builtGrid = el('div', {class:'grid g3'});
    
    data.buildings.forEach(bId => {
      const building = TERRITORY_BUILDINGS.find(b => b.id === bId);
      if (!building) return;
      
      const buildingCard = el('div', {class:'card', style:'background:#f0fdf4;border-color:#86efac'});
      buildingCard.append(
        el('div', {style:'font-weight:800;margin-bottom:6px'}, `${building.icon} ${building.name}`),
        el('div', {class:'tiny', style:'font-style:italic;color:#7a3b00'}, building.latinName),
        el('div', {class:'small', style:'margin-top:6px'}, building.desc)
      );
      builtGrid.append(buildingCard);
    });
    
    root.append(builtGrid);
  }
  
  // Available buildings
  const availableBuildings = TERRITORY_BUILDINGS.filter(b => !data.buildings?.includes(b.id));
  
  if (availableBuildings.length > 0) {
    root.append(el('h4', {style:'margin-top:16px'}, 'üõí Available Buildings'));
    const buildGrid = el('div', {class:'grid g3'});
    
    availableBuildings.forEach(building => {
      const canAfford = S.denarii >= building.cost;
      const buildingCard = el('div', {
        class:'choice',
        style: canAfford ? '' : 'opacity:0.6'
      });
      
      buildingCard.append(
        el('div', {style:'font-weight:800;margin-bottom:4px'}, `${building.icon} ${building.name}`),
        el('div', {class:'tiny', style:'font-style:italic;color:#7a3b00;margin-bottom:6px'}, building.latinName),
        el('div', {class:'small', style:'margin-bottom:8px'}, building.desc),
        el('div', {class:'tiny', style:'margin-bottom:8px'}, 
          Object.entries(building.effect).map(([k,v]) => `${k}: ${v}`).join(', ')
        ),
        el('button', {
          class:'btn btn-primary',
          style:'width:100%;margin-top:8px',
          disabled: !canAfford,
          onClick:() => {
            if (buildTerritoryBuilding(S.selectedTerritory, building.id)) render();
          }
        }, `Build (${fmt(building.cost)}d)`)
      );
      
      buildGrid.append(buildingCard);
    });
    
    root.append(buildGrid);
  }
}

function renderTerritoryGarrison(root, info, data) {
  const garrisoned = data.garrison || 0;
  const maxGarrison = data.maxGarrison || 50;
  
  root.append(
    el('h3', {}, '‚öîÔ∏è Garrison Management'),
    el('div', {class:'info'}, 
      `Station troops in this territory for defense and stability. Current: ${garrisoned}/${maxGarrison}`
    )
  );
  
  const garrisonCard = el('div', {class:'card', style:'margin-top:16px'});
  
  garrisonCard.append(
    el('div', {class:'grid g2', style:'margin-bottom:16px'},
      statPill('üõ°Ô∏è', 'Garrisoned', garrisoned, garrisoned > 0 ? 'success' : 'warning'),
      statPill('üì¶', 'Available', S.troops, S.troops > 0 ? 'success' : 'warning')
    ),
    el('div', {class:'small', style:'margin-bottom:8px'}, 
      `Defense Power: ${info.defensePower} | Each 10 troops = +10% stability`
    )
  );
  
  // Assign garrison
  const assignCard = el('div', {class:'card', style:'margin:12px 0'});
  const amountInput = el('input', {
    type:'number',
    min:0,
    max:Math.min(S.troops, maxGarrison - garrisoned),
    value:Math.min(10, S.troops, maxGarrison - garrisoned),
    style:'width:100px;padding:6px;border:1px solid var(--line);border-radius:6px;margin:0 8px'
  });
  
  assignCard.append(
    el('div', {style:'display:flex;align-items:center;gap:8px;flex-wrap:wrap'},
      el('div', {}, 'Assign troops:'),
      amountInput,
      el('button', {
        class:'btn btn-success',
        disabled: S.troops === 0 || garrisoned >= maxGarrison,
        onClick:() => {
          const amount = parseInt(amountInput.value) || 0;
          if (amount > 0 && assignGarrison(S.selectedTerritory, amount)) {
            render();
          }
        }
      }, '‚ûï Assign'),
      el('button', {
        class:'btn',
        disabled: garrisoned === 0,
        onClick:() => {
          const amount = parseInt(amountInput.value) || 0;
          if (amount > 0 && recallGarrison(S.selectedTerritory, Math.min(amount, garrisoned))) {
            render();
          }
        }
      }, '‚¨ÖÔ∏è Recall')
    )
  );
  
  garrisonCard.append(assignCard);
  
  // Quick actions
  if (S.troops > 0) {
    garrisonCard.append(
      el('div', {class:'grid g2', style:'margin-top:8px'},
        el('button', {
          class:'btn',
          onClick:() => {
            const amount = Math.min(S.troops, maxGarrison - garrisoned);
            if (amount > 0 && assignGarrison(S.selectedTerritory, amount)) {
              render();
            }
          }
        }, '‚è´ Assign All'),
        garrisoned > 0 ? el('button', {
          class:'btn',
          onClick:() => {
            if (recallGarrison(S.selectedTerritory, garrisoned)) {
              render();
            }
          }
        }, '‚è¨ Recall All') : null
      )
    );
  }
  
  root.append(garrisonCard);
}

function renderTerritoryDevelopment(root, info, data) {
  root.append(
    el('h3', {}, 'üéØ Development Path'),
    el('div', {class:'info'}, 'Choose a specialization path for long-term bonuses.')
  );
  
  // Current path
  if (data.developmentPath) {
    const path = DEVELOPMENT_PATHS[data.developmentPath];
    const pathCard = el('div', {class:'card', style:'background:#f0fdf4;border-color:#86efac;margin-top:16px'});
    
    pathCard.append(
      el('div', {style:'font-weight:900;font-size:18px;margin-bottom:8px'}, 
        `${path.icon} ${path.name}`
      ),
      el('div', {class:'small', style:'margin-bottom:8px'}, 'Active Bonuses:'),
      el('div', {class:'grid g3'},
        ...Object.entries(path.bonuses).map(([k,v]) => 
          el('div', {class:'pill', style:'background:#dcfce7'}, 
            `${k}: ${typeof v === 'number' && v < 10 ? `x${v}` : v}`
          )
        )
      ),
      el('button', {
        class:'btn',
        style:'margin-top:12px',
        onClick:() => {
          if (confirm('Change development path? This will cost 300 denarii.')) {
            data.developmentPath = null;
            render();
          }
        }
      }, 'Change Path (300d)')
    );
    
    root.append(pathCard);
  }
  
  // Available paths
  if (!data.developmentPath) {
    root.append(el('h4', {style:'margin-top:16px'}, 'Choose Development Path:'));
    const pathGrid = el('div', {class:'grid g2'});
    
    Object.entries(DEVELOPMENT_PATHS).forEach(([pathId, path]) => {
      const pathCard = el('div', {class:'choice'});
      
      pathCard.append(
        el('div', {style:'font-weight:900;font-size:16px;margin-bottom:6px'}, 
          `${path.icon} ${path.name}`
        ),
        el('div', {class:'small', style:'margin-bottom:8px;font-weight:700'}, 'Bonuses:'),
        el('div', {style:'margin-bottom:8px'},
          ...Object.entries(path.bonuses).map(([k,v]) => 
            el('div', {class:'tiny'}, `‚Ä¢ ${k}: ${typeof v === 'number' && v < 10 ? `x${v}` : v}`)
          )
        ),
        el('div', {class:'tiny', style:'margin-bottom:8px'}, 
          `Required buildings: ${path.buildings.map(b => TERRITORY_BUILDINGS.find(tb => tb.id === b)?.name).join(', ')}`
        ),
        el('button', {
          class:'btn btn-success',
          style:'width:100%;margin-top:8px',
          onClick:() => {
            if (setDevelopmentPath(S.selectedTerritory, pathId)) render();
          }
        }, 'Select Path')
      );
      
      pathGrid.append(pathCard);
    });
    
    root.append(pathGrid);
  }
}

function renderTerritoryGovernor(root, info, data) {
  root.append(
    el('h3', {}, 'üëî Governor'),
    el('div', {class:'info'}, 'Appoint a skilled governor for special bonuses.')
  );
  
  // Current governor
  if (data.governor) {
    const governor = GOVERNOR_TRAITS.find(g => g.id === data.governor);
    const govCard = el('div', {class:'card', style:'background:#f0fdf4;border-color:#86efac;margin-top:16px'});
    
    govCard.append(
      el('div', {style:'font-weight:900;font-size:18px;margin-bottom:8px'}, 
        `${governor.icon} ${governor.name}`
      ),
      el('div', {class:'small', style:'margin-bottom:8px'}, 'Active Bonuses:'),
      el('div', {class:'grid g3'},
        ...Object.entries(governor.bonus).map(([k,v]) => 
          el('div', {class:'pill', style:'background:#dcfce7'}, 
            `${k}: ${typeof v === 'number' && v < 10 ? `x${v}` : v}`
          )
        )
      ),
      Object.keys(governor.malus).length > 0 ? el('div', {style:'margin-top:8px'},
        el('div', {class:'small', style:'margin-bottom:4px'}, 'Penalties:'),
        el('div', {class:'grid g3'},
          ...Object.entries(governor.malus).map(([k,v]) => 
            el('div', {class:'pill', style:'background:#fee2e2;border-color:#fca5a5'}, 
              `${k}: ${v}`
            )
          )
        )
      ) : null,
      el('button', {
        class:'btn',
        style:'margin-top:12px',
        onClick:() => {
          if (confirm('Replace this governor? You will need to pay to appoint a new one.')) {
            data.governor = null;
            render();
          }
        }
      }, 'Replace Governor')
    );
    
    root.append(govCard);
  }
  
  // Available governors
  if (!data.governor) {
    root.append(el('h4', {style:'margin-top:16px'}, 'Appoint Governor:'));
    const govGrid = el('div', {class:'grid g3'});
    
    GOVERNOR_TRAITS.forEach(governor => {
      const canAfford = S.denarii >= governor.cost;
      const govCard = el('div', {
        class:'choice',
        style: canAfford ? '' : 'opacity:0.6'
      });
      
      govCard.append(
        el('div', {style:'font-weight:900;margin-bottom:4px'}, 
          `${governor.icon} ${governor.name}`
        ),
        el('div', {class:'small', style:'margin-bottom:6px;font-weight:700'}, 'Bonuses:'),
        el('div', {style:'margin-bottom:6px'},
          ...Object.entries(governor.bonus).map(([k,v]) => 
            el('div', {class:'tiny'}, `‚Ä¢ ${k}: ${typeof v === 'number' && v < 10 ? `x${v}` : v}`)
          )
        ),
        Object.keys(governor.malus).length > 0 ? el('div', {style:'margin-bottom:6px'},
          el('div', {class:'tiny', style:'color:#dc2626;font-weight:700'}, 'Penalties:'),
          ...Object.entries(governor.malus).map(([k,v]) => 
            el('div', {class:'tiny', style:'color:#dc2626'}, `‚Ä¢ ${k}: ${v}`)
          )
        ) : null,
        el('button', {
          class:'btn btn-success',
          style:'width:100%;margin-top:8px',
          disabled: !canAfford,
          onClick:() => {
            if (appointGovernor(S.selectedTerritory, governor.id)) render();
          }
        }, `Appoint (${fmt(governor.cost)}d)`)
      );
      
      govGrid.append(govCard);
    });
    
    root.append(govGrid);
  }
}

function renderTradeFocus(root) {
  // Initialize trade state
  if (!S.tradeState) {
    S.tradeState = {
      routes: [], // {cityId, goodId, qty, income, duration}
      contracts: [], // {cityId, goodId, qty, reward, deadline}
      upgrades: {
        guards: 0, // -10% risk per level
        wagons: 0, // +2 goods capacity per level
        negotiation: 0, // +5% prices per level
      },
      priceHistory: {}, // Track price changes
      reputation: {}, // City-specific reputation
      activeCaravan: null, // Current caravan in transit
    };
    // Initialize reputation
    CITIES.forEach(c => S.tradeState.reputation[c.id] = 0);
  }
  
  // Trade sub-tabs
  if (!S.tradeTab) S.tradeTab = 'quick';
  
  const tabs = el('div', {class:'grid g4', style:'margin-bottom:16px'});
  ['quick', 'routes', 'market', 'caravans'].forEach(tabId => {
    const labels = {quick:'üí∞ Quick Trade', routes:'üõ§Ô∏è Trade Routes', market:'üìä Market Intel', caravans:'üê´ Caravans'};
    const btn = el('button', {
      class: 'btn' + (S.tradeTab === tabId ? ' btn-primary' : ''),
      onClick: () => { S.tradeTab = tabId; render(); }
    }, labels[tabId]);
    tabs.append(btn);
  });
  
  root.append(
    el('h2', {}, 'üíº Trade Hub'),
    tabs
  );
  
  // Render appropriate sub-tab
  if (S.tradeTab === 'quick') renderQuickTrade(root);
  else if (S.tradeTab === 'routes') renderTradeRoutes(root);
  else if (S.tradeTab === 'market') renderMarketIntel(root);
  else if (S.tradeTab === 'caravans') renderCaravans(root);
}

// QUICK TRADE (original functionality enhanced)
function renderQuickTrade(root) {
  root.append(
    el('div', {class:'info'},
      'Sell your inventory to cities for immediate profit. Prices vary by city specialty and your reputation.'
    )
  );
  
  const inv = Object.entries(S.inventory).filter(([k,v]) => v > 0);
  if (inv.length === 0) {
    root.append(
      el('div', {class:'info', style:'background:#fef2f2;border-color:#fca5a5'},
        '‚ö†Ô∏è No goods in inventory. Build production facilities or wait for season production.'
      )
    );
    return;
  }
  
  // Trade upgrades section
  const upgradeBox = el('div', {class:'card', style:'margin:12px 0;padding:12px'});
  upgradeBox.append(el('h3', {}, 'üîß Trade Upgrades'));
  
  const upgradeGrid = el('div', {class:'grid g3'});
  const upgrades = [
    {id:'guards', name:'Caravan Guards', cost:200, icon:'üõ°Ô∏è', desc:'-10% trade risk'},
    {id:'wagons', name:'Better Wagons', cost:300, icon:'üõí', desc:'+2 goods per trade'},
    {id:'negotiation', name:'Negotiation', cost:250, icon:'ü§ù', desc:'+5% sale prices'},
  ];
  
  upgrades.forEach(up => {
    const level = S.tradeState.upgrades[up.id] || 0;
    const cost = Math.floor(up.cost * Math.pow(1.5, level));
    const canAfford = S.denarii >= cost;
    
    const box = el('div', {class:'choice', style: !canAfford ? 'opacity:0.6' : ''});
    box.append(
      el('div', {style:'font-weight:800'}, `${up.icon} ${up.name}`),
      el('div', {class:'small'}, `Level ${level}`),
      el('div', {class:'tiny'}, up.desc),
      el('button', {
        class:'btn btn-success',
        style:'margin-top:8px;width:100%',
        disabled: !canAfford,
        onClick: () => {
          if (S.denarii < cost) return;
          S.denarii -= cost;
          S.tradeState.upgrades[up.id]++;
          render();
        }
      }, `Upgrade: ${fmt(cost)}d`)
    );
    upgradeGrid.append(box);
  });
  upgradeBox.append(upgradeGrid);
  root.append(upgradeBox);
  
  // Cities grid
  root.append(el('h3', {style:'margin-top:16px'}, 'üèõÔ∏è Available Markets'));
  const sellGrid = el('div', {class:'grid g3'});
  
  CITIES.forEach(city => {
    const box = el('div', {class:'choice'});
    const rep = S.tradeState.reputation[city.id] || 0;
    const repBonus = Math.floor(rep / 10) * 5;
    
    box.append(
      el('h3', {style:'margin:4px 0'}, city.name),
      el('div', {class:'tiny'}, `Specialty: ${capitalize(city.specialty)}`),
      el('div', {class:'tiny'}, `Reputation: ${rep >= 0 ? '+' : ''}${rep} (${repBonus >= 0 ? '+' : ''}${repBonus}% price)`),
      el('div', {class:'tiny'}, `Risk: ${Math.round(getTradeRisk(city.id)*100)}%`)
    );
    
    const prices = inv.slice(0, 3).map(([gid, qty]) => {
      const good = GOODS.find(g => g.id === gid);
      const price = getTradePrice(gid, city.id);
      return el('div', {class:'tiny'}, `${good.emoji} ${good.name}: ${price}d ea.`);
    });
    
    box.append(...prices);
    
    const btn = el('button', {
      class:'btn btn-primary',
      style:'margin-top:8px;width:100%',
      onClick: () => quickTrade(city)
    }, 'Sell Here');
    
    box.append(btn);
    sellGrid.append(box);
  });
  
  root.append(sellGrid);
}

// TRADE ROUTES - Passive income system
function renderTradeRoutes(root) {
  root.append(
    el('div', {class:'info'},
      'Establish permanent trade routes for passive income. Routes require goods each season but generate steady profits.'
    )
  );
  
  // Active routes
  const activeRoutes = S.tradeState.routes;
  if (activeRoutes.length > 0) {
    root.append(el('h3', {}, 'üì¶ Active Trade Routes'));
    const routeGrid = el('div', {class:'grid g2'});
    
    activeRoutes.forEach((route, idx) => {
      const city = CITIES.find(c => c.id === route.cityId);
      const good = GOODS.find(g => g.id === route.goodId);
      const routeBox = el('div', {class:'card', style:'padding:12px'});
      
      routeBox.append(
        el('div', {style:'font-weight:800'}, `${city.name} ‚Üî Rome`),
        el('div', {class:'small'}, `${good.emoji} ${good.name}: ${route.qty}/season`),
        el('div', {class:'small'}, `Income: ${fmt(route.income)}d/season`),
        el('div', {class:'small'}, `Duration: ${route.duration} seasons left`),
        el('button', {
          class:'btn',
          style:'margin-top:8px;width:100%',
          onClick: () => {
            S.tradeState.routes.splice(idx, 1);
            render();
          }
        }, '‚ùå Cancel Route')
      );
      routeGrid.append(routeBox);
    });
    root.append(routeGrid);
  }
  
  // Establish new route
  root.append(el('h3', {style:'margin-top:16px'}, '‚ûï Establish New Route'));
  
  const inv = Object.entries(S.inventory).filter(([k,v]) => v >= 5);
  if (inv.length === 0) {
    root.append(
      el('div', {class:'info', style:'background:#fef2f2;border-color:#fca5a5'},
        '‚ö†Ô∏è Need at least 5 units of a good to establish a route.'
      )
    );
    return;
  }
  
  const routeGrid = el('div', {class:'grid g3'});
  
  CITIES.forEach(city => {
    inv.forEach(([gid, qty]) => {
      const good = GOODS.find(g => g.id === gid);
      const price = getTradePrice(gid, city.id);
      const routeQty = 3;
      const income = Math.floor(price * routeQty * 0.8); // 80% efficiency
      const cost = 500;
      
      const box = el('div', {class:'choice'});
      box.append(
        el('div', {style:'font-weight:800'}, `${city.name}`),
        el('div', {class:'small'}, `${good.emoji} ${good.name} Route`),
        el('div', {class:'tiny'}, `Cost: ${fmt(cost)}d upfront`),
        el('div', {class:'tiny'}, `Sends: ${routeQty} ${good.name}/season`),
        el('div', {class:'tiny'}, `Returns: ${fmt(income)}d/season`),
        el('div', {class:'tiny'}, `Duration: 10 seasons`),
        el('button', {
          class:'btn btn-success',
          style:'margin-top:8px;width:100%',
          disabled: S.denarii < cost,
          onClick: () => {
            if (S.denarii < cost) return alert('Not enough denarii');
            S.denarii -= cost;
            S.tradeState.routes.push({
              cityId: city.id,
              goodId: gid,
              qty: routeQty,
              income: income,
              duration: 10
            });
            alert(`‚úì Trade route established with ${city.name}!`);
            render();
          }
        }, 'Establish Route')
      );
      routeGrid.append(box);
    });
  });
  
  root.append(routeGrid);
}

// MARKET INTEL - Price tracking and commodity info
function renderMarketIntel(root) {
  root.append(
    el('div', {class:'info'},
      'Track market prices, demand trends, and commodity information across all cities.'
    )
  );
  
  // Price comparison table
  root.append(el('h3', {}, 'üìä Price Comparison'));
  
  const priceTable = el('div', {style:'overflow-x:auto'});
  const table = el('table', {style:'width:100%;border-collapse:collapse'});
  
  // Header
  const thead = el('thead');
  const headerRow = el('tr');
  headerRow.append(
    el('th', {style:'border:1px solid var(--line);padding:8px;text-align:left'}, 'Good'),
    ...CITIES.map(c => 
      el('th', {style:'border:1px solid var(--line);padding:8px;text-align:center'}, c.name)
    )
  );
  thead.append(headerRow);
  table.append(thead);
  
  // Body - prices for each good
  const tbody = el('tbody');
  GOODS.forEach(good => {
    const row = el('tr');
    row.append(
      el('td', {style:'border:1px solid var(--line);padding:8px'}, `${good.emoji} ${good.name}`)
    );
    
    CITIES.forEach(city => {
      const price = getTradePrice(good.id, city.id);
      const isSpecialty = city.specialty === good.id;
      const cellStyle = isSpecialty 
        ? 'border:1px solid var(--line);padding:8px;text-align:center;background:#fef3c7;font-weight:800'
        : 'border:1px solid var(--line);padding:8px;text-align:center';
      
      row.append(
        el('td', {style:cellStyle}, `${price}d${isSpecialty ? ' ‚≠ê' : ''}`)
      );
    });
    tbody.append(row);
  });
  table.append(tbody);
  priceTable.append(table);
  root.append(priceTable);
  
  // Inventory overview
  root.append(el('h3', {style:'margin-top:16px'}, 'üì¶ Your Inventory'));
  const invGrid = el('div', {class:'grid g4'});
  
  Object.entries(S.inventory).forEach(([gid, qty]) => {
    if (qty === 0) return;
    const good = GOODS.find(g => g.id === gid);
    const avgPrice = Math.floor(CITIES.reduce((sum, c) => sum + getTradePrice(gid, c.id), 0) / CITIES.length);
    const totalValue = avgPrice * qty;
    
    const box = el('div', {class:'choice'});
    box.append(
      el('div', {style:'font-size:32px;text-align:center'}, good.emoji),
      el('div', {style:'font-weight:800;text-align:center'}, good.name),
      el('div', {class:'small', style:'text-align:center'}, `Quantity: ${qty}`),
      el('div', {class:'tiny', style:'text-align:center'}, `Avg Price: ${avgPrice}d`),
      el('div', {class:'tiny', style:'text-align:center;font-weight:800;color:var(--settlement-color)'}, 
        `Total: ${fmt(totalValue)}d`)
    );
    invGrid.append(box);
  });
  root.append(invGrid);
}

// CARAVANS - Special expeditions
function renderCaravans(root) {
  root.append(
    el('div', {class:'info'},
      'Send specialized caravans on trading expeditions. Higher risks mean higher rewards!'
    )
  );
  
  // Active caravan status
  if (S.tradeState.activeCaravan) {
    const caravan = S.tradeState.activeCaravan;
    root.append(
      el('div', {class:'info', style:'background:#dbeafe;border-color:#60a5fa'},
        `üê´ Caravan in transit to ${caravan.cityName}... Returns in ${caravan.duration} seasons.`
      )
    );
    return;
  }
  
  const inv = Object.entries(S.inventory).filter(([k,v]) => v > 0);
  if (inv.length === 0) {
    root.append(
      el('div', {class:'info', style:'background:#fef2f2;border-color:#fca5a5'},
        '‚ö†Ô∏è No goods to send with caravans.'
      )
    );
    return;
  }
  
  // Caravan types
  const caravanTypes = [
    {
      id: 'safe',
      name: 'Safe Caravan',
      icon: 'üõ°Ô∏è',
      risk: 0.03,
      reward: 1.1,
      duration: 2,
      cost: 100,
      desc: 'Low risk, low reward. Guards protect cargo.'
    },
    {
      id: 'standard',
      name: 'Standard Caravan',
      icon: 'üê´',
      risk: 0.15,
      reward: 1.4,
      duration: 1,
      cost: 50,
      desc: 'Balanced risk and reward.'
    },
    {
      id: 'risky',
      name: 'Fast Caravan',
      icon: '‚ö°',
      risk: 0.30,
      reward: 2.0,
      duration: 1,
      cost: 75,
      desc: 'High risk through dangerous routes, massive profits!'
    },
    {
      id: 'luxury',
      name: 'Luxury Caravan',
      icon: 'üíé',
      risk: 0.10,
      reward: 2.5,
      duration: 3,
      cost: 300,
      desc: 'Premium goods fetch premium prices. Takes time.'
    }
  ];
  
  const caravanGrid = el('div', {class:'grid g2'});
  
  caravanTypes.forEach(type => {
    const box = el('div', {class:'card', style:'padding:12px'});
    
    box.append(
      el('div', {style:'font-weight:800;font-size:18px'}, `${type.icon} ${type.name}`),
      el('div', {class:'small', style:'margin:8px 0'}, type.desc),
      el('div', {class:'tiny'}, `Risk: ${Math.round(type.risk * 100)}%`),
      el('div', {class:'tiny'}, `Reward: ${Math.round((type.reward - 1) * 100)}% bonus`),
      el('div', {class:'tiny'}, `Duration: ${type.duration} seasons`),
      el('div', {class:'tiny'}, `Cost: ${fmt(type.cost)}d`)
    );
    
    // City selection
    const citySelect = el('select', {
      class:'btn',
      style:'margin-top:8px;width:100%'
    });
    citySelect.append(el('option', {value:''}, 'Select City...'));
    CITIES.forEach(city => {
      citySelect.append(el('option', {value:city.id}, city.name));
    });
    
    const sendBtn = el('button', {
      class:'btn btn-success',
      style:'margin-top:8px;width:100%',
      disabled: S.denarii < type.cost,
      onClick: () => sendCaravan(type, citySelect.value)
    }, 'Send Caravan');
    
    box.append(citySelect, sendBtn);
    caravanGrid.append(box);
  });
  
  root.append(caravanGrid);
}

// Helper: Get trade price with all modifiers
function getTradePrice(goodId, cityId) {
  const city = CITIES.find(c => c.id === cityId);
  const good = GOODS.find(g => g.id === goodId);
  if (!city || !good) return 0;
  
  const bias = city.bias && city.bias[goodId] ? city.bias[goodId] : 0;
  let price = good.base + bias;
  
  // === APPLY DYNAMIC MARKET PRICING ===
  // Get market-adjusted price based on supply/demand
  const marketPrice = getMarketPrice(goodId, good.base, 'sell');
  price = marketPrice + bias;
  
  // Apply upgrades
  const negLevel = S.tradeState?.upgrades?.negotiation || 0;
  price *= (1 + negLevel * 0.05);
  
  // Apply reputation bonus
  const rep = S.tradeState?.reputation?.[cityId] || 0;
  const repBonus = Math.floor(rep / 10) * 0.05;
  price *= (1 + repBonus);
  
  // Other modifiers
  if (S.mods && S.mods.sellMul) price *= S.mods.sellMul;
  if (S.techs?.market) price *= 1.05;
  
  // Apply merchant guild and economic building bonuses
  S.territories.forEach(tId => {
    const data = S.territoryData[tId];
    if (data && data.buildings) {
      if (data.buildings.includes('merchant_guild')) {
        price *= 1.05; // Merchant guild bonus already applied in getMarketPrice, but stack it
      }
    }
  });
  
  return Math.floor(price);
}

// Helper: Get trade risk with modifiers
function getTradeRisk(cityId) {
  const city = CITIES.find(c => c.id === cityId);
  if (!city) return 0.1;
  
  let risk = city.risk;
  
  // Apply upgrades
  const guardLevel = S.tradeState?.upgrades?.guards || 0;
  risk *= (1 - guardLevel * 0.10);
  
  // Apply tech/perks
  if (S.proc_perk_risk) risk *= S.proc_perk_risk;
  
  return Math.max(0.01, risk);
}

// Send caravan expedition
function sendCaravan(type, cityId) {
  if (!cityId) return alert('Select a city first!');
  if (S.denarii < type.cost) return alert('Not enough denarii!');
  
  const city = CITIES.find(c => c.id === cityId);
  const inv = Object.entries(S.inventory).filter(([k,v]) => v > 0);
  
  if (inv.length === 0) return alert('No goods to send!');
  
  // Deduct cost
  S.denarii -= type.cost;
  
  // Set active caravan
  S.tradeState.activeCaravan = {
    type: type.id,
    cityId: cityId,
    cityName: city.name,
    risk: type.risk,
    reward: type.reward,
    duration: type.duration,
    goods: inv.map(([gid, qty]) => ({gid, qty: Math.min(qty, 5)}))
  };
  
  // Remove goods from inventory
  S.tradeState.activeCaravan.goods.forEach(g => {
    S.inventory[g.gid] -= g.qty;
  });
  
  alert(`üê´ Caravan sent to ${city.name}! Returns in ${type.duration} seasons.`);
  render();
}

function quickTrade(city) {
  const inv = Object.entries(S.inventory).filter(([k,v]) => v > 0);
  if (inv.length === 0) return alert('No goods to sell');
  
  const maxGoods = 4 + (S.tradeState?.upgrades?.wagons || 0) * 2;
  
  let totalRevenue = 0;
  let soldGoods = [];
  inv.slice(0, maxGoods).forEach(([gid, qty]) => {
    const sellQty = Math.min(qty, 5);
    const price = getTradePrice(gid, city.id);
    totalRevenue += price * sellQty;
    S.inventory[gid] -= sellQty;
    soldGoods.push({good: GOODS.find(g => g.id === gid).name, qty: sellQty});
  });
  
  const risk = getTradeRisk(city.id);
  const success = Math.random() > risk;
  
  if (success) {
    let finalRevenue = totalRevenue;
    if (S.questTradeBuff) finalRevenue *= S.questTradeBuff;
    if (S.comboTradeBuff) finalRevenue *= S.comboTradeBuff;
    if (S.permanentTradeBuff) finalRevenue *= S.permanentTradeBuff;
    
    const tariff = city.tariff * (S.mods && S.mods.tariffMul ? S.mods.tariffMul : 1);
    
    // Apply tariff reductions from economic buildings and development paths
    let tariffReduction = 0;
    S.territories.forEach(tId => {
      const data = S.territoryData[tId];
      if (data && data.buildings) {
        if (data.buildings.includes('merchant_guild')) {
          tariffReduction = Math.max(tariffReduction, 0.15);
        }
      }
      if (data && data.developmentPath === 'economic') {
        const path = DEVELOPMENT_PATHS['economic'];
        if (path && path.bonuses.tariffReduction) {
          tariffReduction = Math.max(tariffReduction, path.bonuses.tariffReduction);
        }
      }
    });
    
    const effectiveTariff = Math.max(0, tariff - tariffReduction);
    finalRevenue = Math.floor(finalRevenue * (1 - effectiveTariff));
    
    // Apply banking multiplier to income
    const bankingMult = getBankingMultiplier();
    if (bankingMult > 1.0) {
      finalRevenue = Math.floor(finalRevenue * bankingMult);
    }
    
    S.denarii += finalRevenue;
    S.reputation += 4;
    S.favor += Math.floor(finalRevenue / 400);
    
    // Improve city reputation
    if (!S.tradeState.reputation[city.id]) S.tradeState.reputation[city.id] = 0;
    S.tradeState.reputation[city.id] += 2;
    
    let msg = `‚úì Trade successful!\n\nSold:\n`;
    soldGoods.forEach(s => msg += `  ${s.qty}√ó ${s.good}\n`);
    msg += `\nEarned: ${fmt(finalRevenue)} denarii\nReputation +2 with ${city.name}`;
    alert(msg);
  } else {
    S.tradeState.reputation[city.id] = (S.tradeState.reputation[city.id] || 0) - 1;
    alert(`‚úó Trade caravan raided! Goods lost.\n\nReputation -1 with ${city.name}`);
    S.happiness = Math.max(0, S.happiness - 5);
  }
  
  S.history.push({
    round: S.round + 1,
    kind: 'Trade',
    action: city.name,
    note: success ? `Sold for ${fmt(totalRevenue)}d` : 'Raided'
  });
  
  endSeason();
}

function renderMilitaryFocus(root) {
  root.append(
    el('h2', {}, '‚öîÔ∏è Military'),
    el('div', {class:'info'},
      `Troops: ${S.troops} | Morale: ${Math.round(S.morale)}% | Supplies: ${S.supplies}`
    )
  );
  
  // Training & Equipment section
  root.append(
    el('h3', {style:'margin-top:16px'}, 'üõ°Ô∏è Training & Equipment'),
    el('div', {class:'grid g3'},
      // Drill
      (() => {
        const disabled = S.food < 10;
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, 'üõ°Ô∏è Drill'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Train your troops to boost morale'),
          el('div', {class:'small', style:'margin:3px 0'}, '+10-15 morale'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Cost: 10 food'),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              if (S.food < 10) return alert('Need 10 food');
              const delta = 10 + Math.floor(Math.random() * 6);
              S.food -= 10;
              S.morale = clamp(S.morale + delta, 0, 100);
              alert(`Morale increased by ${delta}%!`);
              render();
            }
          }, 'Drill' + (disabled ? ' (locked)' : ''))
        );
        return box;
      })(),
      // Forge
      (() => {
        const disabled = S.denarii < 140;
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, '‚öíÔ∏è Forge'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Forge equipment and supplies'),
          el('div', {class:'small', style:'margin:3px 0'}, '+20 supplies'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Cost: 140 denarii'),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              let cost = S.techs.forge ? 110 : 140;
              if (S.mods && S.mods.buildCost) cost = Math.floor(cost * S.mods.buildCost);
              if (S.denarii < cost) return alert(`Need ${cost}d`);
              S.denarii -= cost;
              S.supplies = Math.min(300, S.supplies + 20);
              alert(`Forged +20 supplies!`);
              render();
            }
          }, 'Forge' + (disabled ? ' (locked)' : ''))
        );
        return box;
      })()
    )
  );
  
  // Military Unit Recruitment section
  root.append(
    el('h3', {style:'margin-top:16px'}, '‚öîÔ∏è Recruit Military Units'),
    el('div', {class:'info', style:'margin-bottom:8px'},
      'Different units have varying costs and troop yields. Choose wisely based on your resources!'
    )
  );
  
  const unitsGrid = el('div', {class:'grid g3'});
  
  MILITARY_UNITS.forEach(unit => {
    const inflationMult = getInflationMultiplier();
    let costDenarii = unit.costDenarii;
    let costFood = unit.costFood;
    
    if (S.mods && S.mods.recruitCost) {
      costDenarii = Math.floor(costDenarii * S.mods.recruitCost);
    }
    costDenarii = Math.floor(costDenarii * inflationMult);
    
    const disabled = S.denarii < costDenarii || S.food < costFood;
    const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
    
    box.append(
      el('div', {style:'font-weight:800;margin-bottom:6px;font-size:14px'}, `${unit.icon} ${unit.name}`),
      el('div', {class:'small', style:'margin:3px 0;line-height:1.4'}, unit.desc),
      el('div', {class:'small', style:'margin:3px 0;color:#16a34a;font-weight:700'}, 
        `+${unit.troopsMin}-${unit.troopsMax} troops`),
      el('div', {class:'small', style:'margin:3px 0;color:#dc2626'}, 
        `Cost: ${costDenarii}üí∞ ${costFood}üåæ`),
      el('button', {
        class:'btn btn-primary',
        style:'margin-top:10px;width:100%',
        disabled: disabled,
        onClick: disabled ? null : () => {
          if (S.denarii < costDenarii || S.food < costFood) {
            return alert(`Need ${costDenarii}d and ${costFood} food`);
          }
          S.denarii -= costDenarii;
          S.food -= costFood;
          const recruited = unit.troopsMin + Math.floor(Math.random() * (unit.troopsMax - unit.troopsMin + 1));
          S.troops += recruited;
          alert(`${unit.icon} Recruited ${recruited} ${unit.name}!`);
          render();
        }
      }, disabled ? 'üîí Locked' : 'Recruit')
    );
    
    unitsGrid.append(box);
  });
  
  root.append(unitsGrid);
}

function renderSettlementFocus(root) {
  root.append(
    el('h2', {}, 'üèòÔ∏è Settlement'),
    el('div', {class:'info'},
      `Population: ${S.pop} | Housing: ${S.housing} | Sanitation: ${Math.round(S.sanitation)}%`
    )
  );
  
  root.append(
    el('div', {class:'grid g3'},
      // Housing
      (() => {
        const disabled = S.denarii < 170;
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, 'üèöÔ∏è Housing'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Build housing for your people'),
          el('div', {class:'small', style:'margin:3px 0'}, '+35 housing capacity'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Cost: 170 denarii'),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              let cost = 170;
              if (S.mods && S.mods.buildCost) cost = Math.floor(cost * S.mods.buildCost);
              if (S.denarii < cost) return alert(`Need ${cost}d`);
              S.denarii -= cost;
              S.housing = Math.min(10000, S.housing + 35);
              recalcHappiness();
              alert('Built housing for +35 capacity!');
              render();
            }
          }, 'Build' + (disabled ? ' (locked)' : ''))
        );
        return box;
      })(),
      // Sanitation
    // Warehouse (Inventory Capacity)
    (() => {
      const disabled = S.denarii < 130;
      const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
      box.append(
        el('div', {style:'font-weight:600;margin-bottom:6px'}, 'üì¶ Warehouse'),
        el('div', {class:'small', style:'margin:3px 0'}, 'Expand storage capacity across your realm'),
        el('div', {class:'small', style:'margin:3px 0'}, '+40 capacity (scaled by regions)'),
        el('div', {class:'small', style:'margin:3px 0'}, 'Cost: 130 denarii'),
        el('button', {
          class:'btn btn-primary',
          style:'margin-top:10px;width:100%',
          disabled: disabled,
          onClick: disabled ? null : () => {
            let cost = 130;
            if (S.mods && S.mods.buildCost) cost = Math.floor(cost * S.mods.buildCost);
            if (S.denarii < cost) return alert(`Need ${cost}d`);
            S.denarii -= cost;
            S.buildingCounts = S.buildingCounts || {};
            S.buildingCounts.warehouse = (S.buildingCounts.warehouse||0) + 1;
            if (window.CapSystem) CapSystem.computeCaps();
            alert('Built Warehouse (+40 base capacity, scaled by regions)');
            render();
          }
        }, 'Build' + (disabled ? ' (locked)' : ''))
      );
      return box;
    })(),
    
      (() => {
        const disabled = S.denarii < 95;
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, 'üöΩ Sanitation'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Improve sanitation and health'),
          el('div', {class:'small', style:'margin:3px 0'}, '+12 sanitation'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Cost: 95 denarii'),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              let cost = 95;
              if (S.mods && S.mods.buildCost) cost = Math.floor(cost * S.mods.buildCost);
              if (S.denarii < cost) return alert(`Need ${cost}d`);
              const cap = (window.CapSystem ? CapSystem.getCap('sanitation') : (S.maxSanitation||100));
              if (S.sanitation >= cap) return alert('Max reached');
              S.denarii -= cost;
              S.buildingCounts = S.buildingCounts || {}; S.buildingCounts.bath = (S.buildingCounts.bath||0)+1;
              const gain = Math.max(1, Math.round(12 * (window.CapSystem ? CapSystem.regionScale() : 1)));
              S.sanitation = Math.min(cap, S.sanitation + gain);
              recalcHappiness();
              alert(`Improved sanitation by +${gain}%!`);
              if (window.CapSystem) CapSystem.computeCaps();
              render();
            }
          }, 'Build' + (disabled ? ' (locked)' : ''))
        );
        return box;
      })(),
      // Fort
      (() => {
        const disabled = S.denarii < 220;
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, 'ü™µ Palisade'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Build defensive fortifications'),
          el('div', {class:'small', style:'margin:3px 0'}, '+1 fort, +3 morale'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Cost: 220 denarii'),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              let cost = 220;
              if (S.mods && S.mods.buildCost) cost = Math.floor(cost * S.mods.buildCost);
              if (S.denarii < cost) return alert(`Need ${cost}d`);
              if (S.forts >= 10000) return alert('Max forts');
              S.denarii -= cost;
              S.forts++;
              S.morale += 3;
              recalcHappiness();
              alert('Built a new fort! +3% morale');
              render();
            }
          }, 'Build' + (disabled ? ' (locked)' : ''))
        );
        return box;
      })(), // end Palisade

      // Marketplace (enhances trade through settlement)
      (() => {
        const baseCost = 200;
        let cost = baseCost;
        // Apply any build cost modifiers
        if (S.mods && S.mods.buildCost) cost = Math.floor(baseCost * S.mods.buildCost);
        const disabled = S.denarii < cost;
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, 'üè¶ Marketplace'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Stimulate trade and economic activity'),
          el('div', {class:'small', style:'margin:3px 0'}, '+5% trade revenue, -2% tariffs'),
          el('div', {class:'small', style:'margin:3px 0'}, `Cost: ${cost} denarii`),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              if (S.denarii < cost) return alert(`Need ${cost}d`);
              S.denarii -= cost;
              S.buildingCounts = S.buildingCounts || {};
              S.buildingCounts.market = (S.buildingCounts.market || 0) + 1;
              // Apply trade bonuses: boost sell multiplier and reduce tariff multiplier
              S.mods = S.mods || {};
              const sellMul = (typeof S.mods.sellMul === 'number' ? S.mods.sellMul : 1);
              const tariffMul = (typeof S.mods.tariffMul === 'number' ? S.mods.tariffMul : 1);
              S.mods.sellMul = sellMul * 1.05;
              S.mods.tariffMul = tariffMul * 0.98;
              recalcHappiness();
              alert('Marketplace built! Trade revenue up 5%, tariffs reduced 2%');
              render();
            }
          }, 'Build' + (disabled ? ' (locked)' : ''))
        );
        return box;
      })(),

      // Barracks (connects settlement to military)
      (() => {
        const baseCost = 200;
        let cost = baseCost;
        if (S.mods && S.mods.buildCost) cost = Math.floor(baseCost * S.mods.buildCost);
        const disabled = S.denarii < cost;
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, 'üèπ Barracks'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Train and house your soldiers'),
          el('div', {class:'small', style:'margin:3px 0'}, '+2 attack, -5% recruit cost, +2 morale'),
          el('div', {class:'small', style:'margin:3px 0'}, `Cost: ${cost} denarii`),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              if (S.denarii < cost) return alert(`Need ${cost}d`);
              S.denarii -= cost;
              S.buildingCounts = S.buildingCounts || {};
              S.buildingCounts.barracks = (S.buildingCounts.barracks || 0) + 1;
              // Apply military bonuses: attack and recruit cost improvements
              S.mods = S.mods || {};
              S.mods.attackBonus = (typeof S.mods.attackBonus === 'number' ? S.mods.attackBonus : 0) + 2;
              const recruitCostMul = (typeof S.mods.recruitCost === 'number' ? S.mods.recruitCost : 1);
              S.mods.recruitCost = recruitCostMul * 0.95;
              S.morale += 2;
              recalcHappiness();
              alert('Barracks built! Attack +2, recruit cost -5%, morale +2');
              render();
            }
          }, 'Build' + (disabled ? ' (locked)' : ''))
        );
        return box;
      })(),

      // Granary (connects settlement to resources)
      (() => {
        const baseCost = 150;
        let cost = baseCost;
        if (S.mods && S.mods.buildCost) cost = Math.floor(baseCost * S.mods.buildCost);
        const disabled = S.denarii < cost;
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, 'üåæ Granary'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Store surplus grain and improve production'),
          el('div', {class:'small', style:'margin:3px 0'}, '+5% resource production, +50 max food'),
          el('div', {class:'small', style:'margin:3px 0'}, `Cost: ${cost} denarii`),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              if (S.denarii < cost) return alert(`Need ${cost}d`);
              S.denarii -= cost;
              S.buildingCounts = S.buildingCounts || {};
              S.buildingCounts.granary = (S.buildingCounts.granary || 0) + 1;
              S.mods = S.mods || {};
              const prodBonus = (typeof S.mods.productionBonus === 'number' ? S.mods.productionBonus : 1);
              S.mods.productionBonus = prodBonus * 1.05;
              // Increase maximum food storage
              if (typeof S.maxFood === 'number') S.maxFood += 50;
              recalcHappiness();
              alert('Granary built! Production +5%, max food +50');
              render();
            }
          }, 'Build' + (disabled ? ' (locked)' : ''))
        );
        return box;
      })(),

      // Shrine (connects settlement to religion)
      (() => {
        const baseCost = 160;
        let cost = baseCost;
        if (S.mods && S.mods.buildCost) cost = Math.floor(baseCost * S.mods.buildCost);
        const disabled = S.denarii < cost;
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, '‚õ™ Shrine'),
          el('div', {class:'small', style:'margin:3px 0'}, 'Offer worship and seek divine favor'),
          el('div', {class:'small', style:'margin:3px 0'}, '+100 max piety, +5% happiness multiplier'),
          el('div', {class:'small', style:'margin:3px 0'}, `Cost: ${cost} denarii`),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              if (S.denarii < cost) return alert(`Need ${cost}d`);
              S.denarii -= cost;
              S.buildingCounts = S.buildingCounts || {};
              S.buildingCounts.shrine = (S.buildingCounts.shrine || 0) + 1;
              S.mods = S.mods || {};
              // Increase happiness multiplier
              const happinessMul = (typeof S.mods.happinessMul === 'number' ? S.mods.happinessMul : 1);
              S.mods.happinessMul = happinessMul * 1.05;
              // Increase maximum piety capacity
              if (typeof S.maxPiety === 'number') S.maxPiety += 100;
              recalcHappiness();
              alert('Shrine built! Max piety +100 and happiness increased');
              render();
            }
          }, 'Build' + (disabled ? ' (locked)' : ''))
        );
        return box;
      })()
    )
  );
}

function renderTechnologies(root) {
  root.append(
    el('h2', {}, 'üî¨ Technologies'),
    el('div', {class:'grid g3'},
      ...TECHNOLOGIES.map(tech => {
        const unlocked = S.techs[tech.id];
        const canUnlock = !unlocked && checkTechRequirements(tech);
        const disabled = unlocked || !canUnlock || S.denarii < tech.cost;
        
        const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
        box.append(
          el('div', {style:'font-weight:800;margin-bottom:6px'}, tech.name + (unlocked ? ' ‚úì' : '')),
          el('div', {class:'small', style:'margin:4px 0'}, tech.desc),
          el('div', {class:'tiny', style:'margin:4px 0;color:#7a3b00'}, formatRequirements(tech.req)),
          el('button', {
            class:'btn btn-primary',
            style:'margin-top:10px;width:100%',
            disabled: disabled,
            onClick: disabled ? null : () => {
              if (!checkTechRequirements(tech)) return alert('Requirements not met');
              S.denarii -= tech.cost;
              S.techs[tech.id] = true;
// apply any perks associated with this tech
applyTechPerk(tech || (TECHNOLOGIES.find(t=>t.id===id)));
              if (tech.id === 'market') S.capacity += 10;
              if (tech.id === 'roads') S.capacity += 20;
              if (tech.id === 'aqueduct') S.maxSanitation = 120;
              alert(`Researched ${tech.name}!`);
              render();
            }
          }, unlocked ? 'Unlocked' : 'Research')
        );
        return box;
      })
    )
  );
}

function checkTechRequirements(tech) {
  if (S.denarii < tech.cost) return false;
  for (const [key, val] of Object.entries(tech.req)) {
    if (key === 'territories' && S.territories.length < val) return false;
    if (S[key] < val) return false;
  }
  return true;
}

function formatRequirements(req) {
  return 'Requires: ' + Object.entries(req)
    .map(([k, v]) => `${capitalize(k)}: ${v}`)
    .join(', ');
}

/* ==================== RELIGION RENDERING ==================== */

function renderReligionFocus(root) {
  root.append(
    el('h2', {}, '‚õ™ Piety & Religion'),
    el('div', {class:'info'},
      'Honor the Roman gods through worship, offerings, and sacred buildings. Divine favor brings powerful blessings!'
    )
  );
  
  // Piety and god favor status
  const statusCard = el('div', {class:'info', style:'background:linear-gradient(135deg,#fef3c7,#fde68a);border-color:var(--roman-gold);margin:12px 0'});
  statusCard.append(
    el('div', {style:'display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px'},
      el('div', {},
        el('b', {}, `‚ú® Piety: ${S.piety}/${S.maxPiety}`),
        el('div', {class:'tiny', style:'margin-top:4px'}, 'Piety grows through worship and religious buildings')
      ),
      S.patronGod ? el('div', {},
        el('b', {}, `${ROMAN_GODS.find(g=>g.id===S.patronGod).icon} Patron: ${ROMAN_GODS.find(g=>g.id===S.patronGod).name}`),
        el('div', {class:'tiny', style:'margin-top:4px'}, ROMAN_GODS.find(g=>g.id===S.patronGod).domain)
      ) : el('button', {class:'btn', style:'background:var(--roman-gold);color:#fff', onClick:()=>selectPatronGod()}, 'Choose Patron God')
    )
  );
  root.append(statusCard);
  
  // Gods panel
  root.append(el('h3', {style:'margin-top:16px'}, 'üèõÔ∏è The Pantheon'));
  
  const godsGrid = el('div', {class:'grid g3'});
  ROMAN_GODS.forEach(god => {
    const favor = S.godFavor[god.id] || 0;
    const isPatron = S.patronGod === god.id;
    
    const box = el('div', {
      class:'choice',
      style: isPatron ? 'outline:2px solid var(--roman-gold);background:linear-gradient(135deg,#fffbf5,#fef3c7)' : ''
    });
    
    box.append(
      el('div', {style:'font-size:32px;text-align:center;margin-bottom:8px'}, god.icon),
      el('div', {style:'font-weight:800;margin-bottom:4px;text-align:center'}, god.name),
      el('div', {class:'tiny', style:'margin-bottom:8px;text-align:center;font-style:italic;color:#7a3b00'}, god.domain),
      el('div', {class:'small', style:'margin:4px 0'}, `Favor: ${favor}/${god.maxFavor}`),
      el('div', {class:'statbar', style:'margin:4px 0'},
        el('div', {class:'bar', style:`width:${(favor/god.maxFavor)*100}%`})
      ),
      el('div', {class:'tiny', style:'margin:4px 0;color:#16a34a'}, god.bonus),
      isPatron ? el('div', {style:'text-align:center;margin-top:8px;font-weight:900;color:var(--roman-gold)'}, '‚≠ê PATRON GOD ‚≠ê') : 
        el('button', {
          class:'btn',
          style:'margin-top:8px;width:100%',
          onClick: () => {
            if(confirm(`Make ${god.name} your patron god? This cannot be easily changed.`)) {
              S.patronGod = god.id;
              alert(`${god.name} is now your patron god! Their blessings will be especially powerful.`);
              render();
            }
          }
        }, 'Choose as Patron')
    );
    
    // Show unlocked blessings
    const unlockedBlessings = god.blessings.filter(b => favor >= b.level);
    if (unlockedBlessings.length > 0) {
      box.append(
        el('div', {class:'tiny', style:'margin-top:8px;padding-top:8px;border-top:1px solid var(--line)'}, 
          el('b', {}, 'Active Blessings:')),
        ...unlockedBlessings.map(b => 
          el('div', {class:'tiny', style:'color:#16a34a;margin:2px 0'}, `‚úì ${b.name}: ${b.desc}`)
        )
      );
    }
    
    // Show next blessing
    const nextBlessing = god.blessings.find(b => favor < b.level);
    if (nextBlessing) {
      box.append(
        el('div', {class:'tiny', style:'margin-top:4px;color:#999;font-style:italic'}, 
          `Next at ${nextBlessing.level} favor: ${nextBlessing.name}`)
      );
    }
    
    godsGrid.append(box);
  });
  root.append(godsGrid);
  
  // Religious Buildings
  root.append(el('h3', {style:'margin-top:16px'}, 'üèõÔ∏è Sacred Buildings'));
  
  const buildingsGrid = el('div', {class:'grid g3'});
  RELIGIOUS_BUILDINGS.forEach(building => {
    const canAfford = S.denarii >= building.cost;
    const rarityText = building.rarity ? ` [${building.rarity.name}]` : '';
    
    const box = el('div', {class:'choice', style: !canAfford ? 'opacity:0.6' : ''});
    box.append(
      el('div', {style:'font-size:24px;text-align:center;margin-bottom:8px'}, building.icon),
      el('div', {style:'font-weight:800;margin-bottom:4px'}, building.name + rarityText),
      building.latinName ? el('div', {class:'tiny', style:'font-style:italic;color:#7a3b00;margin-bottom:4px'}, building.latinName) : '',
      el('div', {class:'small', style:'margin:4px 0'}, building.desc),
      el('div', {class:'small', style:'margin:4px 0'}, `Cost: ${building.cost} denarii`),
      el('div', {class:'small', style:'margin:4px 0;color:var(--roman-gold);font-weight:700'}, 
        `+${building.pietyGain} piety, +${building.godFavorGain} god favor/season`),
      el('button', {
        class:'btn btn-primary',
        style:'margin-top:10px;width:100%',
        disabled: !canAfford,
        onClick: !canAfford ? null : () => {
          S.denarii -= building.cost;
          S.religiousBuildings.push({type: building.id, level: 1});
          alert(`Built ${building.name}!\n\nProduces +${building.pietyGain} piety and +${building.godFavorGain} god favor each season.`);
          render();
        }
      }, canAfford ? 'Build' : 'Build (locked)')
    );
    buildingsGrid.append(box);
  });
  root.append(buildingsGrid);
  
  // Show owned religious buildings
  if (S.religiousBuildings.length > 0) {
    root.append(
      el('h3', {style:'margin-top:16px'}, '‚õ™ Your Sacred Sites'),
      el('div', {class:'grid g4'},
        ...S.religiousBuildings.map(b => {
          const building = RELIGIOUS_BUILDINGS.find(rb => rb.id === b.type);
          return el('div', {class:'choice'},
            el('div', {style:'font-size:24px;text-align:center'}, building.icon),
            el('div', {style:'font-weight:700;text-align:center;font-size:12px'}, building.name),
            el('div', {class:'tiny', style:'text-align:center;color:#16a34a;margin-top:4px'},
              `+${building.pietyGain}‚ú® +${building.godFavorGain}üèõÔ∏è`
            )
          );
        })
      )
    );
  }
  
  // Religious Actions
  root.append(el('h3', {style:'margin-top:16px'}, 'üôè Religious Actions'));
  
  const actionsGrid = el('div', {class:'grid g3'});
  RELIGIOUS_ACTIONS.forEach(action => {
    const lastUsed = S.lastReligiousAction[action.id] || 0;
    const canUse = (S.round - lastUsed) >= action.cooldown;
    
    // Check costs
    let affordable = true;
    let costText = 'Cost: ';
    const costs = [];
    for (const [resource, amount] of Object.entries(action.cost)) {
      if (resource === 'denarii' && S.denarii < amount) affordable = false;
      if (resource === 'piety' && S.piety < amount) affordable = false;
      if (resource === 'food' && S.food < amount) affordable = false;
      if (resource === 'livestock' && (S.inventory.livestock||0) < amount) affordable = false;
      if (resource === 'wine' && (S.inventory.wine||0) < amount) affordable = false;
      if (resource === 'grain' && (S.inventory.grain||0) < amount) affordable = false;
      
      if (amount > 0) {
        const symbol = resource === 'denarii' ? 'üí∞' : 
                      resource === 'piety' ? '‚ú®' : 
                      resource === 'food' ? 'üåæ' :
                      resource === 'livestock' ? 'üêë' :
                      resource === 'wine' ? 'üç∑' :
                      resource === 'grain' ? 'üåæ' : resource;
        costs.push(`${amount}${symbol}`);
      }
    }
    costText += costs.join(', ') || 'Free';
    
    const disabled = !canUse || !affordable;
    const box = el('div', {class:'choice', style: disabled ? 'opacity:0.6' : ''});
    
    box.append(
      el('div', {style:'font-size:24px;text-align:center;margin-bottom:8px'}, action.icon),
      el('div', {style:'font-weight:800;margin-bottom:4px'}, action.name),
      el('div', {class:'small', style:'margin:4px 0'}, action.desc),
      el('div', {class:'tiny', style:'margin:4px 0'}, costText),
      action.cooldown > 0 ? el('div', {class:'tiny', style:'margin:4px 0;color:#999'}, 
        `Cooldown: ${action.cooldown} seasons ${!canUse ? '(' + (action.cooldown - (S.round - lastUsed)) + ' left)' : ''}`) : null,
      el('button', {
        class:'btn btn-primary',
        style:'margin-top:10px;width:100%',
        disabled: disabled,
        onClick: disabled ? null : () => performReligiousAction(action)
      }, !canUse ? 'On Cooldown' : !affordable ? 'Cannot Afford' : 'Perform')
    );
    actionsGrid.append(box);
  });
  root.append(actionsGrid);
}

function selectPatronGod() {
  if (S.patronGod) {
    alert('You already have a patron god!');
    return;
  }
  // This will be handled by clicking the Choose Patron button on individual gods
  alert('Choose a patron god from the Pantheon above!');
}

function performReligiousAction(action) {
  // Deduct costs
  for (const [resource, amount] of Object.entries(action.cost)) {
    if (resource === 'denarii') S.denarii -= amount;
    if (resource === 'piety') S.piety -= amount;
    if (resource === 'food') S.food -= amount;
    if (resource === 'livestock') S.inventory.livestock -= amount;
    if (resource === 'wine') S.inventory.wine -= amount;
    if (resource === 'grain') S.inventory.grain -= amount;
  }
  
  // Apply effects
  let message = `${action.icon} ${action.name}\n\n`;
  
  if (action.effect.godFavor && S.patronGod) {
    S.godFavor[S.patronGod] = Math.min(100, (S.godFavor[S.patronGod] || 0) + action.effect.godFavor);
    message += `+${action.effect.godFavor} favor with ${ROMAN_GODS.find(g=>g.id===S.patronGod).name}\n`;
  }
  
  if (action.effect.piety) {
    S.piety = Math.min(S.maxPiety, S.piety + action.effect.piety);
    message += `+${action.effect.piety} piety\n`;
  }
  
  if (action.effect.happiness) {
    S.happiness = Math.min(100, S.happiness + action.effect.happiness);
    message += `+${action.effect.happiness}% happiness\n`;
  }
  
  if (action.effect.favor) {
    S.favor += action.effect.favor;
    message += `+${action.effect.favor} favor\n`;
  }
  
  if (action.effect.pop) {
    S.pop += action.effect.pop;
    message += `+${action.effect.pop} population\n`;
  }
  
  if (action.effect.reputation) {
    S.reputation += action.effect.reputation;
    message += `+${action.effect.reputation} reputation\n`;
  }
  
  if (action.effect.reveal) {
    message += '\nüîÆ The augurs have spoken! Future events will be more favorable.\n';
    // Could add actual event prediction logic here
  }
  
  if (action.effect.blessing && S.patronGod) {
    message += '\n‚ú® Divine blessing invoked! Your patron god grants special favor!\n';
    // Apply patron-specific bonus
    const god = ROMAN_GODS.find(g => g.id === S.patronGod);
    if (god.id === 'jupiter') {
      S.troops += 30;
      message += '+30 troops from Jupiter!\n';
    } else if (god.id === 'mars') {
      S.morale = Math.min(100, S.morale + 25);
      message += '+25% morale from Mars!\n';
    } else if (god.id === 'venus') {
      S.happiness = Math.min(100, S.happiness + 25);
      S.pop += 15;
      message += '+25% happiness and +15 pop from Venus!\n';
    } else if (god.id === 'ceres') {
      S.food += 300;
      message += '+300 food from Ceres!\n';
    } else if (god.id === 'mercury') {
      S.denarii += 1500;
      message += '+1500 denarii from Mercury!\n';
    } else if (god.id === 'minerva') {
      S.reputation += 15;
      S.favor += 10;
      message += '+15 reputation and +10 favor from Minerva!\n';
    }
  }
  
  if (action.effect.territory_bonus) {
    if (S.territories.length > 0) {
      const territory = rpick(S.territories);
      S.consecratedTerritories.push(territory);
      message += `\n‚ú® Territory consecrated! ${territory} receives divine blessing (+25% production).\n`;
    }
  }
  
  // Set cooldown
  S.lastReligiousAction[action.id] = S.round;
  
  alert(message);
  render();
}

/* ==================== NEW RENDER FUNCTIONS ==================== */

function renderAchievements(root) {
  root.append(
    el('h2', {}, 'üèÜ Achievements'),
    el('div', {class:'info'}, `Unlocked: ${S.achievements.length}/${ACHIEVEMENTS.length}`)
  );
  
  const grid = el('div', {class:'grid g3'});
  ACHIEVEMENTS.forEach(ach => {
    const unlocked = S.achievements.includes(ach.id);
    const badge = el('div', {class:`achievement-badge ${unlocked ? '' : 'locked'}`});
    badge.append(
      el('span', {style:'font-size:20px'}, ach.icon),
      el('div', {},
        el('div', {style:'font-weight:900;font-size:13px'}, ach.name + (unlocked ? ' ‚úì' : '')),
        el('div', {class:'tiny'}, ach.desc),
        unlocked ? null : el('div', {class:'tiny', style:'color:var(--roman-gold);margin-top:4px'}, 
          'Reward: ' + Object.entries(ach.reward).map(([k,v])=>`+${v} ${k}`).join(', '))
      )
    );
    grid.append(badge);
  });
  root.append(grid);
}

function renderQuests(root) {
  root.append(
    el('h2', {}, 'üìú Active Quests'),
    el('div', {class:'info'}, 'Complete quests for rewards! Quests rotate automatically.')
  );
  
  if (S.activeQuests.length === 0) {
    root.append(el('div', {style:'text-align:center;padding:40px;color:#999'}, 'No active quests. They will appear as you play!'));
    return;
  }
  
  S.activeQuests.forEach(quest => {
    const template = quest.template;
    const progress = Math.min(quest.progress, quest.target);
    const progressPct = Math.floor((progress / quest.target) * 100);
    
    const questCard = el('div', {class:'quest-card'});
    questCard.append(
      el('div', {class:'quest-header'},
        el('div', {class:'quest-title'}, `${template.icon} ${template.name}`),
        el('div', {class:'quest-progress'}, `${progress}/${quest.target}`)
      ),
      el('div', {class:'quest-desc'}, template.desc),
      el('div', {class:'progress-bar-container'},
        el('div', {class:'progress-bar-fill', style:`width:${progressPct}%`})
      ),
      el('div', {class:'quest-reward', style:'margin-top:8px'}, 
        'üéÅ Reward: ' + Object.entries(template.reward).map(([k,v])=>`+${v} ${k}`).join(', '))
    );
    root.append(questCard);
  });
}

/* ==================== DIPLOMACY RENDERING ==================== */
// Render the diplomacy panel showing relations with neighbouring factions.
function renderDiplomacyFocus(root) {
  root.append(
    el('h2', {}, 'ü§ù Diplomacy & Relations'),
    el('div', {class:'info'},
      'Manage relations with neighbouring tribes and rival factions. Positive relations unlock benefits, negative relations invite raids.'
    )
  );
  // Ensure diplomacy object exists
  const relations = S.diplomacy || {};
  const table = el('div', {class:'card', style:'padding:12px'});
  Object.keys(relations).forEach(key => {
    const value = relations[key];
    const name = key.charAt(0).toUpperCase() + key.slice(1);
    // Build a simple meter for each relation
    const barContainer = el('div', {style:'margin:8px 0'});
    barContainer.append(
      el('div', {style:'display:flex;justify-content:space-between;margin-bottom:4px'},
        el('div', {style:'font-weight:600'}, name),
        el('div', {style:'font-size:12px;color:#555'}, (value>0?'+':'') + value)
      ),
      el('div', {style:'background:#eee;width:100%;height:8px;border-radius:4px;overflow:hidden'},
        el('div', {style:`height:100%;width:${Math.max(0, Math.min(100, (value + 100)/2))}%;background:${value >= 0 ? '#4ade80' : '#f87171'}`})
      )
    );
    table.append(barContainer);
  });
  root.append(table);
  // Provide hint if diplomacy is locked
  if (!S.diplomacyUnlocked) {
    root.append(el('div', {class:'info', style:'margin-top:12px;color:#b91c1c'}, 'Unlock Envoy Diplomacy technology to activate diplomacy options.'));
  }
}

function renderResourceCombos(root) {
  root.append(
    el('h2', {}, '‚öôÔ∏è Resource Combinations'),
    el('div', {class:'info'}, 'Combine resources for powerful effects!')
  );
  
  const grid = el('div', {class:'grid g2'});
  RESOURCE_COMBOS.forEach(combo => {
    const canAfford = canAffordCombo(combo);
    const card = el('div', {class:'combo-card', style: canAfford ? '' : 'opacity:0.6'});
    
    const costDisplay = el('div', {class:'combo-cost'});
    Object.entries(combo.cost).forEach(([resource, amount]) => {
      const have = S.inventory[resource] || 0;
      const good = GOODS.find(g => g.id === resource);
      costDisplay.append(
        el('div', {class:'combo-cost-item', style: have >= amount ? 'background:#dcfce7' : 'background:#fee2e2'},
          `${good.emoji} ${amount} ${good.name}`
        )
      );
    });
    
    card.append(
      el('div', {style:'font-weight:900;margin-bottom:6px'}, `${combo.icon} ${combo.name}`),
      el('div', {class:'small', style:'margin-bottom:8px'}, combo.desc),
      costDisplay,
      el('button', {
        class:'btn btn-primary',
        style:'margin-top:10px;width:100%',
        disabled: !canAfford,
        onClick: canAfford ? () => {
          if (useResourceCombo(combo)) render();
        } : null
      }, canAfford ? 'Use Combination' : 'Insufficient Resources')
    );
    grid.append(card);
  });
  root.append(grid);
}

function renderEmergencyActions(root) {
  root.append(
    el('h2', {}, 'üö® Emergency Actions'),
    el('div', {class:'info warning'}, '‚ö†Ô∏è Use these only in desperate situations! They have long cooldowns.')
  );
  
  const grid = el('div', {class:'grid g2'});
  EMERGENCY_ACTIONS.forEach(action => {
    const canUse = canUseEmergencyAction(action.id);
    const lastUsed = S.emergencyActionsUsed[action.id] || 0;
    const cooldownRemaining = action.cooldown - (S.round - lastUsed);
    
    const card = el('div', {class:'combo-card', style: canUse ? '' : 'opacity:0.6'});
    card.append(
      el('div', {style:'font-weight:900;margin-bottom:6px'}, `${action.icon} ${action.name}`),
      el('div', {class:'small', style:'margin-bottom:8px'}, action.desc),
      !canUse ? el('div', {class:'tiny', style:'color:#dc2626;margin-bottom:8px'}, 
        `Cooldown: ${cooldownRemaining} seasons remaining`) : null,
      action.cost ? el('div', {class:'small', style:'margin-bottom:8px'}, `Cost: ${action.cost} favor`) : null,
      el('button', {
        class:'btn',
        style:'margin-top:10px;width:100%;' + (canUse ? 'background:#dc2626;color:#fff' : ''),
        disabled: !canUse,
        onClick: canUse ? () => {
          if (confirm(`Use ${action.name}?\n\n${action.desc}\n\nThis action has a ${action.cooldown} season cooldown.`)) {
            if (useEmergencyAction(action.id)) render();
          }
        } : null
      }, canUse ? 'Use Action' : 'On Cooldown')
    );
    grid.append(card);
  });
  root.append(grid);
}

function renderResults() {
  const card = el('div', {class:'card'});
  const ending = ENDINGS.find(e => e.cond(S)) || ENDINGS[ENDINGS.length - 1];
  
  card.append(
    el('h2', {}, `Final Outcome ‚Äî Season ${S.round}`),
    el('div', {class:'milestone'},
      el('h2', {style:'margin:0 0 8px 0'}, ending.title),
      el('div', {}, ending.text)
    ),
    el('h3', {}, 'Final Statistics'),
    el('div', {class:'grid g4'},
      statPill('üí∞', 'Denarii', S.denarii, 'gold'),
      statPill('üë•', 'Population', S.pop, 'normal'),
      statPill('üó∫Ô∏è', 'Territories', S.territories.length, 'normal'),
      statPill('üè≠', 'Buildings', S.productionBuildings.length, 'normal')
    ),
    el('div', {style:'margin-top:16px;display:flex;gap:12px;flex-wrap:wrap'},
      el('button', {
        class:'btn',
        style:'background:#2563eb;color:#fff;flex:1;min-width:150px',
        onClick:exportStats
      }, 'üìä Export Stats'),
      el('button', {class:'btn btn-primary', style:'flex:1;min-width:150px', onClick:() => location.reload()}, 'üîÑ Play Again'),
      el('button', {
        class:'btn btn-success', 
        style:'background:#16a34a;color:#fff;flex:1;min-width:150px',
        onClick:() => {
          S.infiniteMode = true;
          S.maxRounds = 999999;
          S.stage = 'game';
          S.mapTab = 0;
          S.nextRaidRound = S.round + 5;
          alert('‚ôæÔ∏è INFINITE MODE ACTIVATED!\n\n‚ú® Features:\n‚Ä¢ New territories every 7 seasons\n‚Ä¢ New production buildings every 10 seasons\n‚Ä¢ New technologies every 15 seasons\n‚Ä¢ New cities every 20 seasons\n‚Ä¢ Enemy raids every 5 seasons\n‚Ä¢ 2.5x price volatility\n‚Ä¢ Harder raids as you grow\n‚Ä¢ ALL new content has Latin names and rarity!\n\nThe empire never ends!\nGood luck, eternal founder!');
          render();
        }
      }, '‚ôæÔ∏è Infinite Seasons')
    )
  );
  
  app.textContent = '';
  app.append(card);
}

function statPill(icon, label, value, type = 'normal') {
  const colors = {
    gold: 'background:var(--roman-gold);color:#fff',
    warning: 'background:#fef2f2;color:#991b1b;border-color:#fca5a5',
    success: 'background:#f0fdf4;color:#166534;border-color:#86efac',
    normal: ''
  };
  
  return el('div', {class:'pill', style:colors[type]},
    icon + ' ',
    el('span', {class:'small'}, label + ':'),
    ' ',
    el('b', {}, typeof value === 'number' ? fmt(value) : value)
  );
}

/* ==================== BOOT ==================== */
render();

// === Balance Patch: Warehouse Nerf (auto-applied if present) ===
setTimeout(()=>{
  try{
    if (typeof PRODUCTION_BUILDINGS !== 'undefined') {
      for (const b of PRODUCTION_BUILDINGS) {
        if (b.id === 'warehouse' || (b.name && b.name.toLowerCase() === 'warehouse')) {
          b.cost = 145;
          b.capacity = 30; // interpreted as +30 capacity
          console.log('[Patch] Warehouse cost set to 145 and capacity bonus +30');
        }
      }
    }
    if (typeof BUILDINGS !== 'undefined') {
      for (const k in BUILDINGS) {
        const b = BUILDINGS[k];
        if (b && (b.id === 'warehouse' || (b.name||'').toLowerCase()==='warehouse')) {
          b.cost = 145;
          b.capacity = 30;
          console.log('[Patch] Warehouse cost set to 145 and capacity bonus +30');
        }
      }
    }
  }catch(e){ console.warn('Warehouse patch error', e); }
}, 0);

// === Patch Hook: Handle postPenalty for expired combo effects ===
(function(){
  const _tick = window.advanceSeason || window.nextRound;
  if (!_tick) return;
  window.advanceSeason = window.nextRound = function(){
    const beforeSeason = (typeof S!=='undefined') ? JSON.stringify(S) : null;
    const rv = _tick.apply(this, arguments);
    try{
      if (S && Array.isArray(S.activeEffects)) {
        // Clean up any effects that just expired last tick and carry a postPenalty
        S.activeEffects = S.activeEffects.map(e=>{
          if (e && e.duration===0 && e.postPenalty && !e.__postApplied) {
            const p = e.postPenalty;
            const roll = (n)=> Math.floor(Math.random()*n)+1;
            const down = roll(p.penaltyRange||3);
            // Decrease grain and vineyard outputs by 1-3 for one season via temporary flags
            S.__postFeastPenalty = {rounds:1, grainDown:down, vineyardDown:down};
            e.__postApplied = true;
            console.log('[Patch] Applied post-feast penalty:', S.__postFeastPenalty);
          }
          return e;
        });
      }
      // Apply any one-season penalties to production
      if (S && S.__postFeastPenalty) {
        const pen = S.__postFeastPenalty;
        if (typeof S.productionPenalty === 'undefined') S.productionPenalty = {};
        S.productionPenalty.grain = (S.productionPenalty.grain||0) - (pen.grainDown||1);
        S.productionPenalty.vineyard = (S.productionPenalty.vineyard||0) - (pen.vineyardDown||1);
        pen.rounds -= 1;
        if (pen.rounds <= 0) delete S.__postFeastPenalty;
      }
    }catch(e){ console.warn('postPenalty hook error', e); }
    return rv;
  };
})();

// --- Extracted from original HTML --- 

// === Accessibility helpers: keyboard activation for interactive divs ===
document.addEventListener('DOMContentLoaded', () => {
  const makeButtonLike = (el) => {
    if (!el) return;
    if (!['BUTTON','A','INPUT','SELECT','TEXTAREA','SUMMARY'].includes(el.tagName)) {
      if (!el.hasAttribute('role')) el.setAttribute('role','button');
      if (!el.hasAttribute('tabindex')) el.setAttribute('tabindex','0');
      el.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          el.click();
        }
      });
    }
  };
  document.querySelectorAll('.choice, .territory, [data-buttonlike]').forEach(makeButtonLike);
});

// --- Extracted from original HTML --- 

// === Minimal focus trap for elements with [data-overlay] ===
(function(){
  function trapFocus(container){
    const focusable = container.querySelectorAll('a,button,input,select,textarea,[tabindex]:not([tabindex="-1"])');
    if (!focusable.length) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    function onKey(e){
      if (e.key === 'Escape') {
        container.dispatchEvent(new CustomEvent('overlay:close', {bubbles:true}));
      }
      if (e.key !== 'Tab') return;
      if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
      else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
    }
    container.addEventListener('keydown', onKey);
    container.addEventListener('overlay:destroy', () => container.removeEventListener('keydown', onKey), {once:true});
    first.focus();
  }
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('[data-overlay]').forEach(trapFocus);
    document.addEventListener('overlay:open', (e) => { if (e.target && e.target.matches && e.target.matches('[data-overlay]')) trapFocus(e.target); });
  });
})();

// --- Extracted from original HTML --- 

// === Scalable Building Caps tied to Map Regions ===
(function(){
  function getUnlockedRegions(){
    try {
      const territoriesPerTab = 12;
      const owned = (window.S && Array.isArray(S.territories)) ? S.territories.length : 0;
      return Math.max(1, Math.ceil(owned / territoriesPerTab));
    } catch(e){ return 1; }
  }
  function regionScale(){
    const regions = getUnlockedRegions();
    return 1 + (regions - 1) * 0.25;
  }
  function ensureState(){
    if (typeof window.S === 'undefined') window.S = {};
    const S = window.S;
    // Initialize building counts.  We extend the original settlement
    // buildings with new cross-functional structures that interlink
    // other game systems (market, barracks, granary, shrine).
    if (!S.buildingCounts) {
      S.buildingCounts = {
        house: 0,
        bath: 0,
        warehouse: 0,
        fort: 0,
        market: 0,
        barracks: 0,
        granary: 0,
        shrine: 0
      };
    } else {
      // Ensure newly added building types have a default count when
      // loading an existing save that predates this update.
      S.buildingCounts.market = S.buildingCounts.market || 0;
      S.buildingCounts.barracks = S.buildingCounts.barracks || 0;
      S.buildingCounts.granary = S.buildingCounts.granary || 0;
      S.buildingCounts.shrine = S.buildingCounts.shrine || 0;
    }
    if (typeof S.baseHousing === 'undefined') S.baseHousing = S.housing || 0;
    if (typeof S.baseCapacity === 'undefined') S.baseCapacity = S.capacity || 0;
    if (typeof S.baseSanitationCap === 'undefined') S.baseSanitationCap = typeof S.maxSanitation === 'number' ? S.maxSanitation : 100;
  }
  function getCap(name){
    const S = window.S || {};
    const regions = getUnlockedRegions();
    switch(name){
      case 'sanitation':
        const techCap = (typeof S.maxSanitation === 'number' ? S.maxSanitation : (S.baseSanitationCap || 100));
        return techCap + (regions - 1) * 10;
      case 'capacity':
        return S.capacity || 0;
      case 'housing':
        return S.housing || 0;
      default:
        return 0;
    }
  }
  function computeCaps(){
    ensureState();
    const S = window.S;
    const scale = regionScale();
    const houseGain = Math.round((S.buildingCounts.house || 0) * 35 * scale);
    S.housing = Math.max(0, Math.floor(S.baseHousing + houseGain));
    const wareGain = Math.round((S.buildingCounts.warehouse || 0) * 40 * scale);
    S.capacity = Math.max(0, Math.floor(S.baseCapacity + wareGain));
    S.maxSanitationEffective = getCap('sanitation');
    if (typeof S.sanitation === 'number'){
      S.sanitation = Math.min(S.sanitation, S.maxSanitationEffective);
    }
    window.getUnlockedRegions = getUnlockedRegions;
    window.regionScale = regionScale;
  }
  document.addEventListener('DOMContentLoaded', computeCaps);
  window.addEventListener('app:stateRestored', computeCaps);
  window.addEventListener('territory:conquered', computeCaps);
  window.CapSystem = { computeCaps, getCap, getUnlockedRegions, regionScale };
})();
</script>
<script>
(function(){
  // Utility: wait for all CSS animations in a container to finish
  function waitForAnimations(container){
    const nodes = container ? Array.from(container.querySelectorAll('.battle-unit, .battle-spark')) : [];
    if (nodes.length === 0) return Promise.resolve();
    let pending = 0;
    let resolveAll;
    const all = new Promise(r => resolveAll = r);
    nodes.forEach(el => {
      const style = getComputedStyle(el);
      const countStr = style.animationIterationCount;
      const count = (countStr === 'infinite') ? Infinity : parseFloat(countStr);
      if (!isFinite(count) || count === 0) return;
      pending++;
      el.addEventListener('animationend', function onEnd(){
        el.removeEventListener('animationend', onEnd, { once: true });
        pending--;
        if (pending <= 0) resolveAll();
      }, { once: true });
    });
    if (pending === 0) resolveAll();
    return all;
  }
  window.waitForAnimations = waitForAnimations;

  // Observe for battle-animation containers and auto-resolve afterward
  let resolvePending = false;
  function attemptResolve(){
    if (resolvePending) return false; // Prevent multiple calls
    resolvePending = true;
    
    setTimeout(() => { resolvePending = false; }, 500); // Reset after 500ms
    
    try {
      if (typeof window.resolveBattle === 'function') {
        window.resolveBattle();
        return true;
      }
      // Dispatch an event that game code can listen for
      document.dispatchEvent(new CustomEvent('battle:resolve'));
      // Try clicking any known resolve/close buttons
      const btn = document.querySelector('[data-battle-resolve], .close-battle, .battle-close, .btn-resolve-battle');
      if (btn) { btn.click(); return true; }
    } catch(e){}
    return false;
  }

  const seen = new WeakSet();
  const handleArena = (arena)=>{
    if (!arena || seen.has(arena)) return;
    seen.add(arena);
    waitForAnimations(arena).then(()=>{
      attemptResolve();
      document.dispatchEvent(new CustomEvent('battleAnimationsDone', { detail: { arena } }));
    });
  };

  // Immediate: any existing arena
  document.querySelectorAll('.battle-animation').forEach(handleArena);

  // Observe future additions
  const mo = new MutationObserver((mutations)=>{
    for (const m of mutations){
      m.addedNodes && m.addedNodes.forEach(n => {
        if (!(n instanceof Element)) return;
        if (n.matches && n.matches('.battle-animation')) handleArena(n);
        n.querySelectorAll && n.querySelectorAll('.battle-animation').forEach(handleArena);
      });
    }
  });
  mo.observe(document.documentElement, { childList: true, subtree: true });
})();

// === KEYBOARD SHORTCUTS ===
(function() {
  document.addEventListener('keydown', function(e) {
    // Don't trigger if user is typing in an input
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // Don't trigger during intro or results screens
    if (!window.S || window.S.stage !== 'game') return;
    
    switch(e.key.toLowerCase()) {
      case ' ': // Space = simulate season (most common action)
        e.preventDefault();
        if (typeof simulateSeason === 'function') simulateSeason();
        break;
      case 's': // S = save
        e.preventDefault();
        if (typeof saveGame === 'function') saveGame();
        break;
      case 'h': // H = help
        e.preventDefault();
        const help = 'üèõÔ∏è KEYBOARD SHORTCUTS üèõÔ∏è\n\n' +
          'SPACE = Simulate Season\n' +
          'S = Save Game\n' +
          'H = Help\n' +
          '1-9 = Switch Tabs\n' +
          'ESC = Close dialogs';
        alert(help);
        break;
      case '1': changeFocus('resources'); break;
      case '2': changeFocus('map'); break;
      case '3': changeFocus('trade'); break;
      case '4': changeFocus('military'); break;
      case '5': changeFocus('settlement'); break;
      case '6': changeFocus('religion'); break;
      case '7': changeFocus('tech'); break;
      case '8': changeFocus('tracker'); break;
      case '9': changeFocus('achievements'); break;
    }
  });
  
  function changeFocus(newFocus) {
    if (window.S && window.S.stage === 'game') {
      window.S.focus = newFocus;
      if (typeof render === 'function') render();
    }
  }
})();

// === Fast Battles toggle wiring ===
(function(){
  function applyFastToggle(on){
    document.body.classList.toggle('fast-battles', !!on);
    try { localStorage.setItem('fastBattles', on ? '1' : '0'); } catch(e){}
  }
  function readStored(){
    try { return localStorage.getItem('fastBattles') === '1'; } catch(e){ return false; }
  }
  function initFastToggle(){
    var el = document.getElementById('fast-battles-toggle');
    if (!el) return;
    // Initialize from storage or current body state
    var initial = document.body.classList.contains('fast-battles') || readStored();
    el.checked = initial;
    applyFastToggle(initial);
    el.addEventListener('change', function(){
      applyFastToggle(el.checked);
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initFastToggle);
  } else {
    initFastToggle();
  }
})();

</script>
</body></html>

<script>
// === WONDERS SYSTEM ===
(function() {
  const WONDERS = [
    {
      id: 'colosseum',
      name: 'The Colosseum',
      icon: 'üèüÔ∏è',
      description: 'The greatest amphitheater ever built. Hosts spectacular games that inspire loyalty and awe throughout the empire.',
      costs: {
        stone: 500,
        wood: 300,
        iron: 200,
        denarii: 1000
      },
      benefits: {
        influence: 100,
        piety: 50,
        populationBoost: 50,
        soldierRecruitBonus: 0.25  // 25% more soldiers per recruitment
      },
      requirementText: 'Requires: 5+ territories conquered',
      checkRequirement: (S) => getUnlockedRegions().length >= 5
    },
    {
      id: 'pantheon',
      name: 'The Pantheon',
      icon: '‚õ™',
      description: 'A temple to all the gods of Rome. Its magnificent dome inspires devotion and brings divine favor.',
      costs: {
        stone: 600,
        iron: 150,
        luxuries: 100,
        denarii: 1200
      },
      benefits: {
        piety: 150,
        influence: 75,
        pietyPerSeason: 5,  // +5 piety each season
        tradeBonus: 0.15  // 15% more from trade
      },
      requirementText: 'Requires: 100+ piety',
      checkRequirement: (S) => S.piety >= 100
    },
    {
      id: 'circus_maximus',
      name: 'Circus Maximus',
      icon: 'üèá',
      description: 'The grandest chariot racing venue in the world. Thrilling races keep the populace entertained and content.',
      costs: {
        stone: 400,
        wood: 350,
        iron: 150,
        denarii: 800
      },
      benefits: {
        population: 100,
        influence: 80,
        populationGrowth: 0.20,  // 20% faster population growth
        denariiPerSeason: 50  // +50 denarii each season
      },
      requirementText: 'Requires: 200+ population',
      checkRequirement: (S) => S.population >= 200
    },
    {
      id: 'aqua_claudia',
      name: 'Aqua Claudia',
      icon: 'üåä',
      description: 'A massive aqueduct bringing fresh water from distant mountains. Enables unprecedented urban growth.',
      costs: {
        stone: 800,
        iron: 250,
        wood: 200,
        denarii: 1500
      },
      benefits: {
        sanitation: 100,
        population: 150,
        housingBonus: 500,  // +500 housing capacity
        maxSanitation: 250  // Increases sanitation cap
      },
      requirementText: 'Requires: 50+ sanitation',
      checkRequirement: (S) => S.sanitation >= 50
    },
    {
      id: 'forum_romanum',
      name: 'Forum Romanum',
      icon: 'üèõÔ∏è',
      description: 'The heart of Roman public life. A grand plaza for commerce, politics, and justice.',
      costs: {
        stone: 450,
        wood: 200,
        luxuries: 80,
        denarii: 900
      },
      benefits: {
        influence: 120,
        denarii: 500,
        tradeBonus: 0.25,  // 25% more from trade
        influencePerSeason: 5  // +5 influence each season
      },
      requirementText: 'Requires: 150+ influence',
      checkRequirement: (S) => S.influence >= 150
    },
    {
      id: 'palatine_palace',
      name: 'Palatine Palace',
      icon: 'üëë',
      description: 'An opulent palace befitting the ruler of Rome. Symbol of imperial power and majesty.',
      costs: {
        stone: 700,
        wood: 300,
        luxuries: 200,
        denarii: 2000
      },
      benefits: {
        influence: 200,
        piety: 75,
        luxuryGeneration: 10,  // +10 luxuries per season
        allResourceBonus: 0.10  // 10% bonus to all resource generation
      },
      requirementText: 'Requires: 3+ wonders built',
      checkRequirement: (S) => {
        const built = Object.values(S.wonders || {}).filter(w => w.built).length;
        return built >= 3;
      }
    }
  ];

  // Initialize wonders in state
  function initWonders() {
    if (!window.S) return;
    if (!window.S.wonders) {
      window.S.wonders = {};
      // Safely access WONDERS array
      const wondersList = typeof WONDERS !== 'undefined' ? WONDERS : (window.WondersSystem?.WONDERS || []);
      if (wondersList && wondersList.length > 0) {
        wondersList.forEach(wonder => {
          if (wonder && wonder.id) {
            window.S.wonders[wonder.id] = { built: false };
          }
        });
      }
    }
  }

  // Check if can build wonder
  function canBuildWonder(wonder) {
    if (!wonder || !wonder.id) return false;
    const S = window.S;
    if (!S) return false;
    
    // Ensure wonders are initialized
    if (!S.wonders) initWonders();
    if (!S.wonders) return false;
    
    if (S.wonders[wonder.id] && S.wonders[wonder.id].built) return false;
    if (!wonder.checkRequirement || !wonder.checkRequirement(S)) return false;
    
    if (wonder.costs) {
      for (let [resource, cost] of Object.entries(wonder.costs)) {
        if ((S[resource] || 0) < cost) return false;
      }
    }
    return true;
  }

  // Build wonder
  function buildWonder(wonderId) {
    // Safely access WONDERS array
    const wondersList = typeof WONDERS !== 'undefined' ? WONDERS : (window.WondersSystem?.WONDERS || []);
    const wonder = wondersList.find(w => w && w.id === wonderId);
    if (!wonder) return;
    
    const S = window.S;
    if (!S) return;
    
    // Ensure wonders is initialized
    if (!S.wonders) {
      initWonders();
    }
    if (!S.wonders || !S.wonders[wonderId]) return;
    
    if (!canBuildWonder(wonder)) {
      alert('Cannot build this wonder! Check requirements and costs.');
      return;
    }
    
    // Deduct costs
    if (wonder.costs) {
      for (let [resource, cost] of Object.entries(wonder.costs)) {
        S[resource] = Math.max(0, (S[resource] || 0) - cost);
      }
    }
    
    // Mark as built
    S.wonders[wonderId].built = true;
    
    // Apply immediate benefits
    if (wonder.benefits) {
      if (wonder.benefits.influence) S.influence = (S.influence || 0) + wonder.benefits.influence;
      if (wonder.benefits.piety) S.piety = (S.piety || 0) + wonder.benefits.piety;
      if (wonder.benefits.population) S.population = (S.population || 0) + wonder.benefits.population;
      if (wonder.benefits.denarii) S.denarii = (S.denarii || 0) + wonder.benefits.denarii;
      if (wonder.benefits.sanitation) S.sanitation = (S.sanitation || 0) + wonder.benefits.sanitation;
      if (wonder.benefits.housingBonus) S.baseHousing = (S.baseHousing || 0) + wonder.benefits.housingBonus;
      if (wonder.benefits.maxSanitation) S.maxSanitation = (S.maxSanitation || 0) + wonder.benefits.maxSanitation;
    }
    
    // Trigger achievement
    if (typeof triggerAchievement === 'function') {
      triggerAchievement(`wonder_${wonderId}`, `Built ${wonder.name}!`);
    }
    
    // Show completion message
    alert(`üèõÔ∏è ${wonder.name} completed! ${wonder.description}`);
    
    if (typeof render === 'function') render();
    if (typeof computeCaps === 'function') computeCaps();
  }

  // Apply per-season wonder benefits
  function applyWonderBenefits() {
    if (!window.S) return;
    
    // Ensure wonders are initialized
    if (!window.S.wonders) {
      initWonders();
    }
    if (!window.S.wonders) return;
    
    // Safely access WONDERS array
    const wondersList = typeof WONDERS !== 'undefined' ? WONDERS : (window.WondersSystem?.WONDERS || []);
    if (!wondersList || wondersList.length === 0) return;
    
    wondersList.forEach(wonder => {
      if (wonder && wonder.id && window.S.wonders[wonder.id] && window.S.wonders[wonder.id].built) {
        const benefits = wonder.benefits;
        if (!benefits) return;
        
        if (benefits.pietyPerSeason) {
          window.S.piety = (window.S.piety || 0) + benefits.pietyPerSeason;
        }
        if (benefits.denariiPerSeason) {
          window.S.denarii = (window.S.denarii || 0) + benefits.denariiPerSeason;
        }
        if (benefits.influencePerSeason) {
          window.S.influence = (window.S.influence || 0) + benefits.influencePerSeason;
        }
        if (benefits.luxuryGeneration) {
          window.S.luxuries = (window.S.luxuries || 0) + benefits.luxuryGeneration;
        }
      }
    });
  }

  // Get wonder multipliers for calculations
  function getWonderMultipliers() {
    if (!window.S) return {
      soldierRecruitBonus: 0,
      tradeBonus: 0,
      populationGrowth: 0,
      allResourceBonus: 0
    };
    
    // Ensure wonders are initialized
    if (!window.S.wonders) {
      initWonders();
    }
    if (!window.S.wonders) return {
      soldierRecruitBonus: 0,
      tradeBonus: 0,
      populationGrowth: 0,
      allResourceBonus: 0
    };
    
    // Safely access WONDERS array
    const wondersList = typeof WONDERS !== 'undefined' ? WONDERS : (window.WondersSystem?.WONDERS || []);
    if (!wondersList || wondersList.length === 0) return {
      soldierRecruitBonus: 0,
      tradeBonus: 0,
      populationGrowth: 0,
      allResourceBonus: 0
    };
    
    const multipliers = {
      soldierRecruitBonus: 0,
      tradeBonus: 0,
      populationGrowth: 0,
      allResourceBonus: 0
    };
    
    wondersList.forEach(wonder => {
      if (wonder && wonder.id && window.S.wonders[wonder.id] && window.S.wonders[wonder.id].built) {
        const benefits = wonder.benefits;
        if (!benefits) return;
        
        if (benefits.soldierRecruitBonus) multipliers.soldierRecruitBonus += benefits.soldierRecruitBonus;
        if (benefits.tradeBonus) multipliers.tradeBonus += benefits.tradeBonus;
        if (benefits.populationGrowth) multipliers.populationGrowth += benefits.populationGrowth;
        if (benefits.allResourceBonus) multipliers.allResourceBonus += benefits.allResourceBonus;
      }
    });
    
    return multipliers;
  }

  // Render wonders tab
  function renderWonders() {
    initWonders();
    const S = window.S;
    
    // Safely access WONDERS array
    const wondersList = typeof WONDERS !== 'undefined' ? WONDERS : (window.WondersSystem?.WONDERS || []);
    if (!wondersList || wondersList.length === 0) {
      return '<div class="info">Wonders system not available</div>';
    }
    
    const wonderCards = wondersList.map(wonder => {
      const isBuilt = S.wonders[wonder.id]?.built;
      const canBuild = !isBuilt && canBuildWonder(wonder);
      const meetsReqs = wonder.checkRequirement(S);
      
      const costsHTML = Object.entries(wonder.costs)
        .map(([resource, cost]) => {
          const hasEnough = (S[resource] || 0) >= cost;
          const className = hasEnough ? 'affordable' : 'unaffordable';
          const icon = getResourceIcon(resource);
          return `
            <div class="wonder-cost-item ${className}">
              ${icon} ${cost}<br/>
              <span class="tiny">(${S[resource] || 0})</span>
            </div>
          `;
        })
        .join('');
      
      const benefitsHTML = Object.entries(wonder.benefits)
        .map(([key, value]) => {
          let text = '';
          if (key === 'influence') text = `+${value} Influence`;
          else if (key === 'piety') text = `+${value} Piety`;
          else if (key === 'population' || key === 'populationBoost') text = `+${value} Population`;
          else if (key === 'denarii') text = `+${value} Denarii`;
          else if (key === 'sanitation') text = `+${value} Sanitation`;
          else if (key === 'pietyPerSeason') text = `+${value} Piety/season`;
          else if (key === 'denariiPerSeason') text = `+${value} Denarii/season`;
          else if (key === 'influencePerSeason') text = `+${value} Influence/season`;
          else if (key === 'soldierRecruitBonus') text = `+${Math.round(value * 100)}% soldier recruitment`;
          else if (key === 'tradeBonus') text = `+${Math.round(value * 100)}% trade income`;
          else if (key === 'populationGrowth') text = `+${Math.round(value * 100)}% population growth`;
          else if (key === 'housingBonus') text = `+${value} housing capacity`;
          else if (key === 'maxSanitation') text = `+${value} max sanitation`;
          else if (key === 'luxuryGeneration') text = `+${value} luxuries/season`;
          else if (key === 'allResourceBonus') text = `+${Math.round(value * 100)}% all resources`;
          
          return text ? `<div class="wonder-benefit">‚úì ${text}</div>` : '';
        })
        .filter(Boolean)
        .join('');
      
      const statusHTML = isBuilt 
        ? '<span class="wonder-status built">‚úì BUILT</span>'
        : canBuild
          ? `<button class="btn btn-success" onclick="window.WondersSystem.buildWonder('${wonder.id}')">Build Wonder</button>`
          : `<div class="small" style="color:#dc2626">
              ${!meetsReqs ? wonder.requirementText : 'Insufficient resources'}
            </div>`;
      
      return `
        <div class="wonder-card ${isBuilt ? 'built' : ''}">
          <div class="wonder-header">
            <div class="wonder-icon">${wonder.icon}</div>
            <div>
              <div class="wonder-title">${wonder.name}</div>
              ${isBuilt ? '' : `<div class="tiny">${wonder.requirementText}</div>`}
            </div>
          </div>
          <div class="wonder-description">${wonder.description}</div>
          ${!isBuilt ? `
            <div class="divider"></div>
            <strong class="small">Costs:</strong>
            <div class="wonder-costs">${costsHTML}</div>
          ` : ''}
          <div class="divider"></div>
          <div class="wonder-benefits">
            <strong>Benefits:</strong>
            ${benefitsHTML}
          </div>
          ${statusHTML}
        </div>
      `;
    }).join('');
    
    const builtCount = Object.values(S.wonders).filter(w => w.built).length;
    const totalWonders = wondersList.length;
    
    return `
      <div class="card">
        <h2>üèõÔ∏è Great Wonders of Rome</h2>
        <p class="subtitle">
          Construct legendary monuments that will stand for eternity. Each wonder grants powerful permanent bonuses.
          <br/><strong>Wonders Built: ${builtCount}/${totalWonders}</strong>
        </p>
        <div class="divider"></div>
        <div class="grid g2">
          ${wonderCards}
        </div>
      </div>
    `;
  }

  // Helper function
  function getResourceIcon(resource) {
    const icons = {
      food: 'üåæ', wood: 'ü™µ', stone: 'ü™®', iron: '‚öíÔ∏è',
      denarii: 'üí∞', soldiers: '‚öîÔ∏è', population: 'üë•',
      influence: '‚≠ê', piety: 'üôè', luxuries: 'üíé'
    };
    return icons[resource] || 'üì¶';
  }

  // Helper to get unlocked regions (assuming this exists in the game)
  function getUnlockedRegions() {
    if (typeof window.getUnlockedRegions === 'function') {
      return window.getUnlockedRegions();
    }
    // Fallback
    return window.S?.regions?.filter(r => r.owned) || [];
  }

  // Helper to trigger achievements (assuming this exists)
  function triggerAchievement(id, name) {
    if (typeof window.checkAchievements === 'function') {
      // Game has achievement system, it will handle it
      window.checkAchievements();
    } else {
      // Simple fallback
      console.log('Achievement unlocked:', name);
    }
  }

  // Hook into season simulation to apply wonder benefits
  const originalSimulate = window.simulateSeason;
  if (originalSimulate) {
    window.simulateSeason = function() {
      // Ensure wonders are initialized before applying benefits
      if (window.S && !window.S.wonders) {
        initWonders();
      }
      applyWonderBenefits();
      originalSimulate.apply(this, arguments);
    };
  }

  // Initialize
  document.addEventListener('DOMContentLoaded', initWonders);
  window.WondersSystem = { 
    WONDERS, 
    buildWonder, 
    renderWonders, 
    getWonderMultipliers,
    applyWonderBenefits,
    initWonders
  };
})();

// === RANDOM EVENTS SYSTEM ===
(function() {
  const EVENTS = [
    {
      id: 'plague',
      type: 'disaster',
      icon: '‚ò†Ô∏è',
      title: 'Plague Outbreak',
      description: 'A terrible plague sweeps through your territories. The sick and dying fill the streets.',
      weight: 10,
      effects: {
        population: -30,
        food: -50,
        denarii: -100
      },
      requirements: { population: 50 }
    },
    {
      id: 'earthquake',
      type: 'disaster',
      icon: 'üåã',
      title: 'Devastating Earthquake',
      description: 'The earth shakes violently! Buildings collapse and infrastructure is damaged.',
      weight: 8,
      effects: {
        stone: -80,
        wood: -60,
        population: -20
      },
      requirements: { stone: 50 }
    },
    {
      id: 'flood',
      type: 'disaster',
      icon: 'üåä',
      title: 'Great Flood',
      description: 'Heavy rains cause rivers to overflow, destroying crops and supplies.',
      weight: 10,
      effects: {
        food: -100,
        wood: -40
      },
      requirements: { food: 50 }
    },
    {
      id: 'merchant_caravan',
      type: 'opportunity',
      icon: 'üê´',
      title: 'Wealthy Merchant Caravan',
      description: 'A caravan from the East offers exotic goods at favorable prices.',
      weight: 15,
      effects: {
        denarii: 200,
        luxuries: 30,
        influence: 15
      },
      requirements: { denarii: 100 }
    },
    {
      id: 'rich_mine',
      type: 'opportunity',
      icon: '‚õèÔ∏è',
      title: 'Rich Mineral Deposit',
      description: 'Your miners discover a vein of precious metals and quality stone!',
      weight: 12,
      effects: {
        iron: 100,
        stone: 80,
        denarii: 150
      },
      requirements: { iron: 20 }
    },
    {
      id: 'bumper_harvest',
      type: 'opportunity',
      icon: 'üåæ',
      title: 'Bumper Harvest',
      description: 'Perfect weather and good fortune bless your farms with abundant yields.',
      weight: 15,
      effects: {
        food: 150,
        population: 15
      },
      requirements: { food: 30 }
    },
    {
      id: 'gladiator_games',
      type: 'opportunity',
      icon: '‚öîÔ∏è',
      title: 'Victorious Gladiator',
      description: 'Your gladiators win a prestigious tournament, bringing glory and wealth to Rome!',
      weight: 10,
      effects: {
        denarii: 250,
        influence: 25,
        piety: 10
      },
      requirements: { denarii: 150, influence: 30 }
    },
    {
      id: 'conspiracy',
      type: 'intrigue',
      icon: 'üó°Ô∏è',
      title: 'Conspiracy Uncovered',
      description: 'Your spies uncover a plot against you. Swift action prevents disaster.',
      weight: 8,
      effects: {
        influence: -20,
        denarii: -80,
        population: -10
      },
      requirements: { influence: 40 }
    },
    {
      id: 'ally_betrayal',
      type: 'intrigue',
      icon: 'üíî',
      title: 'Ally\'s Betrayal',
      description: 'A trusted general attempts to seize power. You must act quickly to maintain control.',
      weight: 6,
      effects: {
        soldiers: -20,
        influence: -30,
        denarii: -100
      },
      requirements: { soldiers: 40 }
    },
    {
      id: 'diplomatic_triumph',
      type: 'intrigue',
      icon: 'ü§ù',
      title: 'Diplomatic Triumph',
      description: 'Your envoys negotiate a favorable treaty, bringing tribute and prestige.',
      weight: 12,
      effects: {
        denarii: 200,
        influence: 40,
        luxuries: 20
      },
      requirements: { influence: 50 }
    },
    {
      id: 'festival',
      type: 'opportunity',
      icon: 'üé≠',
      title: 'Grand Festival',
      description: 'The people celebrate with games and feasts, boosting morale across the realm.',
      weight: 10,
      effects: {
        piety: 20,
        population: 10,
        denarii: -50
      },
      requirements: { piety: 20 }
    },
    {
      id: 'pirate_raid',
      type: 'disaster',
      icon: 'üè¥‚Äç‚ò†Ô∏è',
      title: 'Pirate Raid',
      description: 'Pirates strike your coastal settlements, stealing goods and disrupting trade.',
      weight: 8,
      effects: {
        denarii: -150,
        luxuries: -20,
        food: -40
      },
      requirements: { denarii: 100 }
    }
  ];

  // Initialize event tracking in state
  function initEventSystem() {
    if (!window.S) return;
    if (!window.S.events) {
      window.S.events = {
        lastEventSeason: 0,
        eventHistory: []
      };
    }
  }

  // Check if event requirements are met
  function meetsRequirements(event) {
    if (!event.requirements) return true;
    const S = window.S;
    for (let [resource, amount] of Object.entries(event.requirements)) {
      if ((S[resource] || 0) < amount) return false;
    }
    return true;
  }

  // Trigger random event
  function triggerRandomEvent() {
    if (!window.S || window.S.stage !== 'game') return;
    
    initEventSystem();
    
    // Only trigger events every 5-10 seasons
    const seasonsSinceLastEvent = window.S.season - window.S.events.lastEventSeason;
    if (seasonsSinceLastEvent < 5) return;
    
    // 30% chance each eligible season
    if (Math.random() > 0.3) return;
    
    // Filter eligible events
    const eligibleEvents = EVENTS.filter(e => meetsRequirements(e));
    if (eligibleEvents.length === 0) return;
    
    // Weighted random selection
    const totalWeight = eligibleEvents.reduce((sum, e) => sum + e.weight, 0);
    let random = Math.random() * totalWeight;
    let selectedEvent = null;
    
    for (let event of eligibleEvents) {
      random -= event.weight;
      if (random <= 0) {
        selectedEvent = event;
        break;
      }
    }
    
    if (selectedEvent) {
      showEventModal(selectedEvent);
      window.S.events.lastEventSeason = window.S.season;
      window.S.events.eventHistory.push({
        id: selectedEvent.id,
        season: window.S.season
      });
    }
  }

  // Show event modal
  function showEventModal(event) {
    const overlay = document.createElement('div');
    overlay.className = 'event-overlay';
    
    const modal = document.createElement('div');
    modal.className = 'event-modal';
    
    const effectsHTML = Object.entries(event.effects)
      .map(([resource, amount]) => {
        const sign = amount > 0 ? '+' : '';
        const className = amount > 0 ? 'positive' : 'negative';
        const icon = getResourceIcon(resource);
        return `<div class="event-effect-item ${className}">${icon} ${sign}${amount} ${resource}</div>`;
      })
      .join('');
    
    modal.innerHTML = `
      <div class="event-header">${event.title}</div>
      <div class="event-icon">${event.icon}</div>
      <div class="event-description">${event.description}</div>
      <div class="event-effects">
        <strong>Effects:</strong>
        ${effectsHTML}
      </div>
      <button class="btn btn-primary" onclick="window.acceptEvent()">Continue</button>
    `;
    
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
    
    // Store current event for processing
    window._currentEvent = event;
    
    // Close on overlay click
    overlay.onclick = () => {
      window.acceptEvent();
    };
  }

  // Accept and apply event effects
  window.acceptEvent = function() {
    const event = window._currentEvent;
    if (!event) return;
    
    // Apply effects
    for (let [resource, amount] of Object.entries(event.effects)) {
      if (window.S[resource] !== undefined) {
        window.S[resource] = Math.max(0, (window.S[resource] || 0) + amount);
      }
    }
    
    // Remove modal
    document.querySelectorAll('.event-modal, .event-overlay').forEach(el => el.remove());
    window._currentEvent = null;
    
    // Re-render
    if (typeof render === 'function') render();
  };

  // Helper function to get resource icon
  function getResourceIcon(resource) {
    const icons = {
      food: 'üåæ', wood: 'ü™µ', stone: 'ü™®', iron: '‚öíÔ∏è',
      denarii: 'üí∞', soldiers: '‚öîÔ∏è', population: 'üë•',
      influence: '‚≠ê', piety: 'üôè', luxuries: 'üíé'
    };
    return icons[resource] || 'üì¶';
  }

  // Hook into season simulation
  const originalSimulate = window.simulateSeason;
  if (originalSimulate) {
    window.simulateSeason = function() {
      originalSimulate.apply(this, arguments);
      setTimeout(triggerRandomEvent, 500); // Delay slightly after season ends
    };
  }

  // Initialize on load
  document.addEventListener('DOMContentLoaded', initEventSystem);
  window.RandomEvents = { triggerRandomEvent, initEventSystem };
})();

// === ENHANCED BATTLE ANIMATIONS ===
(function() {
  // Add particle effects during battles - OPTIMIZED
  window.addBattleParticles = function() {
    const effects = document.querySelector('.battle-effects');
    if (!effects) return;
    
    // Check if already animating to prevent duplicate calls
    if (effects.dataset.animating === 'true') return;
    effects.dataset.animating = 'true';
    
    // Create fewer particles with faster animations
    for (let i = 0; i < 3; i++) {  // Reduced from 5 to 3
      setTimeout(() => {
        const particle = document.createElement('div');
        particle.textContent = ['‚öîÔ∏è', 'üõ°Ô∏è', 'üí•'][Math.floor(Math.random() * 3)];
        particle.style.cssText = `
          position: absolute;
          font-size: 20px;
          left: ${20 + Math.random() * 60}%;
          top: ${20 + Math.random() * 60}%;
          animation: particle-float 0.8s ease-out forwards;
          pointer-events: none;
        `;
        effects.appendChild(particle);
        setTimeout(() => particle.remove(), 800);  // Reduced from 2000ms to 800ms
      }, i * 150);  // Reduced delay from 400ms to 150ms
    }
    
    // Reset flag after animation completes
    setTimeout(() => {
      effects.dataset.animating = 'false';
    }, 1000);
  };
  
  // Auto-trigger particles once when battle screen renders
  let particlesTriggered = new WeakSet(); // Use WeakSet to track which battle screens were animated
  const observer = new MutationObserver(() => {
    const battleScreen = document.querySelector('.battle-screen');
    if (battleScreen && !particlesTriggered.has(battleScreen)) {
      particlesTriggered.add(battleScreen);
      setTimeout(addBattleParticles, 200);  // Reduced initial delay
    }
  });
  observer.observe(document.body, {childList: true, subtree: true});
})();
</script>

<style>
/* Particle animation for battles */
@keyframes particle-float {
  0% {
    opacity: 0;
    transform: translate(0, 0) scale(0.5) rotate(0deg);
  }
  50% {
    opacity: 1;
    transform: translate(var(--tx, 20px), var(--ty, -30px)) scale(1) rotate(180deg);
  }
  100% {
    opacity: 0;
    transform: translate(var(--tx, 40px), var(--ty, -60px)) scale(0.3) rotate(360deg);
  }
}

/* Random Events Modal */
.event-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--paper);
  border: 3px solid var(--roman-gold);
  border-radius: 20px;
  padding: 24px;
  max-width: 500px;
  width: 90%;
  box-shadow: 0 10px 40px rgba(0,0,0,0.3);
  z-index: 10000;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from { transform: translate(-50%, -60%); opacity: 0; }
  to { transform: translate(-50%, -50%); opacity: 1; }
}

.event-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 9999;
  animation: fadeIn 0.3s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.event-header {
  font-size: 24px;
  font-weight: 900;
  margin-bottom: 12px;
  color: var(--roman-red);
  text-align: center;
}

.event-icon {
  font-size: 48px;
  text-align: center;
  margin: 12px 0;
}

.event-description {
  font-size: 15px;
  line-height: 1.6;
  margin-bottom: 16px;
  text-align: center;
  color: #333;
}

.event-effects {
  background: #f9f9f9;
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 12px;
  margin: 16px 0;
}

.event-effect-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 0;
  font-size: 14px;
}

.event-effect-item.positive { color: #16a34a; font-weight: 700; }
.event-effect-item.negative { color: #dc2626; font-weight: 700; }

/* Wonders Section */
.wonder-card {
  border: 2px solid var(--roman-gold);
  border-radius: 16px;
  padding: 16px;
  background: linear-gradient(135deg, #fff9e6, #ffffff);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.wonder-card::before {
  content: '';
  position: absolute;
  top: -50%;
  right: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(184,134,11,0.1), transparent 70%);
  animation: shimmer 8s linear infinite;
}

@keyframes shimmer {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.wonder-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 12px 24px rgba(184,134,11,0.2);
}

.wonder-card.built {
  background: linear-gradient(135deg, #d4af37, #ffd700);
  border-color: #b8860b;
}

.wonder-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
  position: relative;
  z-index: 1;
}

.wonder-icon {
  font-size: 36px;
  filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.2));
}

.wonder-title {
  font-size: 18px;
  font-weight: 900;
  color: var(--roman-red);
}

.wonder-description {
  font-size: 13px;
  color: #555;
  margin-bottom: 12px;
  line-height: 1.4;
  position: relative;
  z-index: 1;
}

.wonder-costs {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 8px;
  margin: 12px 0;
  position: relative;
  z-index: 1;
}

.wonder-cost-item {
  background: white;
  border: 1px solid var(--line);
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  font-size: 12px;
}

.wonder-cost-item.affordable { border-color: #16a34a; background: #f0fdf4; }
.wonder-cost-item.unaffordable { border-color: #dc2626; background: #fef2f2; }

.wonder-benefits {
  background: rgba(255,255,255,0.8);
  border: 1px solid var(--line);
  border-radius: 8px;
  padding: 10px;
  margin: 12px 0;
  font-size: 13px;
  position: relative;
  z-index: 1;
}

.wonder-benefit {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  color: #16a34a;
  font-weight: 700;
}

.wonder-status {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
  margin-top: 8px;
}

.wonder-status.built {
  background: #16a34a;
  color: white;
}

.wonder-status.available {
  background: #fbbf24;
  color: #78350f;
}

/* Enhanced battle animations */
.battle-animation {
  box-shadow: inset 0 2px 8px rgba(0,0,0,0.1);
}

.battle-unit {
  transition: filter 0.3s;
  will-change: transform;
}

.battle-unit:hover {
  filter: drop-shadow(3px 3px 6px rgba(0,0,0,.5)) brightness(1.2);
}

/* Shake effect for battle impacts */
@keyframes battle-shake {
  0%, 100% { transform: translateY(-50%) translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateY(-50%) translateX(-2px); }
  20%, 40%, 60%, 80% { transform: translateY(-50%) translateX(2px); }
}

.battle-animation.shaking .unit-left,
.battle-animation.shaking .unit-right {
  animation: battle-shake 0.5s;
}
</style>
